---
title: 3. redis 原理篇
date: 2020-05-03
categories:
    - 存储
tags:
    - Kafka
---

Redis 原理篇

<!-- more -->

## 1. 原理篇概述
原理篇我们将介绍 Redis 的如下内容:
- IO模型
- 网络协议
- 持久化
- 管道
- 事务
- 小对象压缩

## 1. IO 模型
**首先Redis 是个单线程程序**。

### 1.1 redis 高并发的原因
为什么单线程还能支持如此高的并发量，原因有下面几个:
1. 高效的事务和使用内存保存所有数据
2. 使用 IO 多路复用处理并发的客户端连接
3. 指令队列和响应队列

#### 高效的事务和内存使用
通常的事务处理机制希望囊括用户的所有操作:
    - **事务总是需要等待来自用户的输入**，同时还要支持潜在大量并发需求，那么系统大部分时间处于空闲状态。
    - 于此同时事务总体沿用交互式客户端/服务器风格，一次一个请求有语句。请求与结果在应用代码和数据库服务器之间来回交互。**这种交互式的事务处理，大量时间耗费在应用程序与数据库之间的网络通信上**。数据库总是在等待应用程序提交下一个请求。
    - 在这种类型的数据库中，为了获得足够的吞吐量，需要能够同时处理多个事务

而像 Redis 这种单线程串行的系统则将**人为交互**从事务中移除，并且**不支持交互式的多语句事务**。应用程序必须提交整个事务代码作为存储过程打包发送到数据库，同时**事务所需的所有数据已经全部加载到内存中**，使得存储过程高效执行，而无需等待网络和磁盘I/O。

**与直觉相反，内存数据库的性能欧式并不是因为它们不需要从磁盘读取。如果有足够的内存，即便是基于磁盘的存储引擎，也可能不需要从磁盘读取，因为操作系统将最近使用的磁盘块缓存在内存中。相反内存数据库可以更快是因为它们避免使用写磁盘的格式对内存数据结构编码的开销。**

内存数据库另一个有意思地方是提供了基于磁盘索引难以实现的数据结构，典型的是 Redis。内存数据库使用所谓的**反缓存方法**，在内存不够用时将最近最少使用的数据写到磁盘，可以支持比内存更大的数据集。

正因为 Redis 是单线程，所以要小心使用 Redis 指令，特别是那些时间复杂度为 O(n) 级别的指令。因为单条指令执行太长时间就会导致 Redis 卡顿。

#### IO 多路复用
使用 IO 多路复用可以解决 C10K 问题，IO 多路复用的原理读者可以自行查阅相关资料，这里不再赘述。

#### 指令队列和响应队列
Redis 会将每个客户端套接字都关联一个指令队列，客户端指令通过队列来排队顺序处理。

Redis 同样也会为每个客户端套接字关联一个响应队列。Redis 通过响应队列将指令的返回结果恢复给客户端。

## 2. 通信协议
RESP 是 Redis 序列化协议(Redis Serialization Protocol)的简写。它是一种文件协议，优势在于简单，解析性能好。具体的协议细节，这里我们不在赘述，有兴趣大家可以直接阅读 [《Redis深度历险：核心原理与应用实践》](https://book.douban.com/subject/30386804/)。

## 3. 持久化
Redis 持久化机制有两种:
1. 快照: 
    - 一次全量备份
    - 是内存数据的二进制序列化形式，存储上非常紧凑
2. AOF 日志:
    - 连续增量备份
    - 是内存数据修改的指令记录文本
    - 在运行的过程中会慢慢变大，数据库重启需要加载 AOF 日志进行指令重放，为了避免重放时间过长，需要定期进行 AOF 日志压缩

### 3.1 快照原理
持久化是不能影响正常的客户端请求的。所以持久化的同时，内存数据还在改变。我们需要一种机制来获取所有数据的一致性视图。Redis 使用的是操作系统的多进程 COW(Copy On Write)。

Redis 在持久化时会调用 glibc 的函数 fork 一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。COW 保证了父进程对内存数据的修改不会影响子进程的内存。子进程可以拿到 Redis 所有数据的一致性视图。

### 3.2 AOF
AOF 日志存储的是 Redis 服务器的顺序指令序列，只记录堆内存进行修改的指令。

Redis 会在收到客户端修改指令后，进行参数校验、逻辑处理，如果没有问题，就立即将指令文本存储到 AOF 日志中。也就是说，**先执行指令，在将日志存盘**。

#### AOF 重写
Redis 提供了 bgrewriteaof 指令对 AOF 进行压缩，其原理是创建一个子进程对内存进行遍历，转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完成后，再将操作期间发生的增量AOF 日志追加到新的 AOF日志文件中。追加完成后新的 AOF 日志文件将替代旧的 AOF 日志文件。

#### fsync 
通常文件写操作是将数据写到了操作系统的页缓存，然后由操作系统定期将页缓存刷入磁盘(调用 fsync 函数)。fsync 是一个磁盘 IO 操作。

生产环境中，Redis 通常是每个 1s 左右进行一次 fsync 操作，这个时间是可配置的。这是在数据安全性和性能之间的权衡。

### 3.3 持久化策略
无论是快照遍历内存，然后大块写磁盘；还是AOF 定期 fsync 都会增加系统负载。所以通常 Redis 的主节点不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，通常没有客户端请求的压力。

### 3.4 Redis 4.0 混合持久化
Redis 4.0 增加了一个新的持久化选型-混合持久化。如下图所示:
1. 将 rdb 文件(快照的结果文件)和增量的 AOF 日志文件存在一起
2. 这里 AOF 日志不再是全量日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志(很小)
3. 于是 Redis 重启时，先加载 rdb，在重放增量 AOF 日志，就可以避免之前的 AOF 全量重放的低效率

![混合持久化](/images/redis/rdb_aof.png)

## 4. 管道
Pipeline 管道是 Redis 客户端提供的一种技术，通过对管道内的指令改变读写顺序，并合并连续的写请求和读请求，从而减少网络 IO 的次数，从而提升性能。注意这跟服务器没有直接关系。

redis 自带的压力测试工具 redis-benchmark 可以进行管道的压力测试:

```bash
> redis-benchmark -t set -q
# -P 表示管道内并行的请求数量
> redis-benchmark -t set -q -P 2

```

## 5. Redis 事务
Redis 如下命令用于启动事务:
1. multi: begin 开启事务
2. exec: commit 提交
3. discard: rollback 回滚

```bash
> multi
OK
> incr books
QUEUED
> incr books
QUEUED
> exec
(interger) 1
(interger) 2
```

上面的指令演示了一个完整的事务过程。所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开始执行整个事务队列，执行完成之后一次性返回所有指令的运行结果。因为 Redis 单线程特性，可以保证他们能得到顺序执行，而不被打断。

但是 **Redis的事务不具备原子性**，当事务中的一连串命令，发生错误时，发生错误的指令不会影响接下来的其他指令的运行，更不会回滚。Redis 是单线程，准确来说它仅仅满足事务隔离性中的串行化。

discard 作用仅仅是丢弃事务队列里的命名。此处不存在回滚一说，因为命令压根没有执行。

为了避免事务中多次发送命令带来了多次网络开销，通常事务与管道一起使用。

```bash
pip = redis.pipeline(transaction=True)
pipe.multi()
pipe.incr("books")
pipe.incr("books")
values = pipe.execute()
```
