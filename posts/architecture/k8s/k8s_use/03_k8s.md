---
weight: 1
title: "Pod"
date: 2020-08-03T22:00:00+08:00
lastmod: 2020-08-03T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "什么是 Pod"
featuredImage: 

tags: ["k8s"]
categories: ["architecture"]

lightgallery: true

---

接下来我们要先来认识 k8s 中最基础的 API 对象 POD，这是学习后面所有的编排对象的基础。

## 1. k8s 中的对象操作
### 1.1 配置文件定义
在 k8s 中要创建一个容器的第一步是为其编写配置文件，即：把容器的定义、参数、配置，统统记录在一个 YAML 文件中。就像下面这样:

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

像这样的一个 YAML 文件，对应到 Kubernetes 中，就是一个 API Object（API 对象），其中:
1. kind 字段，指定了这个 API 对象的类型（Type）
2. spec.template 定义了Pod 的模版
3. metadata: API 对象的“标识”，即元数据
4. metadata.labels: 就是一组 key-value 格式的标签
  - selector.matchLabels: labels 与 matchLabels 组合定义了控制器与被控制对象之间的关联关系
  - 像上面这样使用一种 API 对象（Deployment）管理另一种 API 对象（Pod）的方法，在 Kubernetes 中，叫作 **控制器模式（controller pattern）** ，Deployment 扮演的正是 Pod 的控制器的角色。
4. metadata.annotations: 
  - 在 Metadata 中，还有一个与 Labels 格式、层级完全相同的字段叫 Annotations
  - Annotations 专门用来携带 key-value 格式的内部信息
  - 所谓内部信息，指的是对这些信息感兴趣的，是 Kubernetes 组件本身，而不是用户
  - 所以 Annotations 大多数 Annotations，都是在 Kubernetes 运行过程中，被自动加在这个 API 对象上

### 1.2 对象创建
配置文件准备好之后，使用下面的命令就可以创建对应的 API 对象:

```bash
# 创建 API 对象
$ kubectl create -f nginx-deployment.yaml

# kubectl get 指令的作用，就是从 Kubernetes 里面获取（GET）指定的 API 对象
# -l 参数，即获取所有匹配 app: nginx 标签的 Pod
# 在命令行中，所有 key-value 格式的参数，都使用“=”而非“:”表示
$ kubectl get pods -l app=nginx

# kubectl describe 命令，查看一个 API 对象的细节
$ kubectl describe pod nginx-deployment-67594d6bf6-9gdvr
```

在 kubectl describe 命令返回的结果中，需要特别关注是 Events（事件），它包含了Kubernetes 执行的过程中，对 API 对象的所有重要操作。这正是我们将来进行 Debug 的重要依据。如果有异常发生，你一定要第一时间查看这些 Events。

### 1.3 声明式 API
假如现在我们要对 Nginx 服务进行升级，把它的镜像版本从 1.7.9 升级为 1.8，要怎么做呢？
1. 首先，需要修改 YAML 文件
2. 然后，执行 `kubectl replace -f nginx-deployment.yaml`

但是更正宗的写法是使用 kubectl apply 命令，来统一进行 Kubernetes 对象的创建和更新操作：

```bash

$ kubectl apply -f nginx-deployment.yaml

# 修改nginx-deployment.yaml的内容

$ kubectl apply -f nginx-deployment.yaml
```

这正是 Kubernetes“声明式 API”所推荐的使用方法。也就是说，作为用户，你不必关心当前的操作是创建，还是更新，你执行的命令始终是 kubectl apply，而 Kubernetes 则会根据 YAML 文件的内容变化，自动进行具体的处理。

这个流程的好处是，它有助于帮助开发和运维人员，围绕着可以版本化管理的 YAML 文件，而不是“行踪不定”的命令行进行协作，从而大大降低开发人员和运维人员之间的沟通成本。

如果通过容器镜像，我们能够保证应用本身在开发与部署环境里的一致性的话，那么现在，Kubernetes 项目通过这些 YAML 文件，就保证了应用的“部署参数”在开发与部署环境中的一致性。而当应用本身发生变化时，开发人员和运维人员可以依靠容器镜像来进行同步；当应用部署参数发生变化时，这些 YAML 文件就是他们相互沟通和信任的媒介。

### 1.4 添加 volume
接下来，我们再在这个 Deployment 中尝试声明一个 Volume。

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.8
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: nginx-vol
      volumes:
      - name: nginx-vol
        emptyDir: {}
```

如上，Deployment 的 Pod 模板部分添加了一个 volumes 字段，定义了这个 Pod 声明的所有 Volume。它的名字叫作 nginx-vol，类型是 emptyDir。emptyDir 类型其实就等同于我们之前讲过的 Docker 的隐式 Volume 参数，即：不显式声明宿主机目录的 Volume。所以，Kubernetes 也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的 Volume 目录上。

Kubernetes 也提供了显式的 Volume 定义，它叫作 hostPath:

```yaml   
    volumes:
      - name: nginx-vol
        hostPath: 
          path:  " /var/data"
```

### 1.5 进入容器
你还可以使用 kubectl exec 指令，进入到这个 Pod 当中:

```bash
$ kubectl exec -it nginx-deployment-5c678cfb6d-lg9lw -- /bin/bash
# ls /usr/share/nginx/html
```

### 1.6 对象删除
最后，如果想删除这个 Nginx Deployment 的话，直接执行：

```bash
$ kubectl delete -f nginx-deployment.yaml
```