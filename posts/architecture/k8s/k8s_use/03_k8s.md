---
weight: 1
title: "Pod"
date: 2020-08-03T22:00:00+08:00
lastmod: 2020-08-03T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "什么是 Pod"
featuredImage: 

tags: ["k8s"]
categories: ["architecture"]

lightgallery: true

---

接下来我们要先来认识 k8s 中最基础的 API 对象 POD，这是学习后面所有的编排对象的基础。

## 1. 容器化一个应用
在介绍 Pod 之前，我们先来借助一个例子，熟悉一下 k8s 的基本操作以及如何容器化一个应用。

### 1.1 配置文件定义
在 k8s 中要创建一个容器的第一步是为其编写配置文件，即：把容器的定义、参数、配置，统统记录在一个 YAML 文件中。就像下面这样:

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

像这样的一个 YAML 文件，对应到 Kubernetes 中，就是一个 API Object（API 对象），其中:
1. kind 字段，指定了这个 API 对象的类型（Type）
2. spec.template 定义了Pod 的模版
3. metadata: API 对象的“标识”，即元数据
4. metadata.labels: 就是一组 key-value 格式的标签
  - selector.matchLabels: labels 与 matchLabels 组合定义了控制器与被控制对象之间的关联关系
  - 像上面这样使用一种 API 对象（Deployment）管理另一种 API 对象（Pod）的方法，在 Kubernetes 中，叫作 **控制器模式（controller pattern）** ，Deployment 扮演的正是 Pod 的控制器的角色。
4. metadata.annotations: 
  - 在 Metadata 中，还有一个与 Labels 格式、层级完全相同的字段叫 Annotations
  - Annotations 专门用来携带 key-value 格式的内部信息
  - 所谓内部信息，指的是对这些信息感兴趣的，是 Kubernetes 组件本身，而不是用户
  - 所以 Annotations 大多数 Annotations，都是在 Kubernetes 运行过程中，被自动加在这个 API 对象上

### 1.2 对象创建
配置文件准备好之后，使用下面的命令就可以创建对应的 API 对象:

```bash
# 创建 API 对象
$ kubectl create -f nginx-deployment.yaml

# kubectl get 指令的作用，就是从 Kubernetes 里面获取（GET）指定的 API 对象
# -l 参数，即获取所有匹配 app: nginx 标签的 Pod
# 在命令行中，所有 key-value 格式的参数，都使用“=”而非“:”表示
$ kubectl get pods -l app=nginx

# kubectl describe 命令，查看一个 API 对象的细节
$ kubectl describe pod nginx-deployment-67594d6bf6-9gdvr
```

在 kubectl describe 命令返回的结果中，需要特别关注是 Events（事件），它包含了Kubernetes 执行的过程中，对 API 对象的所有重要操作。这正是我们将来进行 Debug 的重要依据。如果有异常发生，你一定要第一时间查看这些 Events。

### 1.3 声明式 API
假如现在我们要对 Nginx 服务进行升级，把它的镜像版本从 1.7.9 升级为 1.8，要怎么做呢？
1. 首先，需要修改 YAML 文件
2. 然后，执行 `kubectl replace -f nginx-deployment.yaml`

但是更正宗的写法是使用 kubectl apply 命令，来统一进行 Kubernetes 对象的创建和更新操作：

```bash

$ kubectl apply -f nginx-deployment.yaml

# 修改nginx-deployment.yaml的内容

$ kubectl apply -f nginx-deployment.yaml
```

这正是 Kubernetes“声明式 API”所推荐的使用方法。也就是说，作为用户，你不必关心当前的操作是创建，还是更新，你执行的命令始终是 kubectl apply，而 Kubernetes 则会根据 YAML 文件的内容变化，自动进行具体的处理。

这个流程的好处是，它有助于帮助开发和运维人员，围绕着可以版本化管理的 YAML 文件，而不是“行踪不定”的命令行进行协作，从而大大降低开发人员和运维人员之间的沟通成本。

如果通过容器镜像，我们能够保证应用本身在开发与部署环境里的一致性的话，那么现在，Kubernetes 项目通过这些 YAML 文件，就保证了应用的“部署参数”在开发与部署环境中的一致性。而当应用本身发生变化时，开发人员和运维人员可以依靠容器镜像来进行同步；当应用部署参数发生变化时，这些 YAML 文件就是他们相互沟通和信任的媒介。

### 1.4 添加 volume
接下来，我们再在这个 Deployment 中尝试声明一个 Volume。

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.8
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: nginx-vol
      volumes:
      - name: nginx-vol
        emptyDir: {}
```

如上，Deployment 的 Pod 模板部分添加了一个 volumes 字段，定义了这个 Pod 声明的所有 Volume。它的名字叫作 nginx-vol，类型是 emptyDir。emptyDir 类型其实就等同于我们之前讲过的 Docker 的隐式 Volume 参数，即：不显式声明宿主机目录的 Volume。所以，Kubernetes 也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的 Volume 目录上。

Kubernetes 也提供了显式的 Volume 定义，它叫作 hostPath:

```yaml   
    volumes:
      - name: nginx-vol
        hostPath: 
          path:  " /var/data"
```

### 1.5 进入容器
你还可以使用 kubectl exec 指令，进入到这个 Pod 当中:

```bash
$ kubectl exec -it nginx-deployment-5c678cfb6d-lg9lw -- /bin/bash
# ls /usr/share/nginx/html
```

### 1.6 对象删除
最后，如果想删除这个 Nginx Deployment 的话，直接执行：

```bash
$ kubectl delete -f nginx-deployment.yaml
```

## 2. 为什么我们需要 Pod
### 2.1 成组调度
Pod，是 Kubernetes 项目中最小的 API 对象，更专业的说法可以描述为: Pod，是 Kubernetes 项目的原子调度单位。那为什么我们需要 Pod 呢？如果我们做一个类比:
1. 容器的本质是进程，是未来云计算系统中的进程
2. 容器镜像就是这个系统里的“.exe”安装包
3. Kubernetes 则是未来云计算的操作系统
4. 在操作系统里进程是以进程组的方式组织在一起
5. Kubernetes 项目所做的，其实就是将“进程组”的概念映射到了容器技术中，并使其称为一等公民
6. 之所以这么做的原因是应用往往都存在着类似于“进程和进程组”的关系，更具体地说，就是这些应用之间有着密切的协作关系，使得它们必须部署在同一台机器上

所以 Pod 的存在就是为了解决成组调度（gang scheduling）的问题。Pod 是 Kubernetes 里的原子调度单位。这就意味着，Kubernetes 项目的调度器，是统一按照 Pod 而非容器的资源需求进行计算的。

像这样容器间的紧密协作，我们可以称为“超亲密关系”。这些具有“超亲密关系”容器的典型特征包括但不限于：
1. 互相之间会发生直接的文件交换
2. 使用 localhost 或者 Socket 文件进行本地通信
3. 会发生非常频繁的远程调用
4. 需要共享某些 Linux Namespace（比如，一个容器要加入另一个容器的 Network Namespace）等等。

注:再次强调一下：容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的 init 进程或者 systemd 那样拥有进程管理的功能。

### 2.2 Pod 的实现原理
首先，Pod 只是一个逻辑概念。所以不存在什么 Pod 的边界，存在的依旧是 Linux Namespace 和 Cgroups。本质上 Pod，其实是一组共享了某些资源的容器。具体的说：Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。

而为了避免使用 `docker run --net=B --volumes-from=B --name=A image-A ...` 让 Pod 内的容器引入不对等关系，Pod 的实现使用了一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起，这样的组织关系，可以用下面这样一个示意图来表达：

![rootfs](/images/k8s/k8s_use/infra.webp)


Kubernetes 项目里，Infra 容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：k8s.gcr.io/pause。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。而在 Infra 容器“Hold 住”Network Namespace 后，用户容器就可以加入到 Infra 容器的 Network Namespace 当中了。Pod 的生命周期只跟 Infra 容器一致，而与容器 A 和 B 无关。

而对于同一个 Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的。这一点很重要，因为将来如果你要为 Kubernetes 开发一个网络插件时，应该重点考虑的是如何配置这个 Pod 的 Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的。

有了这个设计之后，共享 Volume 就简单多了：Kubernetes 项目只要把所有 Volume 的定义都设计在 Pod 层级即可。一个 Volume 对应的宿主机目录对于 Pod 来说就只有一个，Pod 里的容器只要声明挂载这个 Volume，就一定可以共享这个 Volume 对应的宿主机目录。

### 2.3 容器设计模式
前面说了 Pod 存在的一个重要原因是成组调度，而另一个原因就是容器设计模式。容器设计模式，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。

第一个最典型的例子是：WAR 包与 Web 服务器:

```yaml

apiVersion: v1
kind: Pod
metadata:
  name: javaweb-2
spec:
  initContainers:
  - image: geektime/sample:v2
    name: war
    command: ["cp", "/sample.war", "/app"]
    volumeMounts:
    - mountPath: /app
      name: app-volume
  containers:
  - image: geektime/tomcat:7.0
    name: tomcat
    command: ["sh","-c","/root/apache-tomcat-7.0.42-v2/bin/start.sh"]
    volumeMounts:
    - mountPath: /root/apache-tomcat-7.0.42-v2/webapps
      name: app-volume
    ports:
    - containerPort: 8080
      hostPort: 8001 
  volumes:
  - name: app-volume
    emptyDir: {}
```

在 Pod 中，所有 Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动。最终的结果就是，我们使用了一种“组合”方式，解决了 WAR 包与 Tomcat 容器之间耦合关系的问题。

实际上，这个所谓的“组合”操作，正是容器设计模式里最常用的一种模式，它的名字叫：sidecar。sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。

这个例子中的 sidecar 的主要工作也是使用共享的 Volume 来完成对文件的操作。但不要忘记，Pod 的另一个重要特性是，它的所有容器都共享同一个 Network Namespace。这就使得很多与 Pod 网络相关的配置和管理，也都可以交给 sidecar 完成，而完全无须干涉用户容器。这里最典型的例子莫过于 Istio 这个微服务治理项目了。

Kubernetes 社区曾经把“容器设计模式”这个理论，整理成了一篇[小论文](https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns)

你现在可以这么理解 Pod 的本质：Pod，实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序。当你需要把一个运行在虚拟机里的应用迁移到 Docker 容器中时，一定要仔细分析到底有哪些进程（组件）运行在这个虚拟机里。然后，你就可以把整个虚拟机想象成为一个 Pod，把这些进程分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。这才是更加合理的、松耦合的容器编排诀窍，也是从传统应用架构，到“微服务架构”最自然的过渡方式。

Pod 这个概念，提供的是一种编排思想，而不是具体的技术方案。所以，如果愿意的话，你完全可以使用虚拟机来作为 Pod 的实现，然后把用户容器都运行在这个虚拟机里。比如，Mirantis 公司的virtlet 项目就在干这个事情。甚至，你可以去实现一个带有 Init 进程的容器项目，来模拟传统应用的运行方式。这些工作，在 Kubernetes 中都是非常轻松的，也是我们后面讲解 CRI 时会提到的内容。

## 3. Pod对象基本概念
接下来我们就要深入到 Pod 对象中细节中了，那么首先我们要面对的问题就是: 到底哪些属性属于 Pod 对象，而又有哪些属性属于 Container 呢？。Pod 对标的是虚拟机所以在 Pod 的配置中，所以凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的。这些属性的共同特征是，它们描述的是“机器”这个整体，而不是里面运行的“程序”

### 3.1 Pod 中重要的字段
#### 调度相关
与调度有关的字段包括:
2. NodeName：
  - 一旦 Pod 的这个字段被赋值，Kubernetes 项目就会被认为这个 Pod 已经经过了调度，调度的结果就是赋值的节点名字
  - 所以，这个字段一般由调度器负责设置，但用户也可以设置它来“骗过”调度器，当然这个做法一般是在测试或者调试的时候才会用到
1. NodeSelector：
  - 是一个供用户将 Pod 与 Node 进行绑定的字段

```yaml
apiVersion: v1
kind: Pod
...
spec:
 nodeSelector:
   disktype: ssd
```
这样的一个配置，意味着这个 Pod 永远只能运行在携带了“disktype: ssd”标签（Label）的节点上；否则，它将调度失败。

#### 网络配置
与网络配置有关的字段包括:
1. HostAliases：定义了 Pod 的 hosts 文件（比如 /etc/hosts）里的内容

```yaml
apiVersion: v1
kind: Pod
...
spec:
  hostAliases:
  - ip: "10.1.2.3"
    hostnames:
    - "foo.remote"
    - "bar.remote"
...
```

上面配置的 Pod 启动后，/etc/hosts 文件的内容将如下所示：

```
cat /etc/hosts
# Kubernetes-managed hosts file.
127.0.0.1 localhost
...
10.244.135.10 hostaliases-pod
# 通过 HostAliases 字段为 Pod 设置的
10.1.2.3 foo.remote
10.1.2.3 bar.remote
```

#### Linux Namespace 相关
与 Namespace 配置有关的字段包括:
1. `shareProcessNamespace: true`: Pod 里的容器要共享 PID Namespace
2. `hostNetwork: true`: 共享宿主机的 Network Namespace
3. `hostIPC: true`: 共享宿主机的 IPC Namespace
4. `hostPID: true`: 共享宿主机的 PID Namespace

```yaml

apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  shareProcessNamespace: true
  containers:
  - name: nginx
    image: nginx
  - name: shell
    image: busybox
    stdin: true
    tty: true

# kubectl attach -it nginx -c shell


apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  hostNetwork: true
  hostIPC: true
  hostPID: true
  containers:
  ...
```

#### 容器相关
Init Containers 和 Containers 都属于 Pod 对容器的定义，内容也完全相同，只是 Init Containers 的生命周期，会先于所有的 Containers，并且严格按照定义的顺序执行。

### 3.2 Container 中重要的字段
Container 的定义除了 Docker 中的常规字段，如下几个字段相对特殊。

#### ImagePullPolicy
ImagePullPolicy 定义了镜像拉取的策略 
- Always: 默认值，每次创建 Pod 都重新拉取一次镜像。另外，当容器的镜像是类似于 nginx 或者 nginx:latest 这样的名字时，ImagePullPolicy 也会被认为 Always
- Never 或者 IfNotPresent，则意味着 Pod 永远不会主动拉取这个镜像，或者只在宿主机上不存在这个镜像时才拉取

#### Lifecycle
定义的是 Container Lifecycle Hooks。顾名思义，Container Lifecycle Hooks 就是在容器状态发生变化时触发一系列“钩子”。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  containers:
  - name: lifecycle-demo-container
    image: nginx
    lifecycle:
      postStart:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]
      preStop:
        exec:
          command: ["/usr/sbin/nginx","-s","quit"]
```

1. postStart: 
  - 指的是，在容器启动后，立刻执行一个指定的操作。
  - 需要明确的是，postStart 定义的操作，虽然是在 Docker 容器 ENTRYPOINT 执行之后，但它并不严格保证顺序。
  - 也就是说，在 postStart 启动时，ENTRYPOINT 有可能还没有结束。
  - 如果 postStart 执行超时或者错误，Kubernetes 会在该 Pod 的 Events 中报出该容器启动失败的错误信息，导致 Pod 也处于失败的状态
2. preStop:
  - 发生的时机，则是容器被杀死之前
  - preStop 操作的执行，是同步的。所以，它会阻塞当前的容器杀死流程，直到这个 Hook 定义操作完成之后，才允许容器被杀死，这跟 postStart 不一样

## 4. Pod 的声明周期
Pod 生命周期的变化，主要体现在 Pod API 对象的 Status 部分，其中，pod.status.phase，就是 Pod 的当前状态，它有如下几种可能的情况：
1. Pending: API 对象已经被创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功
2. Running: Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中
3. Succeeded: Pod 里的所有容器都正常运行完毕，并且已经退出了，运行一次性任务时最为常见
4. Failed: Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出
5. Unknown: 这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题

更进一步地，Pod 对象的 Status 字段，还可以再细分出一组 Conditions。这些细分状态的值包括：PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述造成当前 Status 的具体原因是什么。比如，Pod 当前的 Status 是 Pending，对应的 Condition 是 Unschedulable，这就意味着它的调度出现了问题。

而其中，Ready 这个细分状态非常值得我们关注：它意味着 Pod 不仅已经正常启动（Running 状态），而且已经可以对外提供服务了。这两者之间（Running 和 Ready）是有区别的。
