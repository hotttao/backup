---
weight: 1
title: "GVK"
date: 2023-03-01T22:00:00+08:00
lastmod: 2023-03-01T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "kube-apiserver GVK"
featuredImage: 

tags: ["k8s"]
categories: ["architecture"]

lightgallery: true

---
## 1. ApiServer Restful API
### 1.1 uri 定义 
kubernetes 中的 API Resource 对象基本上有两个维度的划分
1. 是否是 namespace 范围内
    - 隶属于 namespace ，比如 pod、deployment，这一类对象 metadata 内有 namespace 属性标识其所属的  namespace
    - 隶属于整个集群，比如 node， cluster role， cluster role binding， persistent volume 
2. 是否为核心 resource 
    - 核心 resource 来说常见的有 pod, podtemplate, service, endpoint, configmap 等等，这些资源提供了 kubernetes 最基本的能力
    - 非核心资源例如 deployment， statefulset， deamonset 等等提供更高级的功能

kubernetes 提供了标准的 RESTfull API，基于以上不同维度各种 resource 的 uri 如下:

![API Uri](/images/k8s/k8s_use/resource_uri.png)

可以看到:
1. 核心对象以 /api 为 uri path 前缀，没有 group 概念
2. 隶属于 namespace 对象 uri 内有 namespace 的 path 变量 ${namespace-name}。
3. 非核心对象以 /apis 为 uri path 前缀，有 group 概念

所有对象以 group/version/kind(gvk) 构成了如下的结构层次:

![api gvk](/images/k8s/k8s_use/gvk_uri.webp)

### 1.2 API 对象的结构
kubernetes 内的所有对象都通过 yaml 格式的 manifest 进行定义:

![API Uri](/images/k8s/k8s_use/mianfest.png)


以  Deployment 为例:

```go
type Deployment struct {
  metav1.TypeMeta

  metav1.ObjectMeta

  Spec DeploymentSpec

  Status DeploymentStatus
}
```

每个对象的定义都分为如下四个部分:
1. TypeMeta: 通用属性，用于表示一个 API 对象的类型、版本、类型，即 Group/Version/kind (GVK)
2. MetaData: 通用属性，定义 API 对象的元数据信息，包括对象隶属的 namespace，示例名称，label 等等
3. Spec: 用户的期望状态，由创建对象的用户端来定义
4. Status: 对象的实际状态，由对应的控制器收集实际状态并更新

TypeMeta、MetaData 是通用属性，Spec 和 Status 与 API 对象定义对应。staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go 源文件中定义了 kubernetes resource 的 type meta 及 object meta。

### 1.3 TypeMeta
[TypeMeta](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L42) 只包含了，两个属性
1. kind: API 对象类型
2. apiVersion: API 对象版本(group/version)
```go
message TypeMeta { 
  // Kind is a string value representing the REST resource this object represents.
  // Servers may infer this from the endpoint the client submits requests to.
  // Cannot be updated.
  // In CamelCase.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional string kind = 1;

  // APIVersion defines the versioned schema of this representation of an object.
  // Servers should convert recognized schemas to the latest internal value, and
  // may reject unrecognized values.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
  // +optional
  optional string apiVersion = 2;
}
```

### ObjectMeta
[ObjectMeta](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L111) 定义如下:

```go
type ObjectMeta struct {
	Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
	GenerateName string `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`
	Namespace string `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`

	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	// +optional
	SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`

	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	UID types.UID `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID"`

	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`

	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	// +optional
	Generation int64 `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`

	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	//
	// Populated by the system.
	// Read-only.
	// Null for lists.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	CreationTimestamp Time `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`

	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	DeletionTimestamp *Time `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`

	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	// +optional
	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	Labels map[string]string `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	Annotations map[string]string `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`

	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	// +optional
	// +patchMergeKey=uid
	// +patchStrategy=merge
	OwnerReferences []OwnerReference `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`

	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	// Finalizers may be processed and removed in any order.  Order is NOT enforced
	// because it introduces significant risk of stuck finalizers.
	// finalizers is a shared field, any actor with permission can reorder it.
	// If the finalizer list is processed in order, then this can lead to a situation
	// in which the component responsible for the first finalizer in the list is
	// waiting for a signal (field value, external system, or other) produced by a
	// component responsible for a finalizer later in the list, resulting in a deadlock.
	// Without enforced ordering finalizers are free to order amongst themselves and
	// are not vulnerable to ordering changes in the list.
	// +optional
	// +patchStrategy=merge
	Finalizers []string `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`

	// Tombstone: ClusterName was a legacy field that was always cleared by
	// the system and never used.
	// ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`

	// ManagedFields maps workflow-id and version to the set of fields
	// that are managed by that workflow. This is mostly for internal
	// housekeeping, and users typically shouldn't need to set or
	// understand this field. A workflow can be the user's name, a
	// controller's name, or the name of a specific apply path like
	// "ci-cd". The set of fields is always in the version that the
	// workflow used when modifying the object.
	//
	// +optional
	ManagedFields []ManagedFieldsEntry `json:"managedFields,omitempty" protobuf:"bytes,17,rep,name=managedFields"`
}
```
ObjectMeta 定义 API 对象的元数据信息，比较重要的是以下几个:
1. Name: API 对象的实例名称
2. Namespace: 实例存放的 namespace
3. Labels: 实例的标签，通过 label Selector 可以实现对实例的筛选
4. Annotations: 携带 key-value 格式的内部信息
5. Finalizer: Finalizer 本质上是一个资源锁，Kubernetes 在接收某对象的删除请求时，会检查 Finalizer 是否为空，如果不为空则只对其做逻辑删除，即只会更新对象中的 metadata.deletionTimestamp 字段。
4. ResourceVersion: ResourceVersion 可以被看作一种乐观锁，每个对象在任意时刻都有其ResourceVersion，当 Kubernetes 对象被客户端读取以后，ResourceVersion 信息也被一并读取。此机制确保了分布式系统中任意多线程能够无锁并发访问对象，极大提升了系统的整体效率

### 1.5 GVK 内外部对象转换
前面我们提到 kubernetes 所有的 API 对象都通过 GVK(Group/Version/Kind) 进行定义:
1. group: 需要 group 是为了方便对 API 对象进行管理，包括按优先级进行限流
2. version: 需要 version 是因为保证演进的过程中向前向后兼容

从设计角度上看 kubernetes 引入的 internal version 的概念，在同一个 group 之中的所有 version 的 resource 都会转化成 internal version, 然后来持久化在 etcd cluster 之中。反之从 etcd cluster 中读取数据的时候，就会从 internal version 来转化成相应的对外 version，如下所示。

![gvk 版本转换逻辑](/images/k8s/k8s_use/gvk_internal_version.png)

internal version 不会对外暴露，它的存在是希望其它所有的 version 在转化的过程中仅仅会和 internal version 产生关联依赖，不会相互关联依赖。

接下来我们来看一下不同 version 的 resource 都定义在什么地方：
1. API Resource 的外部版本定义在: kubernetes/staging/src/k8s.io/api/ 
2. API Resource 的内部版本定义在: kubernetes/pkg/apis/

以 apps group 资源组为例:
|外部版本|内部版本|
|:---|:---|
|kubernetes/staging/src/k8s.io/api/ |kubernetes/pkg/apis/|
|![app 组外部版本定义](/images/k8s/k8s_use/gvk_external.png)|![app 组内部版本定义](/images/k8s/k8s_use/gvk_internal.png)|
|一本版本对应一个子目录|types.go 是内部版本定义，版本目录定义 外部版本与内部版本之间的转换函数|
