---
weight: 1
title: "Rust 变量与数据类型"
date: 2023-05-01T22:00:00+08:00
lastmod: 2023-05-01T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "Rust 变量与数据类型"
featuredImage: 

tags: ["rust 语法"]
categories: ["Rust"]

lightgallery: true

toc:
  auto: false
---

## 1. 变量定义和声明
问: rust 变量声明语法

在 Rust 中，变量声明语法有几种不同的方式，具体取决于变量的类型和可变性。以下是常见的 Rust 变量声明语法：

1. 不可变变量声明：
   ```rust
   let x = 5; // 自动推断 x 的类型为 i32（32 位有符号整数）
   let y: i32 = 10; // 显式指定 y 的类型为 i32
   
   // 在声明时初始化变量后，变量的值不能再改变
   ```

2. 可变变量声明：
   ```rust
   let mut x = 5; // 自动推断 x 的类型为 i32，并且可变
   let mut y: i32 = 10; // 显式指定 y 的类型为 i32，并且可变
   
   // 可变变量可以在声明后重新赋值
   x = 7;
   ```

3. 声明常量：
   ```rust
   const MAX_POINTS: u32 = 100_000; // 声明一个常量 MAX_POINTS，类型为 u32
   
   // 常量的值不能改变，并且必须显式指定类型
   ```

4. 在模式匹配中声明变量：
   ```rust
   let (x, y) = (5, 10); // 在元组模式匹配中声明多个变量
   
   // x 的值为 5，y 的值为 10
   ```


问: 以表格形式对比 对比  java 和 rust 的变量声明，并给出代码示例

以下是使用表格形式对比 Java 和 Rust 的变量声明，并给出相应的代码示例：

| 特性                       | Java                                          | Rust                                          |
|----------------------------|-----------------------------------------------|-----------------------------------------------|
| 关键字                    | `var`, 具体的类型名                             | `let`                                         |
| 不可变变量声明             | 使用 `final` 关键字                             | 默认情况下变量是不可变的                       |
| 可变变量声明               | 无需关键字，变量可随时重新赋值                     | 使用 `mut` 关键字声明可变变量                  |
| 类型推断                   | 可以使用 `var` 进行类型推断                      | 可以自动推断变量类型                            |
| 显式类型指定               | 可以显式指定变量类型                            | 可以显式指定变量类型                            |
| 常量声明                   | 使用 `final` 关键字或 `static final`,并且必须显式指定类型 | 使用 `const` 关键字声明常量，并且必须显式指定类型 |
| 声明时是否需要初始化       | 可以稍后初始化                                 | 必须在声明时进行初始化                          |
| 默认可变性                | 默认情况下变量是可变的                           | 默认情况下变量是不可变的                       |
| 所有权和借用               | 无                                             | Rust 引入了所有权和借用的概念                    |
| 内存访问控制               | 无                                             | Rust 通过所有权和借用管理变量的内存访问          |

Java 代码示例：
```java
// 不可变变量声明
final int x = 5;

// 可变变量声明
int y = 10;
y = 15;

// 类型推断
var z = "Hello";

// 显式类型指定
int a = 20;

// 常量声明
final int MAX_POINTS = 100_000;

// 声明时是否需要初始化
int b;  // 正确
int c = 0; // 正确：在声明时进行初始化
```

Rust 代码示例：
```rust
// 不可变变量声明
let x = 5;

// 可变变量声明
let mut y = 10;
y = 15;

// 类型推断
let z = "Hello";

// 显式类型指定
let a: i32 = 20;

// 常量声明
const MAX_POINTS: u32 = 100_000;

// 声明时是否需要初始化
let b;  // 错误：需要在声明时进行初始化
let c = 0; // 正确：在声明时进行初始化
```

### 1.1 变量隐藏
问: rust 中的变量隐藏不是重新声明么？

在 Rust 中，变量隐藏（Variable Shadowing）与重新声明是不同的概念。变量隐藏是指在同一作用域中使用相同名称的变量来隐藏之前的变量，而不是重新声明一个新的变量。这样做的好处是，你可以在代码块中使用新的变量，而不需要更改之前的变量名。这是 Rust 中的一种常见模式，用于重新利用变量名称和避免引入新的作用域。

以下是一个示例，演示了变量隐藏的概念：
```rust
fn main() {
    let x: i32 = 10;
    println!("x: {}", x);  // 输出 x: 10

    let x = "hello";  // 变量隐藏，创建一个新的 x 变量
    println!("x: {}", x);  // 输出 x: hello

    let x: f32 = 3.14;  // 变量隐藏，创建一个新的 x 变量
    println!("x: {}", x);  // 输出 x: 3.14
}
```

变量隐藏与重新声明一个新的变量是不同的，因为重新声明会引入一个新的作用域，并且不能在同一作用域中使用相同的名称。在变量隐藏中，编译器会根据上下文推断变量的类型，因此在隐藏之后的代码中可以使用新的类型。


## 2. 常量以及类型转换

问: 以表格的形式对比 java 和 rust 中的常量定义、类型重命名、类型转换、枚举类型、自定义类型

下面是Java和Rust中常量定义、类型重命名、类型转换、枚举类型和自定义类型的比较表格：

| 功能            | Java                                  | Rust                                           |
|-----------------|---------------------------------------|------------------------------------------------|
| 常量定义        | 使用关键字`final`定义不可变变量         | 使用关键字`const`或`static`定义不可变变量        |
| 类型重命名      | 使用关键字`typedef`或`import`语句       | 使用关键字`type`定义类型别名                     |
| 类型转换        | 使用强制类型转换或自动类型转换           | 使用`as`关键字进行类型转换                        |
| 枚举类型        | 使用`enum`关键字定义枚举类型             | 使用`enum`关键字定义枚举类型                      |
| 自定义类型      | 使用`class`或`interface`定义自定义类型   | 使用`struct`和`enum`定义自定义类型                  |
| 代码示例        |                                       |                                                |
| 常量定义示例    | `final int MAX_VALUE = 100;`           | `const MAX_VALUE: i32 = 100;`                   |
| 类型重命名示例  | `typedef int MyInt;`                   | `type MyInt = i32;`                            |
| 类型转换示例    | `int num = (int) doubleValue;`         | `let num: i32 = double_value as i32;`          |
| 枚举类型示例    | ```enum Color { RED, GREEN, BLUE }``` | ```enum Color { RED, GREEN, BLUE }```    |
| 自定义类型示例  | ```class Person { }```             | ```struct Person { }```                   |


## 3. 基础类型
### 3.1 数值类型的范围
问: 以表格形式列举 rust 中的中的基础数据类型，分为三列，分别是类型，长度，表示的含义，使用惯例的代码示例

下面是Rust中常见的基础数据类型的表格，包括类型、长度和表示的含义，以及使用惯例的代码示例：

| 类型                   | 长度           | 含义                                                         | 代码示例                                |
|------------------------|----------------|--------------------------------------------------------------|-----------------------------------------|
| bool                   | 1 字节         | 布尔类型，表示真或假                                          | ```let is_true = true;```               |
| u8                     | 1 字节         | 无符号 8 位整数（0 到 255）                                    | ```let number: u8 = 42;```              |
| i8                     | 1 字节         | 有符号 8 位整数（-128 到 127）                                 | ```let number: i8 = -42;```             |
| u16                    | 2 字节         | 无符号 16 位整数（0 到 65535）                                 | ```let number: u16 = 1000;```           |
| i16                    | 2 字节         | 有符号 16 位整数（-32768 到 32767）                            | ```let number: i16 = -1000;```          |
| u32                    | 4 字节         | 无符号 32 位整数（0 到 4294967295）                            | ```let number: u32 = 1000000;```        |
| i32                    | 4 字节         | 有符号 32 位整数（-2147483648 到 2147483647）                  | ```let number: i32 = -1000000;```       |
| u64                    | 8 字节         | 无符号 64 位整数（0 到 18446744073709551615）                  | ```let number: u64 = 1000000000;```     |
| i64                    | 8 字节         | 有符号 64 位整数（-9223372036854775808 到 9223372036854775807） | ```let number: i64 = -1000000000;```    |
| f32                    | 4 字节         | 单精度浮点数                                                  | ```let number: f32 = 3.14;```           |
| f64                    | 8 字节         | 双精度浮点数                                                  | ```let number: f64 = 3.14;```           |
| char                   | 4 字节         | 单个 Unicode 字符                                             | ```let ch = 'A';```                     |
| str                    | 动态长度       | 字符串 slice（不可变字符串）                                   | ```let message: &str = "Hello";```      |
| String                 | 动态长度       | 堆分配的可变字符串                                            | ```let message: String = String::from("Hello");``` |
| 数组                   | 固定长度       | 具有相同类型的固定长度序列                                     | ```let arr: [i32; 3] = [1, 2, 3];```    |
| 元组                   | 动态长度       | 具有不同类型的固定长度序列                                     | ```let tuple: (i32, f64, char) = (42, 3.14, 'A');``` |
| 指针                   | 平台相关       | 存储内存地址的类型                                             | ```let ptr: *const i32 = &number;```    |
| Option<T>              | 动态长度       | 表示可选值的类型                                               | ```let maybe_number: Option<i32> = Some(42);``` |
| Result<T, E>           | 动态长度       | 表示可能产生错误的操作的结果                                   | ```let result: Result<i32, String> = Ok(42);``` |

除了指明位数的类型，还有isize和usize两种特殊的整数类型，它们的长度取决于程序运行的目标平台。在64位架构上，它们就是64位的，而在32位架构上，它们就是32位的。

### 3.2 数值字面量
问: 以表格列举 Rust中的数字字面量、二进制字面量，包括八进制和十六进制字面量

在 Rust 中，数字字面量用于表示整数和浮点数，而二进制字面量则用于表示二进制数。以下是 Rust 中常见的数字字面量和二进制字面量的示例：

数字字面量：

| 类型    | 示例                  | 描述                                          |
| ------- | --------------------- | --------------------------------------------- |
| 整数    | `10`                  | 默认为有符号32位整数类型（`i32`）              |
| 整数    | `10_000`              | 整数带下划线              |
|         | `1000i64`             | 有符号64位整数类型（`i64`）                    |
|         | `1000u32`             | 无符号32位整数类型（`u32`）                    |
| 浮点数  | `3.14`                | 默认为64位浮点数类型（`f64`）                   |
|         | `3.14f32`             | 32位浮点数类型（`f32`）                         |
|         | `1e5` 或 `1E5`        | 科学计数法表示，等同于 100000.0                 |
|         | `1.23e-4` 或 `1.23E-4`| 科学计数法表示，等同于 0.000123                 |

进制字面量：

| 进制     | 示例                   | 描述                                         |
| -------- | ---------------------- | -------------------------------------------- |
| 二进制   | `0b1010`               | 二进制数 1010                                |
| 八进制   | `0o777`                | 八进制数 777                                 |
| 十六进制 | `0xFF`                 | 十六进制数 FF                                |
| 带下划线 | `0b1010_1100`          | 带下划线的二进制数 1010 1100                  |
|          | `0o777_666`            | 带下划线的八进制数 777 666                    |
|          | `0xFF_AB_CD_EF`        | 带下划线的十六进制数 FF AB CD EF              |

需要注意的是，Rust 中的整数字面量可以使用后缀来明确指定类型，例如 i8、u32 等。默认情况下，整数字面量被推断为有符号的32位整数类型（`i32`），浮点数字面量被推断为64位浮点数类型（`f64`）。如果需要显式指定类型，可以添加后缀，例如使用 `i64` 表示64位整数，使用 `f32` 表示32位浮点数。

### 3.3 浮点数
问: rust 中的浮点数，有哪些特殊表示和使用方法，给出代码示例，包括如何表示无限大，表示NaN

在Rust中，浮点数类型（f32和f64）具有一些特殊的表示和使用方法，包括表示无限大和NaN（非数字）。下面是相关的代码示例：

1. 表示无限大：

```rust
let infinity: f64 = f64::INFINITY;
let neg_infinity: f32 = f32::NEG_INFINITY;

println!("无限大：{}", infinity);
println!("负无限大：{}", neg_infinity);
```

2. 表示NaN（非数字）：

```rust
let nan: f32 = f32::NAN;

println!("NaN：{}", nan);
```

此外，还可以使用浮点数的方法和特性来进行比较和处理，例如：

```rust
let x: f64 = 3.14;
let y: f64 = 2.71;

// 比较
if x > y {
    println!("x 大于 y");
} else if x < y {
    println!("x 小于 y");
} else {
    println!("x 等于 y");
}

// 四舍五入
let rounded: f64 = x.round();
println!("四舍五入后的值：{}", rounded);

// 取绝对值
let abs_value: f64 = y.abs();
println!("绝对值：{}", abs_value);

// 幂运算
let power: f64 = x.powf(2.0);
println!("平方：{}", power);
```

### 3.4 字符串
问: rust 中的字符串设计

在 Rust 中，字符串有两种主要的表示形式：`String` 和 `&str`。

1. `String`：`String` 是一个可变的、堆分配的字符串类型。它可以根据需要动态增长，并支持各种字符串操作。你可以通过 `String::new()` 创建一个空的 `String`，或者使用 `String::from("some string")` 根据现有字符串创建一个 `String`。例如：

   ```rust
   let mut s = String::new();
   s.push_str("Hello");
   s.push(' ');
   s.push_str("world!");
   println!("{}", s);  // 输出：Hello world!
   ```

2. `&str`：`&str` 是一个不可变的**字符串切片**(什么是切片我们后面在详述)，通常用于引用字符串字面量或 `String` 对象的一部分。它是一个指向存储在其他位置的字符串数据的不可变引用。你可以使用字符串字面量直接创建 `&str`，也可以通过 `&String` 将 `String` 转换为 `&str`。例如：

   ```rust
   let s1: &str = "Hello";
   let s2: &str = &s1[0..3];
   println!("{}", s2);  // 输出：Hel
   ```

问: rust 中 str 与 String 之间的转换

```rust
// str 转为 String
let s: &str = "Hello, world!";
let string: String = s.to_string();

// String 转为 str
let string: String = String::from("Hello, world!");
let s: &str = &string;
```

当将str转换为String时，会创建一个新的可变的字符串对象，并将str的内容复制到该对象中。而将String转换为str时，只是获取了String对象的引用，并没有进行字符串数据的复制。

Rust 的字符串设计主要关注安全性和性能。`String` 提供了动态可变的字符串操作，适用于需要修改字符串内容的场景。`&str` 是一个更轻量级的不可变引用，适用于只需要访问字符串内容而不需要修改的场景。

## 4. 隐式类型转换
问: rust 中的隐式类型转换

在Rust中，存在一些隐式的类型转换规则，使得某些类型之间的转换可以在不显式指定类型转换的情况下自动发生。以下是Rust中常见的隐式类型转换情况：

1. 数字类型的隐式类型转换：
   - 整数类型之间的隐式转换（例如：u8到u16、i32到i64等）。
   - 浮点数类型之间的隐式转换（例如：f32到f64）。

2. 引用和借用类型的隐式类型转换：
   - 不可变引用（&T）可以隐式转换为共享引用（&'a T，其中'a是合适的生命周期）。
   - 可变引用（&mut T）可以隐式转换为可变的共享引用（&'a mut T，其中'a是合适的生命周期）。

3. 标准库中的隐式类型转换：
   - 从字符串字面量到String类型的隐式转换。
   - 编译器可以自动将&String类型的参数强制转换为&str类型。

下面是使用隐式类型转换的代码示例：

```rust
let x: u16 = 42;
let y: u32 = x; // 隐式将u16转换为u32

let mut value: i32 = 10;
let ref_value: &i32 = &value; // 隐式将可变引用转换为不可变引用

let str_literal: &str = "Hello, Rust!";
let string: String = str_literal.into(); // 隐式将字符串字面量转换为String类型
```

需要注意的是，Rust强调类型安全和显式的类型转换，因此隐式类型转换的情况相对有限。在某些情况下，需要显式地进行类型转换以确保代码的清晰性和安全性。

## 5. 包装数据类型
问: 以表格形式列举 rust 中的包装数据类型，并给出代码示例

下面是Rust中常见的包装数据类型以及相应的代码示例的表格：

| 类型                   | 描述                                                        | 代码示例                                          |
|------------------------|-------------------------------------------------------------|---------------------------------------------------|
| Option<T>              | 表示可能为空的值的类型                                        | ```let some_value: Option<i32> = Some(42);```     |
| Result<T, E>           | 表示可能产生错误的操作的结果                                  | ```let result: Result<i32, String> = Ok(42);```   |
| Vec<T>                 | 可变长度的动态数组                                           | ```let numbers: Vec<i32> = vec![1, 2, 3];```      |
| Box<T>                 | 堆分配的值的所有权包装器                                     | ```let boxed_value: Box<i32> = Box::new(42);```   |
| Rc<T>                  | 引用计数智能指针，用于多个所有者的共享所有权                   | ```let shared_value: Rc<i32> = Rc::new(42);```    |
| Arc<T>                 | 原子引用计数智能指针，用于多个线程的共享所有权                 | ```let atomic_shared_value: Arc<i32> = Arc::new(42);``` |
| Cell<T>                | 可变的内部可变容器，允许在不可变引用中修改值                   | ```let cell_value: Cell<i32> = Cell::new(42);``` |
| RefCell<T>             | 可变的内部可变容器，允许在运行时检查借用规则并修改值           | ```let ref_cell_value: RefCell<i32> = RefCell::new(42);``` |
| Mutex<T>               | 互斥锁，用于多线程间的同步                                   | ```let mutex_value: Mutex<i32> = Mutex::new(42);``` |
| RwLock<T>              | 读写锁，允许多个读者或单个写者对值进行并发访问                | ```let rw_lock_value: RwLock<i32> = RwLock::new(42);``` |

这些包装类型提供了一些额外的功能或语义，例如处理可选值、错误处理、所有权管理、并发访问等。它们在不同的场景下具有不同的用途和限制，因此在具体使用时，需要仔细考虑其特性和适用性。

## 6. 复合数据类型
问: 以表格形式对比 Java 和 Rust 中常见的复合数据类型，并给出代码示例：

下面是Java和Rust中常见的复合数据类型的对比表格，包括类型名称和代码示例：

| 类型               | Java                           | Rust                                      |
|--------------------|--------------------------------|-------------------------------------------|
| 数组               | ```int[] numbers = {1, 2, 3};``` | ```let numbers: [i32; 3] = [1, 2, 3];```   |
| 列表（动态数组）   | ```List<Integer> list = new ArrayList<>();``` | ```let list: Vec<i32> = vec![1, 2, 3];``` |
| 集合               | ```Set<String> set = new HashSet<>();``` | ```let set: HashSet<String> = HashSet::new();``` |
| 映射               | ```Map<String, Integer> map = new HashMap<>();``` | ```let map: HashMap<String, i32> = HashMap::new();``` |
| 元组               | 不适用                           | ```let tuple: (i32, f64, char) = (42, 3.14, 'A');``` |
| 结构体             | 不适用                           | ```struct Person { name: String, age: i32 }``` |
| 枚举               | ```enum Color { RED, GREEN, BLUE }``` | ```enum Color { RED, GREEN, BLUE }``` |
| 类                 | ```class Person { String name; int age; }``` | ```struct Person { name: String, age: i32 }``` |
| 泛型               | ```List<Integer> list = new ArrayList<>();``` | ```let list: Vec<i32> = Vec::new();``` |
| 包装类型（Optional） | ```Optional<Integer> optional = Optional.of(42);``` | ```let optional: Option<i32> = Some(42);``` |

### 6.1 数组
问: 以表格形式，列举 Rust 中数组的用法

下面是一些Rust中数组的常见用法的表格形式示例：

| 用法                 | 示例                                                         |
|----------------------|--------------------------------------------------------------|
| 声明数组              | `let arr: [i32; 5] = [1, 2, 3, 4, 5];`                        |
| 数组长度              | `let len = arr.len();`                                        |
| 访问数组元素          | `let first_element = arr[0];`                                  |
| 更新数组元素          | `arr[2] = 10;`                                                |
| 遍历数组              | ```for element in &arr { println!("{}", element);}``` |
| 切片数组              | `let slice = &arr[1..3];`                                      |
| 检查数组是否为空      | `let is_empty = arr.is_empty();`                               |
| 比较数组是否相等      | `let equal = arr1 == arr2;`                                    |
| 复制整个数组          | `let arr_copy = arr;`                                         |
| 打印整个数组          | `println!("{:?}", arr);`                                      |

这数组在Rust中具有固定的长度，且类型相同。如果你需要一个可变长度的容器，你可以考虑使用向量（Vector）类型（`Vec<T>`）。

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];

    // 使用 for 循环迭代数组
    for element in &array {
        println!("Array element: {}", element);
    }

    // 使用 iter() 方法迭代数组
    for element in array.iter() {
        println!("Array element: {}", element);
    }
}

```

### 6.2 元祖
问: 以表格形式，列举 Rust 中元祖的用法

以下是Rust中元组的常见用法的表格形式示例：

| 用法                   | 示例                                                         |
|------------------------|--------------------------------------------------------------|
| 声明元组                | `let tuple: (T1, T2, ...);`                                    |
| 创建元组                | `let tuple = (value1, value2, ...);`                            |
| 元组解构                | `let (x, y, z) = tuple;`                                       |
| 元组作为函数返回值      | `fn get_tuple() -> (T1, T2) { (value1, value2) }`               |
| 元组作为函数参数        | `fn process_tuple(tuple: (T1, T2)) { /* 函数体 */ }`          |
| 访问元组字段的方法      | `tuple.0`, `tuple.1`, `tuple.2`, 等等                           |
| 元组的长度              | `let len = tuple.len();`                                       |
| 创建空元组              | `let empty_tuple: () = ();`                                    |
| 元组与数组的区别        | 元组可以包含不同类型的元素，长度不可变；数组包含相同类型的元素，长度固定 |

元组可以存储多个不同类型的值，并且可以通过索引访问和解构。你可以使用模式匹配来处理元组的不同情况，还可以将元组用作函数的返回值和参数。

#### 元组模式匹配
```rust
fn main() {
    let tuple = (10, true, "hello");

    match tuple {
        (10, true, message) => {
            println!("Matched first pattern with message: {}", message);
        }
        (_, false, _) => {
            println!("Matched second pattern");
        }
        _ => {
            println!("Matched default pattern");
        }
    }
}

```

#### 数组与元祖的对比
问: 以表格形式，对比 Rust 中元祖和数组的用法

下面是Rust中元组和数组的用法对比表格：

|               | 元组 (Tuple)                                      | 数组 (Array)                                      |
|---------------|--------------------------------------------------|--------------------------------------------------|
| 声明          | `let tuple: (T1, T2, ...);`                      | `let array: [T; N];`                              |
| 长度          | 固定长度，根据元素数量确定                        | 固定长度，通过类型和元素数量确定                   |
| 类型          | 可以包含不同类型的元素                            | 只能包含相同类型的元素                            |
| 访问元素      | 使用`.`和索引访问元素，如`tuple.0`、`tuple.1`     | 使用`[]`和索引访问元素，如`array[0]`、`array[1]`   |
| 迭代          | 可以使用`for`循环和`iter()`方法进行迭代            | 可以使用`for`循环和`iter()`方法进行迭代            |
| 长度检查      | 不会进行长度检查，可以包含不同数量的元素          | 进行长度检查，必须包含指定数量的元素              |
| 复制和传递    | 元素可以通过复制语义进行复制和传递                | 元素在传递时会进行移动或复制                       |
| 堆栈分配      | 在栈上分配内存                                   | 在栈上分配内存                                   |
| 动态调整大小  | 不支持动态调整大小                               | 不支持动态调整大小                               |

