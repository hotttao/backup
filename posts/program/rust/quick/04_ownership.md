---
weight: 1
title: "Rust 所有权"
date: 2023-05-01T22:00:00+08:00
lastmod: 2023-05-01T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "Rust 所有权"
featuredImage: 

tags: ["rust 语法"]
categories: ["Rust"]

lightgallery: true

toc:
  auto: false
---

## 1. 所有权概述
所有权规则:
1. Rust中的每一个值都有一个对应的变量作为它的所有者。
2. 在同一时间内，值有且仅有一个所有者。
3. 当所有者离开自己的作用域时，它持有的值就会被释放掉。

```rust
{
    les s = String:from("hello， world")   // 从这里开始，变量 s 可用
    // 执行与 s 相关的操作
}                                          // 作用域到这里结束，变量 s 失效
```

审视上面的代码，有一个很适合用来回收内存给操作系统的地方：变量s离开作用域的地方。Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。String类型的作者可以在这个函数中编写释放内存的代码。**Rust会在作用域结束的地方（即`}`处）自动调用drop函数**。

### 1.1 变量和数据交互的方式：移动

```rust
let s1 = String::from("hello");
let s2 = s1;
```

String的内存布局，它实际上由3部分组成:
1. 一个指向存放字符串内容的指针（ptr）
2. 一个长度（len）
3. 一个容量（capacity）

String 本身存储在了栈中。ptr 指向的文本内容则保存在堆上。当把 s1 赋值给 s2 时，由于Rust不会深度地复制堆上的数据。

但是如果是这样处理会有一个问题。前面我们提到过，当一个变量离开当前的作用域时，Rust会自动调用它的drop函数，并将变量使用的堆内存释放回收。当s2和s1离开自己的作用域时，它们会尝试去重复释放相同的内存。为了确保内存安全，同时也避免复制分配的内存，Rust在这种场景下会简单地将s1废弃，不再视其为一个有效的变量。因此，Rust也不需要在s1离开作用域后清理任何东西。试图在s2创建完毕后使用s1会导致编译时错误。

### 1.2 变量和数据交互的方式：克隆
深度拷贝String堆上的数据需要显示调用 clone 方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

### 1.3 栈上数据复制
```rust
// 将变量x绑定的整数值重新绑定到变量y上
let x = 5;
let y = x;
```

这段代码的执行效果：将整数值5绑定到变量x上；然后创建一个x值的拷贝，并将它绑定到y上。结果我们有了两个变量x和y，它们的值都是5。因为整数是已知固定大小的简单值，两个值5会同时被推入当前的栈中。

即便代码没有调用clone，x在被赋值给y后也依然有效，且没有发生移动现象。这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中。换句话说，对于这些类型而言，深度拷贝与浅度拷贝没有任何区别。

Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型（我们会在第10章详细地介绍trait）。一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。如果一种类型本身或这种类型的任意成员实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait。尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误。

一般来说，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。下面是一些拥有Copy这种trait的类型：
- 所有的整数类型，诸如u32。
- 仅拥有两种值（true和false）的布尔类型：bool。
- 字符类型：char。
- 所有的浮点类型，诸如f64。
- 如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的。例如，(i32, i32)是Copy的，但(i32, String)则不是。

### 1.4 所有权与函数
将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样。函数在返回值的过程中也会发生所有权的转移。

变量所有权的转移总是遵循相同的模式：**将一个值赋值给另一个变量时就会转移所有权**。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。

### 1.4 引用与借用

```rust
fn main() { 
    let s1 = String::from("hello"); 
    let len = calculate_length(&s1); 
 
    println!("The length of '{}' is {}.", s1, len); 
} 
 
fn calculate_length(s: &String) -> usize { 
    s.len() 
} 
```

&代表的就是引用语义，引用允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。这种通过引用传递参数给函数的方法也被称为借用（borrowing）

### 1.5 可变引用
与变量类似，引用是默认不可变的，想创建可变引用，需要:
1. 将变量s声明为mut，即可变的
2. 使用&mut s来给函数传入一个可变引用
3. 将函数签名修改为 &mut String 使其可以接收一个可变引用作为参数

```rust
let mut s = String::from("hello"); 
change(&mut s); 

fn change(some_string: &mut String) { 
    some_string.push_str(", world"); 
}
```

### 1.6 引用的使用限制
可变引用在使用上有一个很大的限制：
1. 对于特定作用域中的特定数据来说，一次只能声明一个可变引用。
2. 并且在同一作用域不能同时拥有可变和不可变引用

### 1.7 悬垂引用
悬垂引用表示引用指向的内存，已经被释放或者已经被重新分配。在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。

```rust
fn main() { 
    let reference_to_nothing = dangle(); 
} 
 
fn dangle() -> &String { 
    // s被绑定到新的String上 
    let s = String::from("hello"); 
    
    // 将指向s的引用返回给调用者 
    &s 

} // 变量s在这里离开作用域并随之被销毁，它指向的内存自然也不再有效。 
```

想要在函数内返回局部变量的引用，可以借助于 rust 的生命周期。这里更简单的方法是直接返回 String，所有权被转移出函数，自然不糊设计释放操作。

## 2. 切片
Rust还有另外一种不持有所有权的数据类型：切片（slice）。切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。

### 2.1 字符串切片
rust 中字符串切片的类型是 &str，字符串字面量就是切片
```rust
let s = String::from("hello world");
let hello = &s[0..5];
let slice = &s[..2];
let slice = &s[3..];

let ss = "Hello, world!";
```

上面变量 ss 的类型其实就是&str：它是一个指向二进制程序特定位置的切片。正是由于&str是一个不可变的引用，所以字符串字面量自然才是不可变的。

问: rust 中 &str 与 &String 的区别

在Rust中，`&str`和`&String`是不同类型的引用，有以下区别：

1. **可变性**: 
    - `&str`是不可变引用，而`&String`是对`String`的不可变引用。
    - 这意味着通过`&str`引用的字符串内容不能被修改，而`&String`引用的字符串内容也不能被修改，但可以通过`&String`重新赋值引用的字符串对象。
2. **所有权关系**: 
    - `&str`是对原始字符串数据的引用，不拥有字符串对象的所有权。
    - `&String`是对`String`对象的引用，不拥有`String`对象的所有权。
    - 这意味着`&str`和`&String`可以在不转移所有权的情况下访问字符串数据。
3. **转换**: 
    - `String`可以通过`&str`进行隐式转换，因为`String`实现了`From<&str>` trait。
    - 这意味着可以将`&str`传递给期望`&String`参数的函数或方法，并且会自动转换为`&String`引用。
4. **使用场景**: 
    - 通常情况下，推荐使用`&str`来表示字符串引用，因为它是更通用、更灵活的类型。
    - `&String`通常在需要使用`String`对象的API，但又不希望获取所有权的情况下使用。

总结来说，`&str`是对原始字符串数据的不可变引用，而`&String`是对`String`对象的不可变引用。它们的主要区别在于可变性和所有权关系，以及对`String`和`&str`之间的转换。根据具体的需求和上下文，选择适合的类型来处理字符串引用。

### 2.2 数组切片
```rust
let a = [1, 2, 3, 4, 5];
// 切片类型是&[i32]
let slice = &a[1..3];
```

### 2.3 切片的隐式转换规则
问:rust 中切片的隐式转换规则

在 Rust 中，切片之间存在一些隐式转换规则，允许进行一些类型转换和借用操作。以下是常见的切片隐式转换规则：

1. 不可变切片可以隐式转换为可变切片：
   ```rust
   let numbers = [1, 2, 3, 4, 5];
   let immutable_slice: &[i32] = &numbers;
   let mutable_slice: &mut [i32] = &mut numbers;
   ```

2. 数组可以隐式转换为切片：
   ```rust
   let numbers = [1, 2, 3, 4, 5];
   let slice: &[i32] = &numbers;
   ```

3. `Vec` 类型可以隐式转换为切片：
   ```rust
   let vec = vec![1, 2, 3, 4, 5];
   let slice: &[i32] = &vec;
   ```

4. 字符串字面量可以隐式转换为 `&str` 切片：
   ```rust
   let string_literal = "Hello, world!";
   let slice: &str = string_literal;
   ```

需要注意的是，这些隐式转换都是基于引用的，不会发生数据的拷贝。转换后的切片和原始数据共享同一块内存，因此对切片的修改也会反映到原始数据上。

另外，切片隐式转换的目的是方便代码书写和传递引用，同时提供了类型安全和借用检查。这些规则确保了转换的正确性和安全性，避免了悬垂引用和数据不一致等问题。