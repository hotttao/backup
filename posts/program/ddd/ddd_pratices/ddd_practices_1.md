
---
weight: 4
title: "领域驱动设计的概念和抽象"
date: 2021-05-01T22:00:00+08:00
lastmod: 2021-05-01T22:00:00+08:00
draft: false
author: "宋涛"
authorLink: "https://hotttao.github.io/"
description: "微服务设计之领域驱动设计"
featuredImage: 

tags: ["DDD"]
categories: ["design"]

lightgallery: true

---

## 1.领域驱动设计概述
领域驱动设计是近来随着微服务而兴起的概念，但是对于单体应用而言，领域驱动设计依然是有着巨大作用，有一句话非常适合评价为什么我们需要领域驱动设计: 好的设计决策可以让我们延迟架构层面的设计。领域驱动可以给我们提供更灵活的组织代码的方式。关于领域驱动设计，我阅读的是 [领域驱动设计-软件核心复杂性应对之道](https://book.douban.com/subject/5344973/)。

整本书读下来，下面这些话对我来说是影响深刻的:
1. 详细的业务对象设计不能保证他们能够严丝合缝的呗整合到复杂的应用程序中。反复的迭代并没代码得以改进，因为开发人员的技术水平参差不齐，他们没有认识到自己使用量非正式的风格和技术体系来创建基于模型的对象。最终团队对项目失去了一致性的认识。
2. 领域驱动设计的实质就是笑话吸收大量知识，最后产生一个反应深层次领域知识并聚焦于关键概念的模型。
3. 领域模型和相应的设计可用来保护和共享知识

领域驱动的设计者为领域驱动抽象了一个思考问题的框架，学习领域驱动，就是要深入理解这个框架里面所抽象的概念，并按照领域驱动的思维模式去思考软件设计的方法。

## 2. 领域驱动设计中的抽象概念
领域驱动中有一些需要我们重点理解的概念:
1. 模型: 
   1. 模型是一种知识形式，它对知识进行有选择的简化和有目的的结构化，是抽象出来的概念
   2. 我们可以基于对模型的理解来解释代码
   3. 模型所包含的远远不只是"发现名词"，业务活动和规则如同所涉及的实体一样，都是模型所包含的重要组成部分
   4. 个人理解，关于模型所包含的知识的范围的限定是模型定义的核心，所谓合久必分，分久必合，就是对模型所包含的知识的范围的界定。
2. 模型语言: 讨论系统时要结合模型，使用模型以及模型之间的交互来描述业务场景，并按照模型允许的方式将各种概念结合在一起，最后将翻译到代码中
3. 图: 图是一种沟通和解释手段，简洁小图能够促成头脑风暴，但是包含整个对象模型的综合性的大图反而失去了沟通和解释能力，因为他们讲读者淹没在大量细节中，我们应该避免使用包罗万象的对象模型图，甚至不能使用包含所有细节的 UML 类图，相反应该使用简化的图，图中只包含对象模型的重要概念部分。图只应体现思想的纲要，设计的重要细节应该在代码中体现出来。模型不是图，图的目的是帮助表达和解释模型。
4. 文档: 文档应作为代码和口头交流的补充，不应该使用过多的设计文档，而让代码解释他自己，文档不应重复标识代码已经明确表达出的内容，设计文档最大的价值就是解释模型的概念
5. 声明式设计: 测试中的断言是严格的，但变量和代码组织方式所表达出来的意思未必严格，消除歧义是声明式设计最大的有点-程序元素的用途的陈述决定了它在程序中的实际行为
6. 领域驱动设计:
   1. 要求模型不仅能够指导早期的分析工作，还应该成为代码设计的基础，我们不能接受那些只反应领域概念却舍弃了软件设计原则的拙劣设计
   2. 要想使代码有效的模型就需要用到程序设计和实现技巧

模型是业务知识的抽象，也是软件设计的基础，最后也会成为软件开发人员职责分配的基本单元，基于模型建立的统一语言，可以更容易让所有人达成共识，在各种业务场景的分析也能更好的反馈模型设计的合理性。

好的设计决策能够使模型和程序紧密结合在一起。接下来我们要学习的就是领域驱动设计里面的设计技巧。

## 3. 分离领域
所谓分离领域，就是我们需要将领域对象与系统中的其他功能分离，这样就能够避免将领域概念和其他只与软件技术相关的概念相混淆，也不会吧领域与整个系统混为一谈。

### 3.1 Layered Architecture
在面向对象的程序中，常常在业务对象中直接写入用户界面、数据库访问等支持代码。而一些额外的业务逻辑则会嵌入到用户界面组件和数据库脚本的行为中，这么做最简单。但是如果与领域有关的的代码分散在大量的其他代码中，那么查看和分析领域代码就会变得相当困难。对用户界面的简单修改很可能改变业务逻辑，这样不太可能实现一致的、模型驱动的对象。同时也给自动化测试带来困难。

要想创建出能够处理复杂任务的程序，需要把不同的关注点分开考虑，使设计中的每个部分得到独立的关注。在分离的同时，也需要维护系统内部复杂的交互关系。而分割软件的最佳实践是采用分层架构。分层架构的基本原则是层中的任何元素都仅依赖本层的其他元素或其下层的元素。向上的通信必须通过间接的传递机制进行。而大多数成功的分层架构都包含下面四个概念层的某个版本:
![分层架构](/images/ddd/layered_architecture.png)

1. 用户界面层: 向用户显示信息和解释用户指令
2. 应用层:
   1. 定义软件要完成的任务，并指挥领域层中的对象来解决问题
   2. 应用层必须要尽量简单，不包含业务规则或者知识，只为下一层的领域对象协调任务，分配工作，使他们相互协作
   3. 不反映业务情况的状态，但可以具有另外一种状态，为用户或程序显示某个任务的进度
3. 领域层:
   1. 表达业务概念、业务状态信息以及业务规则
   2. 尽管保存业务状态的技术细节由基础设施层实现，但是反映业务情况的状态是由领域层控制并使用的
4. 基础设施层
   1. 为上面各层提供通用的技术能力
   2. 为应用层传递消息，为领域层提供持久化机制
   3. 还能够通过架构框架支持四个层次间的交互模式
   4. 基础设施层不仅限于数据库和中间件也包括应用程序所使用的的框架

除了层次的划分，层与层的连接也是至关重要的，层与层的依赖关系只能是单向的:
1. 上层可以通过调用下层元素的公共接口，也可以保持对下层元素的引用
2. 下层需要与上层通信，只能使用架构模式，比如回调模式或者 Observers 观察者模式，不过这在绝大多数情况下都是不需要或者说需要避免的

将领域层分离出来才是实现领域驱动设计的关键。

## 4. 领域驱动的模型设计
通过分层架构我们分离出了领域层，领域层包含了领域模型，领域模型最终要与代码实现一一对应起来，我们把代码中构成一个模型的各个部分称为模型构造块，领域驱动设计抽象出来的模型构造块如下图所示:

![领域驱动的标准模式](/images/ddd/ddd_unit.png)

这里面包含两个重要的层次:
1. 模型的分类和表示，模型按照功能分成三类(又叫模型元素):
   1. ENTITY: 用来表示某种具有连续性和标识的事物
   2. VALUE OBJECT: 用于描述某个事物的某种状态的属性
   3. SERVICE:表示必须实现的某项无状态的动作或操作
2. 模型之间的关联关系


## 4.1 关联
对于模型中每个可遍历的关联，在软件中都有一个具有同样属性的机制，表现为代码中的对象引用或者数据层面的关联关系。现实生活中有大量的"多对多"关联，这使得实现和维护变得复杂，至少有三种方法可以使得关联更易于控制:
1. 规定一个遍历方向
2. 添加一个规则或者说限定条件，以便有效的减少多重关联
3. 消除不必要的关联

尽可能的对关系进行约束是非常重要的，双向关联意味着只有将这两个对象放在一起考虑才能理解它们。当应用程序不要求双向遍历时，可以指定一个遍历方向，以减少相互依赖，并简化设计。

这么说有点抽象，我们以国家和总统作为例子，一个国家有很多总统，但是当提到毛主席你很少会问他是哪个国家的总统，从使用角度我们可以将关系简化为国家到总统的单向关联，这种简化反应了对领域的深入理解，它表明 **一个方向的关联比另一个方向的关联更有意义且更为重要**。

进一步研究可以发现，一个国家一段时期内只能 有一位总统，这个**限定条件**把一对多关系简化为一对一关系，并且在模型中植入了一条明确的规则。

![relation](/images/ddd/relation.png)

限定多对多关联的遍历方向可以有效的将其实现简化为一对多关联，得到一个简单的多的设计。这种限定不仅提高了关联的表达力并简化实现，也突出了剩下的双向关联的重要性。当然最终的简化是清除那些对当前工作或模型对象的基本含义来说不重要的关联。

### 4.2 模型: ENTITY
ENTITY 又称 REFERENCE OBOJECT，很多对象不是通过他们的属性定义的，而是通过一连串的连续事件和标识定义的。这种对象表示了一条"标识线"，这条线经过了一个时间跨度，而且对象在这条线上通常经历了多种不同的表示。有时这样的对象必须与另一个不同属性的对象相匹配。而有时一个对象必须与具有相同属性的另一个对象区分开。

主要由标识定义的对象称作 ENTITY。ENTITY 具有生命周期，这期间它的形式和内容可能发生改变，但标识保持不变。ENTITY 最基本职责是确保连续性，以便使其行为更清楚且可预测。ENTITY 的实现应该保持简练，抓住 ENTITY 对象定义的最基本特征，尤其是那些用于识别、查找活匹配对象的特征。只添加那些对概念至关重要的行为和这些行为所必须的属性。除此之外的属性应该转移到与核心实体关联的其他对象中。除了标识问题外，实体往往通过协调其他对象的操作来完成自己到的职责。

### 4.3 模型: VALUE OBJECT
用于描述领域的某个方面而本身没有标识的对象成为 VALUE OBJECT 值对象。值对象的重点在于它们是什么，而不关心它们是谁。VALUE OBJECT 经常作为参数在对象之间传递消息。也可以用作 ENTITY 的属性。VALUE OBJECT 应该是不可变的，也不应该设计的过于复杂。VALUE OBJECT 所包含的属性应该形成一个概念整体，比如街道、城市和邮政编码不应该是人的属性，它们应该是整个地址的一部分，而人只包含地址一个总的属性。VALUE OBJECT 应该保证不可变，这样就可以共享，如果必须发生改变，则必须创建一个副本。**复制和共享哪个更划算取决于实现环境**。

只要 VALUE OBJECT 是不可变的，变更管理就会很简单，因为除了整体替换之外没有其他的更改。

### 4.4 模型: SERVICE
通常而言操作不是对象，但是由于我们建模的是对象，因此需要把操作也划分到对象的范畴里。SERVICE 是作为接口提供的一种操作，他在模型中是独立的，是无状态的。它强调的是与其他对象的关系(我的理解 SERVICE 封装的对象的组合逻辑)，以一个活动命名。SERVICE 也应该有定义的职责，而且这种职责以及履行它的接口也应该作为领域模型的一部分被定义，其参数和结果应该都是领域对象。

好的 SERVICE 有以下三个特征:
1. 包含的操作不是 ENTITY 或  VALUE OBJECT 的一个自然部分
2. 接口是根据领域模型的其他元素定义的
3. 操作是无状态，状态都应该在 ENTITYT 和 VALUE OBJECT 中维护

ENTITYT 和 VALUE OBJECT 往往由于粒度过细而无法提供对领域层功能的便捷访问。SERVICE 则组合了不同的 ENTITYT 和 VALUE OBJECT 向上提供了一个完整的功能，更重要的是组合的逻辑中包含了业务规则。

从另一个层面来说 SERVICE 可以控制领域层中接口的粒度，避免客户与 ENTITYT 和 VALUE OBJECT 的耦合。SERVICE 就好像一扇门，避免了领域知识泄漏到应用层。同时在大型系统中中等粒度的，无状态的 SERVICE 更容易被重用。而细粒度的对象可能导致分布式系统中的消息传递的效率低下。

### 4.5 模型: MODULE/PACKAGE
MODULE 为人们提供了两种光差模型的方式:
1. 可以在 MODULE 中查看细节，而不会被整个模型淹没
2. 观察MODULE之间的关系，而不考虑内部细节

**MODULE 不仅仅是代码的划分，也是概念的划分**。低耦合高内聚是 MODULE 设计的基本原则。和其他模块对象一样， MODULE 是一种表达机制，MODULE 的选择应该取决于被划分到模块中的对象的意义。

领域模型中的每个概念都应该在实现元素中反应出来。ENTITY VALUE OBJECT、它们之间的关联、领域 SERVICE 以及用于组织元素的 MODULE 都是实现与模型直接对应的地方。实现中的对象、指针和检索机制必须直接、清楚的映射到模型元素。如果没有做到这一点，就要重写代码、或者回头修改模型，或者同事修改代码和模型。

### 4.6 建模范式
面向对象是领域驱动设计中主流的建模范式，但是建模范式不一定是面向对象，领域模型也不一定是对象模型。不管项目中使用哪种主要的模型范式，领域中都会有一部分更容易用某种其他范式来表达。当领域的主要部分明显属于不同的范式时，明智的做法是用适合各个部分的的范式对每个部分分别建模，并使用混合的工具集来为实现提供支持。

例如当对象的交互依赖于某些数学关系的时候。这就是将业务规则引擎或工作流引擎这样的非对象组件集成到对象系统中的动机。混合使用不同的范式使得开发人员能够用最合适的风格对特殊概念进行建模。

书中关于建模范式的讨论，我暂时没太看懂。 

## 5. 对象创建和持久化
接下来我们将注意力转移到生命周期的开始阶段，使用 Factory 工厂模式来创建和重建复杂对象，并使用 Aggregate 来封装它们的内部结构。最后在生命周期的中间和末尾使用 Respository(存储库) 来提供查找和检索持久化对象并封装庞大基础设施的手段。Aggregate 可以划分出一个范围，这个范围内的模型元素在生命周期各个阶段都应该维护其固定规则。Factory 和 Repository 在 Aggregate 基础上进行操作，将特定生命周期转换的复杂性封装起来。

### 5.1 Aggregate
将关联减少至最少的设计有助于简化对象之间的遍历，并在某种程度上限制关系的急剧增加。单大多数业务领域的对象都具有十分复杂的联系，以至于最终形成一个很长、很深的对象引用路径，我们不得不在路径上追踪对象。

在具有复杂关联的模型中，保证对象更改的一致性是困难了，一方面是关联对象之间都要遵守一些固定的规则，另一方面并发的操作可能引发并发问题，过于谨慎的锁机制又会导致用户之间毫无意义的相互干扰，从而使得系统不可用。我们需要找到一个对象间冲突较少而固定规则联系更紧密的模型。

换句话说，我们如何知道一个由其他对象组成的对象从哪里开始，又到何处结束呢？人们已经开发出很多模式来定义模型在红的所属关系。
1. 首先我们需要要一个抽象来封装模型中的引用，Aggregate 就是一组相关对象的集合，我们把它作为数据修改的单元。
2. 每个 Aggregate 都有一个根 root 和一个变节 boundary。边界定义了 Aggregate 内部都有什么，根则是 Aggregate 所包含的一个特定 ENTITY
3. 在 Aggregate中，根是唯一允许外部对象保持对它的引用的元素，边界内部的对象之间则可以互相引用
4. 除根之外的其他 ENTITY 都有本地标识，这些标识只在 Aggregate 内部才需要加以区分

固定规则是指在数据变化时必须保持不变的一致性规则。Aggregate 内部的成员之间可能存在固定关系。Aggregate 中的所有规则并不是每时每刻都被更新为最新的状态。通过事件处理、批处理或其他更新机制，在一定时间内可以解决部分依赖性。但在每个事物完成时，必须要满足 Aggregate 内所应用的固定规则的要求。为了实现 Aggregate 内的所有规则，必须对所有事物应用一组规则:
1. 根 ENTITY 负责最终检查固定规则
2. Aggregate 外部的对象不能引用除根 ENTITY 之外的任何内部对象。根 ENTITY 可以把对内部 ENTITY 的引用传递给它们，但是这些对象只能临时使用这些引用，不能保持引用。
3. 根可以把一个 Value Object 的副本传递给另一个对象，而不关心它发生什么变化，因为它只是一个 Value 不在于 Aggregate 有任何关联
4. 只有 Aggregate 的根才能直接通过数据库进行查询，所有其他对象必须通过关联的遍历才能找到
5. Aggregate 内部可以保持对其他 Aggregate 的引用
6. 当提交 Aggregate 边界内部的任何对象的修改时，整个 Aggregate 的所有固定规则都必须被满足

我们应该将 ENTITY 和 Value Object 分门别类放到 Aggregate 中。并定义每个 Aggregate 的边界，通过跟 ENTITY 控制外部对边界内其他对象的访问。只允许外部对象保持对根的引用，对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。根 ENTITY 要保证 Aggregate 内的所有固定规则在事物提交时被同时满足。Aggregate划分出一个范围，生命周期的每个阶段都必须满足一些固定规则。

### 5.2 Factory
Factory 工厂模式用于封装一个复杂对象的创建。注意，复杂对象的创建是领域层的职责，不应该将其放到应用层，否则应用层将与领域层的实现相耦合，从而使得领域驱动设计遭到破坏。

正如对象的接口应该封装对象的实现一样(客户无需知道工作机制就可以使用对象的行为)，Factory 也应该封装创建一个复杂对象的或 Aggregate  所需要的的知识(包括哪个是根，根与内部对象和外部对象的引用关系)。

Factory 工厂要满足以下两个基本需求:
1. 每个创建方法都是原子方法，而且满足贝创建对象或 Aggregate 的所有固定规则。但是把应用于一个对象的规则转移到该对象之外需要三思。Factory 可以将固定规则检查工作委派给 Aggregate。
2. Factory 应该被抽象为所需要的的类型，而不是创建出具体的类

但是下面这些情况，最好使用简单的构造函数而不是 Factory:
1. 类是一种类型，它不是任何相关层次结构的一部分，而且也没有通过接口实现多态
2. 客户关心的是实现，可能是将其作为选择Strategy 的一种方式
3. 构造并不复杂
4. 构造函数必须满足与 Factory 相同的规则，他必须是一个原子操作，且满足被创建对象的所有固定规则。

不要在构造函数中调用其他类的构造函数。

#### 重建已存储的对象
目前为止，Factory 知识发挥了它在对象生命周期开始时的作用。而通常内存中的对象需要被序列化后存储到数据库或被网络传输。因此检索操作需要一个复杂的过程将各个部分重新装配成一个可用对象。用于重建对象的 Factory 与用于创建的 Factory 很类似，但有以下两点不同:
1. 重建对象的 Factory 不分配新的追踪ID
2. 当固定规则未被满足，重建对象的 Factory 采用不同的处理方式

所以通常情况下 **一个复杂对象的创建需要初始化和重建两种 Factory** ，而重建的 Factory 某种程度上就是我们下面要说的 Repository。

## 6. Repository
另一种大大增强领域驱动设计复杂性的转换是对象与存储之间的相互转换。这种转换由另一种构造来完成，就是 Repository。

大多数程序都使用关系型数据库，这种存储技术使人们自然而然使用第三种获取对象引用的方式，基于对象的属性，执行查询来找到对象；或者找到对象的组成部分然后重建它。是通过关联遍历还是依靠搜索，这是一个设计决策，需要在搜索的解耦与关联的内聚之间做出权衡。

从技术上看，检索一个已存储对象的过程属于一种创建对象的操作，即重建。通常我们会构造一个 SQL 查询，并把它传递给基础设施层，然后根据得到的数据传递给构造函数或者  Factory。这里面容易出现的问题是开发人员在整个处理的过程中很自然的把对象当做容器来防止查询的数据，而不是模型的概念。结果就是越来越多的开发人员绕过模型，甚至是对象的封装，直接获取和操作他们所需的数据。这将导致越来越多的领域规则被嵌入到查询代码中。或者干脆丢失。

我们需要以一种符合实际的方式来获取对已存在的领域对象的引用。如果基础设施层随随便便就允许开发人员获得这些引用，那么他们就会增加很多可遍历的关联，这会使得模型变得非常混乱。另一方面，开发人员可能使用查询从数据库中提取他们所需要的的数据，或者直接提取几个具体的对象，而不是通过 Aggregate 根开始导航来得到这些对象。这样就会导致领域逻辑泄漏到查询和客户代码中，而 ENTITY 和 Value Object 变成单纯的数据容器。大多数用于数据库访问的基础设施的技术复杂性会很快使客户代码变得混乱，这将导致开发人员放弃领域层，最后使得模型变得无关紧要。

在所有持久对象中，有一部分必须能够通过基于对象属性的搜索来全局访问。当不易通过遍历的方式来访问某些 Aggregate 根的时候，就需要使用这种访问方式。它们通常是 ENTITY，有时是具有复杂内部结构的 Value Object，有时还可能是枚举Value。而其他对象则不宜使用这种访问方式。因为这会混淆它们的重要区别。无约束的数据查询可能会破坏领域对象的封装和 Aggregate。技术基础设施和数据库访问机制的暴露会增加客户的复杂度，并妨碍模型驱动的设计。有很多技术可以简化数据库访问，但是怎么使用它们就是 Repository 约定的内容。

### 6.1 Repository 作用
Repository 是一个概念框架，不是一个具体的技术。Respository 将同一类型的所有对象表示为一个概念集合。在添加或删除相应类型的对象时，Respository 的后台机制负责底层的数据库更改。客户使用查询方法向 Respository 请求对象，它类似一个抽象层，封装了对基础设施的访问。

只为那些确实需要直接访问的 Aggregate 根提供 Respository。让客户始终聚焦于模型，而将所有对象存储和访问操作交给 Respository 来完成。

Respository 有很多优点:
1. 向上提供了简单接口
2. 使得应用程序、领域设计、持久化技术解耦
3. 很容易 mock，非常便于测试

Respository 委托基础设施层服务来完成工作，将存储、检索和查询机制封装起来是 Respository 实现的最基本的特性。这也意味着我们充分利用 Respository 与客户端解耦特性，最小修改的去优化我们的基础框架。例如在基础框架上添加缓存机制。最后尽管 Respository 用于封装数据库操作。但是事务的控制权需要保留给客户，you客户端应该负责初始化和提交工作单元。

### 6.2 Respository 与 Factory
Factory 负责处理对象生命周期的开始，而 Respository帮助管理生命周期的中间和结束。由于 Respository 需要基于检索出来的数据重建对象，从技术实现上 Respository 与 Factory 很像。但是从领域模型视角，二者具有完全不同的职责。Factory 负责创建新对象， Respository 负责查找和重建对象。

Respository 可以委托 Factory 来创建对象。