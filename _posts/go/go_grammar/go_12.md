---
title: 12 go test 和测试函数
date: 2019-01-12
categories:
    - Go
tags:
    - go语言入门
---

go test 和测试函数
<!-- more -->


在包目录内，所有以 \_test.go为后缀
名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分


*_test.go文件中，有三种类型的函数：
1. 测试函数： 
	- 以Test为函数名前缀的函数，可选的后缀名必须以大写字母开头
	- 用于测试程序的一些逻辑行为是否正确
2. 基准测试(benchmark)函数：
	- 基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能
	- go test命令会多次运行基准函数以计算一个平均的执行时间
3. 示例函数：
	- 示例函数是以Example为函数名前缀的函数
	- 提供一个由编译器保证正确性的示例文档

go test命令会遍历所有的 \*\_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于
调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件

## 1. 测试函数

```Go
import testing

# 其中t参数用于报告测试失败和附加的日志信息
func TestName(t *testing.T) {
	// ...
}
```


```Go
go test ‐v ‐run="French|Canal"

```
go test命令如果没有参数指定包那么将默认采用当前目录对应的包
‐v可用于打印每个测试函数的名字和运行时间
‐run对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被 go test测试命令运行


失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息


如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用

测试失败的信息一般的形式是“f(x) = y, want z”，其中f(x)解释了失败的操作和对应的输出，y是实际
的运行结果，z是期望的正确的结果


要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。

如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。

如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。

以这种方式使用全局变量是安全的，因为go test命令并不会同时并发地执行多个测试