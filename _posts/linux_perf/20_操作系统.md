---
title: 4. 操作系统
date: 2020-01-15
categories:
    - 运维
tags:
    - Linux性能调优
---

从本文开始我们将进入Linux性能优化的第二阶段，操作系统部分。操作系统原理是复杂的，不可能也没有能力把操作系统都将清楚。我们会列出每个部分相关的关键术语，并就其中与性能优化相关的关键部分进行讲解。本文是一个关于操作系统和内核知识的概览，为后面做一点准备。

<!-- more -->

与操作系统相关的术语:
1. 进程: 一个 OS 的抽象概念，是用来执行程序的环境，运行在用户模式(用户态)，通过系统调用或自陷来进入内核模式
2. 线程: 可被调度的运行在 CPU上的可执行上下文
3. 系统调用: 一套明确定义的协议，为用户程序请求内核执行特权操作
4. 自陷: 信号发送到内核，请求执行一段系统程序(特权操作)，自陷类型包括系统调用、处理器异常以及中断
5. 中断: 由物理设备发送到内核的信号，通常是请求 I/O 服务，中断是自陷的一种类型
6. 时钟: 是一个驱动所有处理器逻辑的数字信号，CPU 以一个特定的时钟频率执行

## 1. CPU
### 1.1 停止周期
CPU 指令的执行包括预期，解码，执行，内存访问，寄存器写回。内存访问往往需要几十个CPU周期，这段期间指令执行陷入停滞，这段时间称为停滞周期，因此需要CPU缓存降低内存访问的周期数。

CPI和IPC: 
- CPI: 每指令周期数，IPC 的倒数，代表了指令处理的效率，是 CPU 使用率的本质，CPI 较高代表 CPU 经常陷入停滞
- IPC: 每周期指令数， instructions per cycle

### 1.2 缓存一致性
内存可能会同时被缓存在不同处理的多个 CPU 缓存中，缓存一致性确保了 CPU 永远访问正确的内存状态

### 1.3 MMU 和 TLB
![mmu_tlb](/images/linux_pf/mmu_tlb.png)
- I$: 一级指令缓存: 按照虚拟地址空间寻址
- D$: 一级数据缓存: 按照虚拟地址空间寻址
- TLB: 转移后备缓冲器
- E$: 二级缓存：按照物理内存地址寻址

MMU 负责虚拟地址到物理地址的转换，主存里的页表由MMU(硬件)直接读取，处理缓存未命中情况。

### 1.4 CPU 互联
多处理器架构的 CPU 互联与系统的内存架构(同一内存访问 UMA，或者 NUMA)有关。常见的CPU有两种连接方式:
1. 共享系统总线: 在处理器数量增加增加的情况下，会因为共享总线而出现扩展性问题
2. 专用互联: 互联不仅仅是处理器，还可以是其他组件，一个四处理器的Intel QPI 架构如下所示:

![QPI]((/images/linux_pf/QPI.png)

处理器之间的私有连接提供了无须竞争的访问以及比共享系统总线更高的带宽。除了外部互联，处理器还有核间通信用的内部互联。

### 1.5 CPU性能计数器
CPU性能计数器(CPC) 有很多别名包括性能监测点计数器(PIC)、性能监控单元(PMU)、硬件时间和性能监控事件。它们是可以计数低级 CPU 活动的处理器寄存器。通常包括下列计数器:
1. CPU 周期: 包括停滞周期和停滞周期类型
2. CPU 指令: 
3. 一级，二级，三级缓存访问: 命中，未命中
4. 浮点单元操作
5. 内存 I/O: 读写停滞周期
6. 资源 I/O: 读写停滞周期

每个 CPU 有少量，通常是 2-8 个，可编程记录类似事件的寄存器，哪些寄存器可用取决于处理器的型号。计数器计量哪些事件通过事件选择和 UMASK 确定。事件选择确定要计数的事件类型，UMASK 确定子类型或者子类型组。

## 2. 内核
### 2.1 时钟
UNIX 内核的一个核心组件是 clock() 例程，从一个计时器中断执行，每执行一次成为一个 tick。功能包括更新系统时间，计时器和线程调度时间片的到时结束，维护CPU计数器，以及执行 callout(内核调度例程)。

但是 clock() 曾经有过性能问题。现代内核已经把许多功能移出了 clock 例程，放到了按需中断中，这是为了努力创造无 tick 内核。包括 Linux 在内，clock 例程即系统计时器中断，除了更新系统时钟和更新 jiffies 计数器之外，执行的工作很少。jiffies 是 Linux 的时间单元与 tick 类似。

### 2.2 内核态
用户进程通过系统调用执行内核特权操作时，会做上下文切换，从用户态到内核态。

无论是用户态还是内核态，都有自己的软件执行上下文，包括栈和寄存器。这些状态切换上下文是会耗费 CPU 周期的，这对每次I/O都增加了一小部分的时间开销。

### 2.3 用户栈和内核栈
执行系统调用时，一个进程的线程有两个栈: 一个用户级别栈和一个内核级别的栈。线程被阻塞时，用户级别的栈在系统调用期间不会改变，当执行在内核上下文时，线程用的是一个单独的内核级别栈。此处有一个例外，信号处理程序取决于其配置，可以借用用户级别的栈。

### 2.4 中断和中断线程
![interrupt](/images/linux_pf/interrupt.png)

中断被内核用来响应设备的服务请求，分为:
1. 中断服务程序: 需要通过注册来处理设备中断，这类程序需要运行的尽可能块，以减少对活动线程中断的影响。如果中断要做的工作不少，尤其是可能被阻塞，最好通过中断线程来处理，由内核调度
2. 从中断开始到中断被服务之间的时间叫做中断延时

中断是一种异步的事件处理机制，用来提高系统的并发处理能力。

### 2.5 调度器
分时系统，通过划分执行时间，让多个进程同时运行。进程在处理器上和CPU间的调度是由调度器完成的。调度器操作线程(Linux 中是任务 task)，并将它们隐射到 CPU 上。

![kernel_schduler](/images/linux_pf/kernel_schduler.png)

- VCX: 资源上下文切换
- ICX: 非自愿上下文切换
- Premption: 抢占
- Time Sharing: 分时
- ON-PROC: 运行中
- RUNNABLE: 可运行

#### 调度器功能及实现
调度器要实现如下功能:
1. 分时: 可运行多线程
2. 抢占: 高优先级线程在变为可运行状态时，能抢占当前运行的线程
3. 负载均衡: CPU 之间的负载均衡

在 Linux 上
1. 分时通过**系统时钟中断**调用 scheduler_tick() 实现
2. scheduler_tick 调用**调度器类函数**管理优先级和称为时间片的 CPU时间单位的到期事件
3. 当线程变成可运行状态后就出发抢占，调度类函数 check_preempt_curr() 被调用
4. 线程切换有 _schedule()管理，后者通过 pick_next_task() 选择最高优先级的线程运行
5. 负载均衡由 load_balance() 函数负责执行

#### 空闲线程
内核"空闲"线程只在没有其他可运行线程的时候才在 CPU 上运行，通常被设计为通知CPU执行停止指令或者减速以节省资源，CPU会在下一次硬件中断醒来。

### 2.5 设备驱动
设备驱动是用于设备管理和设备I/O的内核软件，有硬件开发厂商提供。

## 3. 进程
进程包括进程地址空间内的数据和内核里的元数据(上下文)：
1. 内核上下文包含各种进程属性和统计信息
2. 每一线程都包含一些元数据，包括在内核上下文里自己的优先级以及用户地址空间里自己的栈。

![Process environment](/images/linux_pf/process_enviroment.png)

## 4. 虚拟内存


### 4.1 内存管理
当虚拟内存用二级存储(磁盘)作为主存的扩展时，内存管理决定哪些数据保存在主存中。


## 5. 文件系统
### 5.1 VFS
虚拟文件系统 VFS 是一个文件系统类型作抽象的内核界面。VFS 接口让内核添加新的文件系统时更加简单。

![vfs](/images/linux_pf/vfs.png)

### 5.2 I/O 栈
基于存储设备的文件系统，从用户级软件到存储设备的路径被称为 I/O 栈

![io_stack](/images/linux_pf/io_stack.png)
