

本节展示了从头到尾创建一个可工作的Python脚本的过程，该脚本聚合并从原始perf脚本流提取有用的信息。如果一个示例就足够了，您可以避免阅读本文的其余部分;文档的其余部分提供了每个步骤的更多细节，并列出了脚本作者可以使用的库函数。这个示例实际上详细描述了创建系统调用计数脚本的步骤，您可以通过perf脚本-l列出可用的perf脚本。同样，这个脚本还展示了如何将您的脚本集成到该命令列出的通用perf脚本列表中。系统调用计数脚本是一个简单的脚本，但是演示了创建有用脚本所需的所有基本思想。下面是它的输出示例(syscall名称还不支持，它们将作为数字出现):

```bash
syscall events:

           event                                          count
           ----------------------------------------  -----------
           sys_write                                     455067
           sys_getdents                                    4072
           sys_close                                       3037
           sys_swapoff                                     1769
           sys_read                                         923
           sys_sched_setparam                               826
           sys_open                                         331
           sys_newfstat                                     326
           sys_mmap                                         217
           sys_munmap                                       216
           sys_futex                                        141
           sys_select                                       102
           sys_poll                                          84
           sys_setitimer                                     12
           sys_writev                                         8
           15                                                 8
           sys_lseek                                          7
           sys_rt_sigprocmask                                 6
           sys_wait4                                          3
           sys_ioctl                                          3
           sys_set_robust_list                                1
           sys_exit                                           1
           56                                                 1
           sys_access                                         1
           .ft
```

基本上，我们的任务是保持每个系统调用的记录，该记录在系统中每次发生系统调用时更新。我们的脚本会这样做，但首先我们需要记录将由该脚本处理的数据。从理论上讲，有几种方法可以做到这一点:
1. 我们可以在tracing/events/syscalls目录下启用每个事件，但是这超过了600个syscalls，远远超出了perf允许的数量。但是，如果我们希望以后使用从通用脚本中获得的指导来深入了解和获得有关各个系统调用的更多细节，那么这些单独的系统调用事件将非常有用。
2. 我们可以启用在跟踪/events/raw_syscalls下找到的sys_enter和/或sys_exit syscalls。这是所有系统调用;id字段可用于区分各个系统调用编号。

对于这个脚本，我们只需要知道输入了一个系统调用;我们不关心它是如何退出的，所以我们将使用perf记录来只记录sys_enter事件:

```bash
.ft C
perf record -a -e raw_syscalls:sys_enter

^C[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 56.545 MB perf.data (~2470503 samples) ]
.ft
```

这些选项基本上是说为系统范围内的每个syscall事件收集数据，并将每个cpu的输出多路复用到单个流中。这个单独的流将被记录在当前目录中的一个名为perf.data的文件中。一旦有了perf。包含我们的数据的数据文件，我们可以使用-g perf脚本选项来生成一个Python脚本，该脚本将为perf中找到的每个事件类型包含一个回调处理程序。数据跟踪流(有关详细信息，请参阅启动脚本部分)。

```bash
.ft C
# perf script -g python
generated Python script: perf-script.py

The output file created also in the current directory is named
perf-script.py.  Here's the file in its entirety:

# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

import os
import sys

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

def trace_begin():
        print "in trace_begin"

def trace_end():
        print "in trace_end"

def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
                print_header(event_name, common_cpu, common_secs, common_nsecs,
                        common_pid, common_comm)

                print "id=%d, args=%s\n" % \
                (id, args),

def trace_unhandled(event_name, context, event_fields_dict):
                print ' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())])

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print "%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm),
.ft

```

在顶部是一个注释块，后面是一些导入语句和一个path append，每个perf脚本都应该包括这个path append。接下来是一些生成的函数，trace_begin()和trace_end()，它们分别在脚本的开头和结尾调用(有关更多细节，请参阅下面的SCRIPT_LAYOUT部分)。下面是为perf记录输出中的每个事件生成的事件处理程序函数。处理函数采用表单subsystemevent_name，并包含命名参数，每个参数对应于事件中的每个字段;在本例中，只有一个事件raw_syscallssys_enter()。(有关事件处理程序的更多信息，请参见下面的事件处理程序一节)。最后两个函数与begin和end函数一样，是为每个脚本生成的。第一个方法trace_unhandling()在每次脚本在perf中找到事件时调用。与脚本中的任何事件处理程序不对应的数据文件。这可能意味着记录步骤记录了它并不真正感兴趣的事件类型，或者脚本是针对与脚本不对应的跟踪文件运行的。由-g选项生成的脚本只是为跟踪流中找到的每个事件打印一行，也就是说，它基本上只是将事件及其参数值转储到stdout。print_header()函数只是用于该目的的一个实用程序函数。让我们重命名脚本并运行它来查看默认输出: