---
title: 4.1 CPU
date: 2020-01-16
categories:
    - 运维
tags:
    - Linux性能调优
---
本节我们来介绍 CPU 相关的操作系统原理。
<!-- more -->

## 1. CPU 相关的操作原理

### 1.2 上下文切换
在前面的文章我们说过，用户进程通过系统调用执行内核特权操作时，会做上下文切换，从用户态进入到内核态。但是根据切换的任务的不提供，上下文切换包括多种类型:
1. 进程上下文切换
2. 线程上下文切换
3. 中断上下文切换
4. 系统调用的上下文切换

首先我们要明白的是，无论什么类型的上下文切换， CPU 寄存器和程序计数器（Program Counter，PC）都需要保存和重载，这一部又分称为CPU 上下文切换。其次不同的类型上下文切换因为不同任务间共享层次不同，需要交换的内容也就不同。

#### 系统调用的上下文切换
前面我们说过，执行系统调用时，一个进程的线程有两个栈: 一个用户级别栈和一个内核级别的栈。线程被阻塞时，用户级别的栈在系统调用期间不会改变。所以系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，上下文交换需要完成的操作其实很少。

### 进程上下文切换
![Process environment](/images/linux_pf/process_enviroment.png)

进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。这些资源在进程上下文切换时都要保存和恢复。

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新。在多处理器系统上，缓存是被多个处理器共享的，进程切换也会导致缓存被刷新。

由此可见进程上下文切换成本较高。

#### 线程切换
通常线程切换说的是同一进程内的线程，因为不同进程内的线程切换叫做进程切换。
 
线程会共享相同的虚拟内存和全局变量等资源。这些在上下文切换时是不需要修改的。需要保存的仅仅是线程的私有数据，比如栈和寄存器等。

#### 中断上下文切换
为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。因此中断上下文切换并不涉及到进程的用户态，只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

可以查看上下文切换到工具有 **vmstat, pidstat -tw**

## 2. 监测指标
与 CPU 相关的专业术语或者指标包括:
1. 系统负载
2. CPU 使用率
3. 中断计数

### 2.1 进程状态与系统负载
```bash
> uptime
# 过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）
 05:10:14 up  8:37,  2 users,  load average: 0.21, 0.06, 0.06
 
> watch -d uptime

# 查看 CPU 个数
> grep 'model name' /proc/cpuinfo | wc -l
```

uptime 中定义的系统负载与进程状态有关，ps 命令显示的进程状态有如下几种
|状态|含义|
|:---|:---|
|D   | 不可中断睡眠 (通常是在IO操作) 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生|
|R   |正在运行或可运行（在运行队列排队中）|
|S   |可中断睡眠 (休眠中, 受阻, 在等待某个条件的形成或接受到信号)|
|T   |已停止的 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行|
|W   |正在换页(2.6.内核之前有效)|
| X  | 死进程 (未开启)|
| Z  | 僵尸进程  进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放BSD风格的|
| <  | 高优先级(not nice to other users)|
| N  | 低优先级(nice to other users)|
| L  | 页面锁定在内存（实时和定制的IO）|
| s  | 一个信息头|
| l  | 多线程（使用 CLONE_THREAD，像NPTL的pthreads的那样）|
| +  | 在前台进程组|

平均负载是指单位时间内，系统处于可运行状态(R)和不可中断状态(D)的平均进程数,因此平均负载跟CPU使用率没有必然联系。

## 2.2 CPU 使用率
首先 CPU 使用率跟 CPU 时间片有关:
1. Linux 通过事先定义的节拍率（内核中表示为 HZ），来定义时间片的长短。HZ 是内核的可配选项，可以通过查询 /boot/config 内核选项来查看它的配置值。
2. 时间片到期时，会触发系统计时器中断即clock()例程，会更新系统时钟和 jiffies 计数器
3. 为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒

```bash
grep 'CONFIG_HZ=' /boot/config-$(uname -r)
```

根据计数器，操作系统统计了 CPU 和进程运行状态的统计信息:
4. /proc/stat 提供了系统的 CPU 和任务统计信息
5. `/proc/[pid]/stat` 提供了每个进程提供了运行情况的统计信息

诸如 `top, ps, mpstat, pidstat -u` 正是使用上面的数据计算的 CPU 使用率，不同的是计算的方式和周期不同而已。对于CPU使用率的深入分析，需要借助 perf 等高级分析工具。

#### CPU 使用率的相关指标
下面这些指标在各种 CPU 监测工具中都能看到，使用 man proc 可以看到他们的说明，但是最好是能记住:

|指标|缩写|含义|
|:---|:---|:---|
|user| us|代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。|
|nice| ni|代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。|
|system| sys|代表内核态 CPU 时间。|
|idle| id|代表空闲时间。注意，它不包括等待 I/O 的时间|
|iowait| wa|代表等待 I/O 的 CPU 时间，出现 iowait 有两个条件，一是进程在等io，二是等io时没有进程可运行|
|irq| hi|代表处理硬中断的 CPU 时间。|
|softirq| si|代表处理软中断的 CPU 时间。|
|steal| st|代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。|
|guest| guest|代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。|
|guest_nice| gnice|代表以低优先级运行虚拟机的时间。而我们通常所说的 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时|

注意：通常我们收的 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时



## 2.3 中断计数
中断的计数信息位于 `/proc/interrupts` 文件中。
```bash
# 动态查看中断计数器的变化
> watch -d cat /proc/interrupts
```

中断的类型很多，常见的需要我们知道，包括:
1. 重调度中断(RES): 又称处理器中断，与CPU之间实现缓存一致性和负载均衡有关
