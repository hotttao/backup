---
title: 4.4 内存
date: 2020-01-19
categories:
    - 运维
tags:
    - Linux性能调优
---

本节我们来介绍内存相关的操作系统原理。
<!-- more -->

## 1. 内存相关的操作原理
我们从下面几个方面入手来讲解内存相关的操作系统原理:
1. 虚拟内存和页:
2. 内存架构
2. 内存管理
3. 进程地址空间

最后我们会说一说内存检测的相关指标。

## 2. 虚拟内存和换页
![vritual_memory](/images/linux_pf/vritual_memory.png)
虚拟内存是一个抽象概念，它向每个进程和内核提供巨大的、线性的并且私有的地址空间。它简化了软件开发，把物理内存的分配交给操作系统管理。

从上面的图可以看到进程的地址空间由虚拟内存子系统隐射到主内存和物理交换设备。当内存不够用时，内核需要按需在它们之间移动内存页，称为换页。

换页分为两种类型:
1. 为交换共享文件系统的页缓存而产生的文件系统换页
2. 虚拟内存的匿名换页

**文件系统换页**
文件系统换页由读写位于内存中的映射文件页引发。映射文件产生自:
1. 使用文件内存映射 mmap 的应用程序
2. 使用了页缓存的文件系统

文件系统页可能因为在主存修改过("脏的")在换出时需要写回磁盘。如果没有修改过(干净的)因为磁盘已有副本，换页仅仅需要释放内存即可。

**匿名换页**
匿名换页涉及进程私有数据: 堆和栈，要求数据保存至交换设备，因为这些数据磁盘没有副本。匿名页换入会给应用程序带来同步延时，因为必然发生读磁盘I/O，换出可能不会直接应用程序性能，因为换出是内核异步执行的。

### 2.1 按需换页
按需换页将CPU创建和映射内存的开销延时到实际访问或需要，而不是初次分配内存时。访问一个未映射的内存页将产生一个缺页异常。

虚拟内存页存在以下几种状态:
1. 未分配
2. 已分配，未映射
3. 已分配，已映射到主存
4. 已分配，已映射到物理交换空间(磁盘)

从 2->3就是缺页，如果需要磁盘读写就是严重缺页异常，否则就是次缺页异常。从这几种状态出发可以定义另外两个内存时术语:
1. 常驻集合大小 RSS: 已分配的主存(状态3)大小
2. 虚拟内存大小: 所有已分配区域(2+3+4)

除此之外我们还能经常看到另一个内存术语，共享内存 SHR，它标识与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等所占用的内存。要注意共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里。当然，SHR 也包括了进程间真正共享的内存。


## 3.内存架构
### 3.1 UMA 架构
内存硬件包括主存，总线，CPU 缓存和 MMU(内存管理单元)。下面展示了一个普通双处理器均匀访问模型(UMA) 系统的主存架构，又称对称多处理器架构 SMP

![UMA](/images/linux_pf/UMA.png)

通过共享总线，每个 CPU 访问所有内存都有均匀的访问延时。

### 3.2 NUMA
作为对照下面是一个双处理器非均匀访问模型 NUMA 系统，其中采用一个 CPU 互联(CPU 原理一章有提到)。

![NUMA](/images/linux_pf/NUMA.png)

对主存的访问时间随着相对 CPU 的位置不同而变化。与 CPU 直接相连的内存称为本地内存。

## 4.内存管理
内存管理软件包括虚拟内存系统，地址转换，换页。与性能相关的内容包括: 
1. 内存释放
2. 内存分配

### 4.1 内存分配
内存分配器用于内存分配。下图展示了分配器的作用，以及分配器的一些常见类型:
1. slab: 内核级分配器
2. libc: 用户级分配器的统称，包括 libmalloc, libumem, mumalloc
3. **Page Allocator**: Linux 用于管理页的伙伴分配器，在下面的空闲链表中会详细介绍

![allocators](/images/linux_pf/allocators.png)

#### slab
内核 slab 分配器管理特定大小的对象缓存，使它们能被快速的回收利用，并且避免页分配开销。这对经常处理固定大小结构的内核内存分配来说特别有效。slab 大小固定，因此可以一次分配 M 个 slab 大小的缓存，也就避免了多次页分配的开销。大小固定类似于数组也便于回收利用。

Linux 基于 slab 分配器提供了另一个分配器 SLUB。SLUB 为解决多个问题设计，特别是 slab 分配器的复杂性。包括移除对象队列，以及每 CPU 缓存，吧 NUMA 优化留个页分配器(Page Allocator) 

SLUB 现在是 Linux 的默认选项.

#### 用户级分配器
有多种用户级分配器，他们的性能也有所差异：
1. libc: 不建议使用，性能较差，容易导致内存碎片化
2. glibc: 分配基于分配请求的长度，是结合了多种分配策略的高效分配器
    - 较小的分配来自内存集合，包括伙伴关系算法合并长度相似的单位
    - 较大的分配用树高效搜索空间
    - 非常大的分配转到 mmap()

### 4.2 内存释放
![内存释放次序](/images/linux_pf/free_memory.png)

内存过低时，系统会按照上面的高到低的次序释放内存:
1. 空闲链表: 未使用的页列表，能立即用于分配。通常每个 NUMA 的内存有一个
2. 回收: 内核释放可以轻易释放的内存
3. 换页: 对于 Linux 可以配置一个交换倾向的可调参数，范围为 0-100，默认值为 40。
    - 值越高: 倾向于"换页"来释放内存，此处的换页指匿名换页
    - 值越低: 倾向于收回页缓存，即文件系统换页
    - 这就通过在保留热文件系统缓存的同时，换出冷应用程序的内存来提高系统的吞吐量
4. OOM: 搜索并杀死可牺牲的进程来释放内存。Linux 采用 select_band_process() 搜索后用 omm_kill_process() 杀死进程 

#### 空闲链表
![内存释放次序](/images/linux_pf/free_list_memory.png)

类UNIX系统使用空闲链表和页面换出守护进程来管理内存，如上图所示:
1. 回收的内存添加到空闲链表表头以便将来分配
2. 通过页面换出守护进程释放的内存被加到表尾。kswapd 释放的内存包括有价值的文件系统缓存，这些文件系统缓存在未被重用前，如有对任一页的请求，它能被取回并从空闲链表中移除

空闲链表通常由分配器消耗，如内核的 slab 分配器，以及用户空间的 libc malloc。上面的单个空闲链表是一种简化，具体实现依内核版本不同。

Linux 使用**伙伴分配器**管理页。它以2的幂的方式向不同尺寸的内存分配器提供多个空闲链表。术语伙伴指找到相邻的空闲内存页以被同时分配。

#### 回收
回收大多是从内核的**slab 分配器缓存**释放内存。这些缓存包括 slab 大小的未使用内存块，以供重用。回收将这些内存交还给系统进行分配。

#### 换页
页面换出守护进程管理利用换页释放内存。当主存中可用的空闲链表低于阀值时，kswapd就会开始页扫描。页扫描仅会按需启动，通常平衡的系统不会经常做页扫描并且仅以短期爆发方式扫描。因此如果页扫描多于几秒通常是内存压力问题的预兆。

Linux 的页面换出守护进程称作 kswapd()，如下图所示，它扫描非活动和活动内存的 LRU 页列表以释放页面。

![kswapd](/images/linux_pf/kswapd.png)

页的活动列表和非活动列表采用 LRU 方式工作，kswapd 先扫描非活动列表，然后按需扫描活动列表。扫描会遍历列表检查页面，找出可以释放的页面:
1. 如果是干净的页直接释放
2. 如果是脏页会需要先将脏页写回磁盘然后释放。
kswapd 只有在系统严重不足才会选择脏页释放，其他情况下脏页由 flush 内核线程写回磁盘。脏页的管理详见文件系统的操作系统原理部分。

kswapd 的激活基于空闲内存和两个提供滞后的阀值。如下图所示:
1. 一旦空闲内存达到最低阀值，kswapd 运行于同步模式，按需求释放内存页(内核排除在外)
2. 最低阀值通过 vm.min_free_kbytes 设置，其他阀值基于此按比例放大两倍，三倍。

![kswapd_wakeup](/images/linux_pf/kswapd_wakeup.png)

#### OOM
OOM（Out of Memory），其实是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：
1. 一个进程消耗的内存越大，oom_score 就越大
2. 一个进程运行占用的 CPU 越多，oom_score 就越小

这样，进程的 oom_score 越大，代表消耗的内存越多，也就越容易被 OOM 杀死。

可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。oom_adj 的范围是 `[-17, 15]`，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。

```bash
# 调整 sshd 进程的 oom_adj
echo -16 > /proc/$(pidof sshd)/oom_adj
```

## 5. 进程地址空间
![virtual_address](/images/linux_pf/virtual_address.png)

用户空间内存，从低到高分别是五种不同的内存段。
1. 只读段，包括代码和常量等
2. 数据段，包括全局变量等
3. 堆，包括动态分配的内存，从低地址开始向上增长，堆上的内存是匿名页
4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长，
5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB

堆和文件映射段的内存是动态分配的。比如使用 C 标准库
1. malloc(): 可以在堆动态分配内存
2. mmap(): 可以在文件映射段动态分配内存

对于大多数分配器，free()  不会将内存换给操作系统，相反会保留它们以备将来分配。这意味着对会不停增长，进程的常驻内存只会增加，并且是正常现象。

使用 mmap() 分配，使用 munmap() 释放的内存则会归还给操作系统。 

## 6. 内存监测指标
各种内存的统计信息记录在 `/proc/meminfo` 文件中。

```bash
 cat /proc/meminfo
MemTotal:        2895444 kB
MemFree:         2498868 kB
MemAvailable:    2535384 kB
Buffers:            3108 kB
Cached:           165872 kB
SwapCached:            0 kB
Active:           115656 kB
Inactive:         126632 kB
Active(anon):      73964 kB
Inactive(anon):     9412 kB
Active(file):      41692 kB
Inactive(file):   117220 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:       2097148 kB
SwapFree:        2097148 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:         73456 kB
Mapped:            36160 kB
Shmem:             10068 kB
Slab:              57888 kB
SReclaimable:      25428 kB
SUnreclaim:        32460 kB
KernelStack:        5008 kB
.....
```

其中:
1. Buffers 是内核缓冲区用到的内存
2. Cache 是内核页缓存
3. Reclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。

执行 `man proc` 我们可以看到这些指标的准确含义，有关 Buffers 和 Cached 的区别我们在文件系统一节在详述。
