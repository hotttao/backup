---
title: 1.2 Linux 性能调优概览
date: 2020-01-02
categories:
    - 运维
tags:
    - Linux性能调优
---

为了调试和追踪程序的运行过程，Linux 提供了众多的分析工具，本节我们先对它们做一个宏观概览。
<!-- more -->

## 1. 我们到底要优化什么

在我们了解接下来的各种工具之前，我们首先应该问自己，我们要追踪或者说我们要优化什么。我们都知道程序的运行会占用包括 CPU，内存，文件描述符，锁，磁盘，网络等等在内的各种操作系统资源。根据2/8定律，当其中的某一个或多个资源出现瓶颈的时候，我们需要找到程序中耗费资源最大的地方，并对其优化。

那么我们可能需要做如下这些事情:
1. 对系统资源持续进行观测以及时发现哪些资源出现了瓶颈
2. 统计各个程序(进程)，确定哪个或哪些进程占用了过多的资源
3. 分析问题进程，找出其占用过量资源的原因。

所谓追踪技术本质上就是获取**操作系统记录**中程序运行的各种信息，所以尽管工具多种多样，但本质上都是查询操作系统"数据"的工具。在了解这些工具之前，我们非常有必要先去看看操作系统都提供了哪些数据查询接口，即操作系统提供给我们的观测来源。

## 2. 观测来源
观测来源包括两个方面:
1. 观测的内容: 操作系统会记录哪些信息
2. 观测接口: 如何获取这些信息

### 2.1 观测源
#### PMU(CPU 性能计数器) 和 内核计数器
CPU的PMU计数器是大部分CPU都有的功能。它们可以用来统计比如L1 Cache失效的次数，分支预测失败的次数等。PMU可以在这些计数器的计数超过一个特定的值的时候产生一个中断，这个中断，我们可以用和时钟一样的方法，来抽样判断系统中哪个函数发生了最多的Cache失效，分支预测失效等。

除了 PMU 外，内核也维护了各种统计数据，称为计数器，包括 CPU migrations(处理器迁移次数), minor faults(soft page faults), major faults(hard page faults) 等等。

我们把诸如 Cache 失效等硬件相关的事件称为 **Hardware event**，把诸如 minor faults 软件相关的事件称为 **Software Events**。PMU 和内核维护的计数器，通过 /proc 和 /sys 虚拟文件系统对外提供的。

#### 和延时核算
如果开启了Linux 的CONFIG_TASK_DELAY_ACCT 选项，Linux 会跟踪每个任务的延时包括:
1. 调度器延时: 等待 CPU 的延时
2. 块 I/O: 等待块 I/O 的延时
3. 交换: 等待换页的延时
4. 内存回收: 等待内存回收的延时

用户空间的工具通过 taskstats 可以读取这些统计数据，部分统计数据也会通过 /proc 对外提供。

#### 静态探针
静态探针 tracepoints 又称为事件，是散落在内核源代码中的一些 hook，开启后，它们便可以在特定的代码被运行到时被触发。可以用来跟踪特定的事件。

如果你看过内核源码，经常会看到下面这种 trace_开头的函数调用：
```c
if (likely(prev != next)) {
                rq->nr_switches++;
                rq->curr = next;
                ++*switch_count;

                trace_sched_switch(preempt, prev, next);  # trace_ 开头的函数调用
                rq = context_switch(rq, prev, next, cookie); /* unlocks the rq */
        } else {
                lockdep_unpin_lock(&rq->lock, cookie);
                raw_spin_unlock_irq(&rq->lock);
        }
```

trace_sched_switch 就是一个事件，程序执行到这个地方就会把这个点（就是一个整数，而不是函数名），加上后面的三个参数（preempt, prev, next)都写到缓冲区中。ftrace 可以读取并保存这些信息，perf 可以在事件被触发时收到通知，dtrace 和 systemtap 可以在事件触发时执行指定的 "action"。


### 1.4 动态探针
![probes](/images/linux_pf/linux-probes.png)

kprobes 和 uprobes 机制就是我们所说的动态探针。它们可以在指定的探测点(比如函数的某行, 函数的入口地址和出口地址, 或者内核的指定地址处)插入一组处理程序。

静态探针是在编译之前就已经存在代码中的。动态探针是在编译之后软件运行时才加入的，本质上是**内核地址空间的现场修改(live patching)**，所采用的的技术会因处理器类型的不同而有所不同。这也是静态探针和动态探针的区别所在。

kprobes 主要用于调试内核，uprobes 类似 kprobes, 不过主要用户空间的追踪调试。

总结一下，上面我们提到了四个主要的信息来源:
1. Hardware event
2. Software Events
3. transpoint 静态探针
4. kprobes/uprobes 提供查看内核调用栈和用户栈的动态探针

这四个信息来源就是各种 Linux 性能分析工具主要的信息来源。

### 2.2 观测接口
#### /proc 和 /sys
/proc 是一个提供内核统计信息的文件系统接口。将内核和进程的统计数据用目录树的形式暴露给用户空间。
/sys 最初设计用于提供设备驱动的统计信息，不过现在已经扩展到了提供所有信息的统计。/sys 同时也是调整内核参数的入口。

基本上所有的 PMU 和内核计数器都是通过 /proc 和 /sys 对外输出

#### 动态收集
静态和动态探针的信息是动态产生的，不同的分析工具会有不同的收集和保存这些信息的方式，我们会在讲解不同分析工具时一一讲解。

## 3. 观测工具
按照使用的观测源的不同，我们可以将调优工具分为以下三种:
1. 计数器类
2. 跟踪
3. 剖析

### 3.1 计数器类
计数器类工具读取并展示内核和进程各种统计信息，包括 top，vmstat，mpstat，iostat 等绝大多数我们常用的系统命令。它们的使用可以认为是无成本，因为计数器由内核维护的。

### 3.2 跟踪
跟踪指的是跟踪每一个事件的详细数据，相关的工具包括: 
1. tcpdump: 网络报跟踪
2. blktrace: 块 I/O 跟踪
3. execsnoop: 跟踪新进程(位于后面要讲的高级工具中)

跟踪捕获数据会有 CPU 开销，还需要存储空间存放数据，会拖慢跟踪对象，因此在使用时需要注意工具自身对观测对象的影响。

### 3.3 剖析
剖析通过对目标收集采样或快照来归纳目标特征。跟踪是查看事件的详细数据，剖析可以理解为对事件的统计，以了解系统和程序当前运行的全貌。

各种静态和动态追踪技术是完成跟踪和剖析的主要工具。也是我们接下来要介绍的难点内容。

## 4. 静态和动态追踪技术
每一个追踪技术都要解决:
1. 以什么方式获取信息 -- 原理
3. 能在什么位置，系统级别还是进程级别去分析问题

这两个方面也是接下来我们讲解各个追踪技术的切入点。下面是一个追踪技术的不完全列表，接下来我们会一一简单介绍它们。

|工具|使用的 event|特点|
|:---|:---|:---|
|ftrace|静态探针<br>内核的动态探针|1.总体跟踪法，统计了一个事件到下一个事件所有的时间长度<br>2.可以知道整个系统运行在时间轴上的分布<br>3.方法很准确，但跟踪成本很高，只能跟踪内核程序|
|perf|全部的 event|1.抽样跟踪，需要注意抽样导致的结果是否准确<br>2.直接跟踪到整个系统的所有程序<br>perf通常是我们分析系统性能的第一步|
|Dtrace|Solaris 的动态追踪技术||
|Systemtap|Linux 的动态追踪技术||
|eBPF|||
|LTTng|||
|ktap|||

## 参考
- [Linux 系统动态追踪技术介绍](https://blog.arstercz.com/introduction_to_linux_dynamic_tracing/)
- [在Linux下做性能分析2：ftrace](https://zhuanlan.zhihu.com/p/22130013)