---
title: 10 异步编程
date: 2020-08-25
categories:
    - 前端
tags:
	- ES6
---

async 与 await 

<!-- more -->

## 1. ES6 异步编程概述
JavaScript引擎是基于单线程（Single-threaded）事件循环的概念构建的，同一时刻只允许一个代码块在执行。JavaScript引擎同一时刻只能执行一个代码块，所以需要跟踪即将运行的代码，那些代码被放在一个**任务队列（job queue）**中，每当一段代码准备执行时，都会被添加到任务队列。每当JavaScript引擎中的一段代码结束执行，**事件循环（eventloop）**会执行队列中的下一个任务，它是JavaScript引擎中的一段程序，**负责监控代码执行并管理任务队列**。请记住，队列中的任务会从第一个一直执行到最后一个。为了在实现循环中实现异步编程，JavaScript 提供了如下异步编程模型:
1. 响应用户操作的时间
2. 回调函数
3. Promise
4. async/awit 定义的协程

### 1.1 事件
用户点击按钮或按下键盘上的按键会触发类似onclick这样的事件，它会向任务队列添加一个新任务来响应用户的操作。直到事件触发时才执行事件处理程序。

事件模型适用于处理简单的交互，但不适合组合复杂的异步逻辑。

### 1.2 回调函数
回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者的区别是回调模式中被调用的函数是作为参数传入的。与事件相比回调模式比事件模型更灵活，通过回调模式链接多个调用更容易，但是很容易就陷入所谓的"回调地狱"中。

同事件一样，回调函数无法组合复杂的组合逻辑，例如，并行执行两个异步操作，当两个操作都结束时通知你；或者同时进行两个异步操作，只取优先完成的操作结果。

### 1.3 Promise
Promise相当于异步操作结果的占位符，类似于其他语言中类似Future和Deferred，用于表示操作的未来结果。Promise 具有生命周期:
1. 先是处于进行中（pending）的状态，此时操作尚未完成
2. 操作结束后，Promise可能会进入到以下两个状态中的其中一个：
    - Fulfilled　Promise异步操作成功完成
    - Rejected　由于程序错误或一些其他原因，Promise异步操作未能成功完成

内部属性 `[[PromiseState]]` 被用来表示Promise的3种状态："pending"、"fulfilled"及"rejected。基于成功或失败的状态，Promise 可以像事件和回调函数一样指定稍后执行的代码，可以链式地编写 Promise。接下来我们会详细介绍 Promise 提供的异步编程接口。需要说明的是 Promise 不暴露 `[[PromiseState]]` 属性，我们无法获取此属性值，但是 JavaScript 提供了其他方法让我们捕获 Promise 状态的变化，接下来我们会详细介绍。

### 1.4 协程
async/awit 定义的协程组合了生成器和 Promise，实现了以同步方式编写异步代码，要想明白其实现机制，我们需要按次序理解一下问题:
1. 如何使用生成器实现一个异步任务执行器
2. 如何让异步任务函数返回一个 Promise(表示未来操作的结果)
3. 如何让 Promise 与第一步定义的异步任务执行器结合，更好的将异步代码同步化。

在同步代码中，代码按照执行次序一行行执行，因为是同步，我们总是可以得到上一步执行的结果。在协程中，我们通过一个表示未来操作执行结果的 Promise 对象来得到上一行代码的执行结果(假设是异步操作)，让异步代码同步化。

## 2. Promise 
前面我们已经说过了，Promise 表示一个异步操作的结果，通过捕获 Promise 状态的变化我们可以获取异步操作的结果，基于结果我们可以定义接下来的操作。为此 Promise 提供了如下方法:
1. then()
2. catch()

### 2.1 Promise 定义的方法
promise.then(fulfilled_function, reject_function):
- 作用: 定义 Promise 状态改变时(异步操作完成后)，执行的操作
- 参数: 两个参数都是可选的
    - fulfilled_function: 
        - 当Promise的状态变为fulfilled时要调用的函数
        - 异步操作的返回值会传递给此函数
    - reject_function:
        - Promise的状态变为rejected时要调用的函数
        - 所有与失败状态相关的附加数据都会传递给这个拒绝函数
- 说明:
    - 如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象
    - 分离的 fulfilled_function，reject_function 可以确切提供异步操作成功还是失败的处理语义，如果使用事件，在遇到错误时不会主动触发；如果使用回调函数，则必须要记得每次都检查错误参数
    - **如果不给Promise添加拒绝处理程序，那所有失败就自动被忽略了，所以一定要添加拒绝处理程序**
    - 每次调用then()方法或catch()方法都会创建一个新任务，当Promise 表示的异步任务执行完成时。这些任务最终都会被加入到一个为Promise量身定制的独立队列中，即便一个Promise处于已处理状态，在这之后添加到任务队列中的处理程序仍将执行
    - 如果执行器内部抛出一个错误，则Promise的拒绝处理程序就会被调用，每个执行器中都隐含一个try-catch块，所以错误会被捕获并传入拒绝处理程序

promise.catch(reject_function):
- 作用: 相当于只传入拒绝处理程序的then()方法
- 说明: **catch 提供了用于捕获异步操作错误的确切语义**

```js
// readFile 的实现参见 创建未完成的Promise 中示例
let promise = readFile("test.txt");

promise.then(function(contents){
    console.log(contents);
}, function(err){
    onsole.log(err.message);
})

promise.catch(function(err){
    onsole.log(err.message);
})
```

### 2.2 捕获已拒绝 Promise 的钩子
关Promise的其中一个最具争议的问题是，如果在没有拒绝处理程序的情况下拒绝一个Promise，那么不会提示失败信息，这是JavaScript语言中唯一一处没有强制报错的地方。Promise的特性决定了很难检测一个Promise是否被处理过，为此 Node.js 和 浏览器提供了捕获已拒绝 Promise 的钩子，虽然它们还不是 ES6 的标准。

当Promise 被拒绝时，浏览器会在 window 对象上触发两个事件:
1. unhandledrejection　在一个事件循环中，当Promise被拒绝，并且没有提供拒绝处理程序时被调用
2. rejectionhandled　在一个事件循环后，当Promise被拒绝，并且没有提供拒绝处理程序时被调用

这两个事件的事件处理程序会接受一个有以下属性的事件对象作为参数:
1. type: 事件名称（"unhandledrejection"或"rejectionhandled"）
2. promise: 被拒绝的Promise对象
3. reason: 来自Promise的拒绝值

### 2.3 创建未完成的Promise
所谓创建未完成的Promise，就是如何用 Promise 包装一个异步任务。这里的等价含义是如何将回调函数转换为Promise。

用Promise构造函数可以创建新的 Promise，其只接受一个参数：包含初始化Promise代码的执行器（executor）函数。执行器接受两个参数，分别是
1. resolve()函数，执行器成功完成时调用resolve()函数，resolve 函数接收的参数将被 Promise 传递给 fulfilled_function
2. reject()函数，执行器失败时则调用reject()函数，reject 函数接收的参数将被 Promise 传递给 reject_function

下面这个示例是在 Node.js 中用 Promise 实现的Promise 版 readFile()函数：

```js
// NodeJs 示例
let fs = require("fs");

function readFile(filename){
    return new Promise(resolve, reject){
        fs.readFile(filename, {"encoding": "utf8"}, function(err, contents){
            // 检查错误
            if (err){
                reject(err);
                return;
            }

            // 执行成功
            resolve(contents);
        });
    }
}

let promise = readFile("test.txt");

promise.then(function(contents){
    console.log(contents);
}, function(err){
    onsole.log(err.message);
})

```

当上面的 readFile()方法被调用时:
1. 执行器会立刻执行，fs.readFile 异步读取文件的函数会立即执行
2. 然后执行后续的 promise.then
3. 在执行器中，无论是调用resolve()还是reject()，都会向任务队列中添加一个任务来解决这个Promise(更新 Promise 状态)。类似于 setTimeout()或setInterval()函数向任务队列中添加一个新任务，并明确指定将**任务延后执行**
4. 当异步文件读取完成时，会调用resolve()/reject()触发一个异步操作，传入then()和catch()方法的函数会被添加到任务队列中并异步执行

因此整个代码的执行过程为
1. 当前事件循环: 
    1. 执行执行器
    2. 执行promise.then
2. 读文件完成所在的事件循环:
    - 调用 resolve()，想任务队列添加解决 Promise 的任务
3. 下一个事件循环:
    - 执行解决 Promise 的任务，真正调用 resolve() 将定义在 then()方法中的函数到任务队列
4. 下一事件循环:
    - 执行then()方法的函数

之所以**调用resolve()还是reject()，都会向任务队列中添加一个任务来解决这个Promise**，是为了保证 resolve()/reject() 的执行总是在 promise.then 方法之后执行，即使执行器执行的不是异步代码也是如此。这样才能保证完成处理程序和拒绝处理程序总是在执行器完成后被添加到任务队列的末尾。

### 2.4 创建已完成的 Promise
创建已处理的Promise表示你想用Promise来表示一个已知值，相对于编排一个只是简单地给resolve()函数传值的任务，更好的办法是使用如下方法:
1. Promise.resolve
2. Promise.reject

Promise.resolve(value)
- 作用: 接受一个参数并返回一个完成态的Promise
- 说明: 不会有任务编排的过程，而且需要向Promise添加一至多个完成处理程序来获取值

Promise.reject()
- 作用: 创建已拒绝的 Promise

Promise.resolve()和Promise.reject()都有如下特点:
1. 传入一个Promise，那么这个Promise会被直接返回
2. 都可以接受非Promise的Thenable对象作为参数，此时这些方法会创建一个新的Promise，并在then()函数中被调用

在下面这个示例中:
2. Promise.resolve()调用的是thenable.then()
3. 由于 then()方法内部调用了resolve(42)，因此thenable 被转换为一个已完成的 Promise p1，如果调用 reject(43) 则返回一个已拒绝的 Promise，当然也可以执行异步函数，根据异步函数结果调用 resolve 或者 reject
3. p1从Thenable对象接受传入的值（也就是42），p1的完成处理程序的形参value将被赋值 42

```js
let thenable = {
    then: function(resolve, reject) {
        resolve(42);
    }
}

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
    console.log(value);
})
```

有了Promise.resolve()方法和Promise.reject()方法，我们可以更轻松地处理非Promise的Thenable对象。

### 2.5 Promise 提供的链式调用

### 2.6 Promise 提供的任务组合