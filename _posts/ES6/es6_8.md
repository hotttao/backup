---
title: 8 新类型 Set 与 Map 与增强的数组
date: 2020-08-23
categories:
    - 前端
tags:
	- ES6
---

ES6 的新类型

<!-- more -->

## 1. 为什么需要新的 Set 和 Map
在ECMAScript 5中，开发者们用对象属性来模拟这 Set 和 Map:

```js
// 1. 模拟 set
var set = Object.create(null);
set.foo = true;

if set.foo(){

}

// 2. 模拟 map
var map  = Object.create(null);
map.foo = "bar"
```

变量set 和 map 是一个原型为null的对象，不继承任何属性。不过这种解决方案存在下面严重的问题:
1. 因为对象属性只能是字符串，所以
    - `map["5"]`和`map[5]`引用的其实是同一个属性，无法区分数字键和字符串的键
    - 具有相同字符串表示的对象，用作键时也会导致冲突
3. 对象支持 in 运算来判断属性是否存在，但是，in运算符也会检索对象的原型，只有当对象原型为null时使用这个方法才比较稳妥

基于这些 ES6 引入了 Set 和 Map。

## 2. Set
Set类型是一种有序列表，其中含有一些相互独立的非重复值(引擎内部使用 Object.is() 方法检测两个值是否一致)，下面是其基本用法:

```js
// 1. 初始化
let setFromArray  = new Set([1, 2, 2]);
let set = new Set();

// 2. 添加删除元素
set.add(5);
set.add("5");
set.delete("5");
set.clear();  // 清空 set

//3. 检查元素是否存在
set.has(5);

// 4. 获取 set 长度
set.size;

// 5. set 转数组
array = [...setFromArray]
```

Set构造函数可以接受所有可迭代对象作为参数，数组、Set集合、Map集合都是可迭代的

### 2.1 set.forEach 方法
ES6 为集合添加了跟数组一样的 forEach 方法:

set_obj.forEach(function(value, value, set_obj), scope_obj):
- 作用: 对 set 中每个元素调用 forEach 中的回调函数
- 参数: 
    - 接受一个函数和可选的作用域对象，作用域对象将绑定到回调函数中
    - 回调函数: 接受三个参数，(元素值，元素值，被遍历的Set集合本身)
- 说明: Set集合中的每个元素也按照键名和值的形式储存，从而才能保证在所有 forEach() 方法的回调函数中前两个参数值具有相同含义

```js
// 5. forEach 
let setFromArray  = new Set([1, 2, 2]);
let processor = {
    output(value){
        console.log(value);
    },

    process(dataSet){
        // 1. 可以进行 this 绑定
        dataSet.forEach(function(value){
            this.output(value)
        }, this)

        // 2. 也可以使用箭头函数
        dataSet.forEach(value => this.output(value));
    }
}

processor.process(setFromArray)
```

## 3. Weak Set 集合
Weak Set集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。其支持一下操作:

```js

let set = new WeakSet();
let key = {}, k2 = {};
let set = new WeakSet([key, k2]);

set.add(key);
set.has(key);

key = null;
set.has(key);

set.delete(k2);
```

与 Set 相比，WeakSet:
1. WeakSet构造函数不接受任何原始值，向初始化、add()、has()和delete() 传入非对象参数都会导致程序报错
2. Weak Set集合不暴露任何迭代器（例如keys()和values()方法）
3. Weak Set集合不支持forEach()方法。
4.  Weak Set集合不支持size属性

## 4. Map
ES6 Map类型是一种储存着许多键值对的**有序列表**，其中的键名和对应的值支持所有的数据类型。键名的等价性判断通过调用Object.is()方法进行判断。下面是其基本用法:

```js
// 1. 初始化
let map = new Map();
let key = {};

// 2. 添加删除元素
map.set(5, "number5");
map.get(5);
map.set(key, "key");
map.delete(key);
map.clear(); // 清空 map

//3. 检查元素是否存在
map.has(5);

// 4. 获取 map 长度
set.size;
```

可以向Map构造函数传入`[[key, value]...]` 的数组来初始化一个Map集合。Map 同样支持 forEach() 方法 `map_obj.forEach(function(value, key, map_obj), scope_obj)`,与 set 不同的是，其回调函数都接受3个参数：(值，值对应的键名，Map集合本身)。遍历过程中，会按照键值对插入Map集合的顺序将相应信息传入forEach()方法的回调函数。

## 5. Weak Map 集合
ECMAScript 6中的Weak Map类型是一种存储着许多键值对的**无序列表**，列表的键名必须是非null类型的对象，键名对应的值则可以是任意类型，其键保存的对象的弱引用。Weak Map集合最大的用途是保存Web页面中的DOM元素。

```js
let map = new WeakMap();
let key = {}, k2 = {};
let map = new WeakSet([[key, 1],[k2, 2]]);

map.set(key, 10);
map.has(key);
map.get(key);
map.delete(key);
```

### 5.1 Weak Map 的应用
Weak Map 的另一个典型用途是构建对象的私有属性:

```js
let Person = (function(){
    let pri = new WeakMap();

    function Person(name){
        pri.set(this, {"name": name})
    }

    Person.prototype.getName = function(){
        return pri.get(this).name;
    }
    return Person;
})();

```

条目会被添加到Weak Map集合中，条目的键是this，值是对象包含的私有信息。当对象实例被销毁，相关信息也会被销毁，从而保证了信息的私有性。

### 5.2 WeakMap 与 Map 的区别
相对Map集合而言，Weak Map集合
1. 对用户的可见度更低
2. 不支持通过forEach()方法、size属性及clear()方法来管理集合中的元素 
3. 如果你只想使用非对象作为键名，那么普通的Map集合是你唯一的选择。