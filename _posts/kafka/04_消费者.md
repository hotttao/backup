---
title: 1.4 消费者客户端
date: 2020-04-03
categories:
    - 存储
tags:
    - Kafka
---
Kafka 的生产者客户端

<!-- more -->
## 1. 消费者客户端概述
接下来我们将介绍 kafka 消费者客户端，内容包括:
1. 消费者与消费者组
2. 消费者客户端开发，包括
    - 主题订阅
    - 反序列化
    - 消费者拦截器
    - 消息消费和消息确认
    - 再均衡

与生产者客户端一样，消费者客户端也分成两个版本，我们只介绍新版本，并依旧使用 Python 语言来编写示例代码。

## 2. 消费者与消费者组
kafka 通过消费者组（Consumer Group）来同时实现消息传递的两种模式: 负载均衡和扇出。当消息发布到主题后，只会被投递给订阅它的**每个消费组**中的**一个消费者**。消费者组中的每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。通过消费者客户端参数**partition.assignment.strategy**可以来设置消费者与订阅主题之间的分区分配策略，分区分配策略的细节我们之后在深入学习 kafka 相关原理时会详细讲解。

消费者组是一个逻辑上的概念，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，通过消费者客户端参数**group.id**来配置，默认值为空字符串。

## 2. 消费者客户端开发
一个正常的消费逻辑需要具备以下几个步骤：
1. 配置消费者客户端参数及创建相应的消费者实例。
2. 订阅主题
3. 拉取消息并消费
4. 消息确认，即提交消费位移
5. 关闭消费者实例

```python
from confluent_kafka import Consumer

conf = {'bootstrap.servers': "host1:9092,host2:9092",
        'group.id': "foo",
        'auto.offset.reset': 'smallest'}

consumer = Consumer(conf)

running = True

def basic_consume_loop(consumer, topics):
    try:
        # 订阅主题，一个或多个
        consumer.subscribe(topics)

        while running:
            msg = consumer.poll(timeout=1.0)
            if msg is None: continue

            if msg.error():
                if msg.error().code() == KafkaError._PARTITION_EOF:
                    # End of partition event
                    sys.stderr.write('%% %s [%d] reached end at offset %d\n' %
                                     (msg.topic(), msg.partition(), msg.offset()))
                elif msg.error():
                    raise KafkaException(msg.error())
            else:
                msg_process(msg)
    finally:
        # Close down consumer to commit final offsets.
        consumer.close()

def shutdown():
    running = False
```

### 2.1 必要的连接参数
Kafka消费者客户端有四个参数是必填的
1. bootstrap.servers：
    - 作用: 该参数用来指定生产者客户端连接Kafka集群所需的broker地址清单
    - 默认: 默认值为 ""
    - 格式: 具体的内容格式为host1：port1，host2：port2
    - 说明: 不需要指定所有的broker地址，因为消费者会从给定的broker里查找到其他broker的信息
2. group.id:
    - 作用: 消费者隶属的消费者组名称
    - 默认: 默认值为 ""，设置为空，则会报出异常
    - 说明: 需要设置成具有一定的业务意义的名称
3. key.deserializer: 指定键的反序列化器
4. value.deserializer: 指定值的反序列化器
5. client.id:
    - 作用: 设定KafkaConsumer对应的客户端id
    - 默认: 默认值为 ""，非必须参数
    - 说明: 客户端不设置，则KafkaConsumer会自动生成一个非空字符串，内容形式如“consumer-1”

Python kafka 客户端实现与 Java 略有不同，自定义反序列化器是通过Producer子类实现的，还有一些使用特殊序列化协议的序列化/反序列化器。

### 2.2 订阅主题和分区
`consumer.subscribe(topics[, on_assign=None][, on_revoke=None])`
- 作用: 主题订阅
- topics: 
    - 指定订阅的主题，一个或多个
    - 如果前后两次订阅了不同的主题，以最后一次的为准
    - 正则表达式的主题名称需要以 "^" 开头
    - 如果在订阅主题之后，又有人创建了新的主题，并且与正则表达式的主题匹配，消费者可以消费到新添加的主题中的消息
    - 在Kafka 和其他系统之间进行数据复制时，这种正则表达式的方式就显得很常见
- on_assign:
    - 可调用函数，用于在 partition re-assignment 成功后提供自定义偏移量
- on_revoke: 
    - 可调用函数，用于在再均衡开始前，提供对偏移量的处理，并提交至服务端

```Python
# 1. 正则表达式的主题名称
consumer.subscribe(["^my_topic.*", "^another[0-9]-?[a-z]+$", "not_a_regex"])
```

`consumer.assign(partitions)`
- 作用: 直接订阅主题的分区
- partitions: TopicPartition 的 List 指定需要订阅的分区集合

`TopicPartition(topic [, partition][, offset])`
- 作用: 保存主题单个分区的类
- topic: 所属主题
- partition: 分区ID
- offset: 初始分区偏移量

`consumer.assignment()`
- 作用: 返回主题的分区元数据，类型为 TopicPartition 的 List

`consumer.unsubscribe()`
- 作用: 删除当前订阅

subscribe(topics)、正则表达式订阅的方式subscribe(Pattern)和指定分区的订阅方式 assign(TopicPartition)分表代表了三种不同的订阅状态：AUTO_TOPICS、AUTO_PATTERN和USER_ASSIGNED。这三种状态是互斥的，在一个消费者中只能使用其中的一种，否则会报错。

通过 subscribe（）方法订阅主题具有消费者自动再均衡的功能，在多个消费者的情况下可以根据**分区分配策略**来自动分配各个**消费者与分区的关系**。当消费组内的消费者增加或减少时，分区分配关系会自动调整，以实现消费负载均衡及故障自动转移。而通过assign()方法订阅分区时，是不具备消费者自动均衡的功能的。

### 2.3 反序列化

### 2.4 消费者拦截器

## 3. 消息消费

## 4. 重要的消费者参数
2. group.id:
    - 作用:
    - 默认:
    - 说明: