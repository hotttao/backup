---
title: 5. redis 拓展篇
date: 2020-05-05
categories:
    - 存储
tags:
    - Kafka
---

Redis 拓展应用

<!-- more -->

## 1. 集群篇概述
拓展篇我们将介绍基于 Redis 的扩展应用
- Stream 消息流
- Info 指令，Redis 的监测
- 分布式锁的实现
- Redis 的惰性删除
- Redis 的加密


## 2. 消息队列
通过 List 实现的消息队列支持只有一组消费，没有 ack 保证，不支持多播，消息无法持久化。为了解决这些问题，Redis 陆续引入了不同的消息队列实现。本节我们就来介绍 Redis 中队列实现的多种方式，包括:
1. List 实现的消息队列
2. zset 实现的延时队列
3. pubsub fabudingyue
4. Stream

### 2.1 Redis List 消息队列
通过 list，rpush，lpush，rpop，lpop 实现。rpop，lpop 在 list 为空时造成忙等待。blpop，brpop 是对应的阻塞读版本，在list 为空时就会阻塞等待。

需要注意的被 block 住的空闲连接可能会被服务器端断开，因此使用 brpop，blpop 时需要捕获连接异常并重试。


### 2.2 pubsub(发布/订阅)
Redis 单独使用了一个模块来支持消息多播，叫做 PubSub。
```bash
# 发布
client = redis.StrictRedis()
client.publish("code", "python")

# 订阅-非阻塞
client = redis.StrictRedis()
p = client.pubsub()
p.subscribe("code")
while True:
    msg = p.get_message() # 非阻塞的

# 订阅-阻塞
client = redis.StrictRedis()
p = client.pubsub()
p.subscribe("code")
for msg in p.listen():  # 阻塞监听
    print(msg)
```

Redis 支持对主题名称使用模糊匹配来订阅多个主题。
```bash
> psubscribe code*
```

#### pubsub 的缺点
pubsub 的消息是不会持久化的:
1. 如果消息没有对应的消费者，那么消息会被直接丢弃
2. 如果有多个消费者，其中一个消费者中间迭机掉线，等到它从新上线之间的所有消息，对于这个消费者就彻底丢失了

所以 Redis 的 pubsub 没有太多合适的适用场景。

## 2.3 Stream
#### Stream 结构
Stream支持多播的可持久化消息队列。其结构如下图所示:

![Stream数据结构](/images/redis/redis_stream.png)


Stream:
1. 是一个消息链表，具有唯一的名称(Redis key)，消息是持久化的
2. 每个消息都有唯一的ID
3. 每个 Stream 支持多个消费组

消费组:
3. 每个消费组会有一个游标 last_delivered_id 表示当前已经消费到哪条消息
4. 每个消费组都有一个 Stream 内唯一名称
5. 通过 xgroup create 创建消费者组，需要指定从哪个消息ID开始消费，这个ID用来初始化 last_delivered_id
6. 同一个消费组支持多个消费者

消费者:
1. 消费者之间属于竞争关系
2. 每个消费者在组内唯一
3. 消费者内部会有一个状态变量 pending_ids，记录了被客户端读取，但还没有 ack 的消息。
4. pending_ids 用来确保客户端至少消费了一次消息
5. pending_id是变量被Redis 称为 PEL

#### Stream 操作
消息的增删改查指令如下:
1. xadd: 向Stream 追加消息，提供了一个定长参数 maxlen，超过长度的老消息会被彻底删除
2. xdel: 标记删除
3. xrange: 按范围获取消息，自动过滤已经删除的消息
4. xlen: 获取Stream 消息的长度
5. del: 删除整个 Stream 消息列表中是所有消息
6. xinfo: 获取 stream 信息

```bash
# * 表示自动生成消息ID
> xadd codehole maxlen 3 * name xiaoshuo
```

消费组指令:
1. xgroup read: 创建消费组
2. xreadgroup: 
    - 消费者组的组内消费
    - 其实消息ID 一般设置为 0-0，表示读取所有 PEL 消息以及自 last_delivered_id 之后的新消息
3. xack: 确认消息

```bash
>  xgroup create codehole cg1 0-0
> xreadgroup GROUP cg2 c1 count 1 stream codehole
> xack codehole cg1 ID1 ID2
```

#### 独立消费者
使用 xread 可以定义独立消费者，在没有消费组的情况下直接读取Stream 中的消息。独立消费者将Stream 当做消息队列 list 来使用，设置可以在没有消息时阻塞等待。

客户端使用 xread 顺序消费是一定要保存 xread 返回的消息ID，下次调用时需要将此 ID 当做 xread 参数传入以便继续消费后面的消息。

```bash
# 从头部读取消息
> xread count 1 stream code 0-0 
# 从尾部读取消息，只接受新消息
> xread count 1 stream code $
# 阻塞读取
> xread block 0 count 1 stream code $ 
```

#### 分区
Redis 不支持消息分区，只能在客户端通过生产和消费多个 Stream 来手动分区。

## 2. Info 指令
在诊断 Redis 性能问题之前，需要了解 Redis 的运行状态，通过强大的 info 指令，可以查看 Redis 内部一系列的运行参数。info 的输出分为 9 大块:
1. Server: 服务器运行的环境参数
2. Clients: 客户端相关信息
3. Memory: 服务器运行内存统计数据
4. Persistence: 持久化信息
5. Stats: 通用统计数据
6. Replication: 主从复制相关信息
7. CPU: CPU 使用情况
8. Cluster: 集群信息
9. KeySpace: 键值对统计数量信息

info 可一次获取所有信息，也可分块获取。

## 3. 分布式锁
### 3.1 锁的使用
1. redis 通过使用 setnx 指令成功创建一个键表示抢占锁。
2. 通过 del 删除键表示释放锁
3. 为了避免应用程序奔溃导致键不能被删除导致的死锁，需要使用 expire 为键设置过期时间
4. 但是 setnx 与 expire 之间仍然有可能发生奔溃，redis 引入了扩展的 set 命令，使得 setnx 和 expire 在一个指令中执行

```bash
# 1. 有问题的锁
> set lock:codehol true  # : 仅表示普通字符
> expire lock:codehole 5
> del lock:codehole

# 2. 正确的锁
> set lock:codehole true ex 5 nx
> del lock:codehole
```

#### 超时问题
Redis 的分布式锁存在两个问题:
1. 一个线程占有的锁，可能被另一线程释放。一个安全的做法是使用类似乐观锁的方式，将value 设置成随机数，在删除 key 时判断 value 是否一致，但是 匹配 value 和删除 key 不是一个原子操作，依然存在问题。可使用 lua 脚本实现此功能，因为 lua 脚本可以保证连续多个指令的原子性执行。
2. expire 的超时时长问题: 如果在加锁和释放锁之间的逻辑执行的太长，超过了 expire 的超时时长，就会出现两个线程并发修改临界区的情况

#### 可重入锁
Redis 的分布式锁显然不是可重入锁。实现可重入锁需要在编程语言内通过 Threadlocal  存储当前持有锁的计数来实现。

#### 锁冲突的处理
客户端加锁失败，一般有以下 3 中策略来处理:
1. 直接抛出异常: 比较适合客户端直接发送的请求
2. sleep: 阻塞并重试
3. 延时队列: 将当前冲突的请求放到消息队列中，稍后在重试，比较适合异步消息处理。


### 3.2 Redis 中的乐观锁
Redis 提供的 watch 机制就是一种乐观锁，使用方式如下:

```bash
> watch books
> multi
> incr books
> exec
```

1. watch 会在事务开始之前监测一个或多个关键变量
2. 事务执行时，即开始顺序执行事务队列中的命令时，Redis 会先检查关键变量自 watch 以来是否被修改，包括当前事务所在的客户端
3. 如果关键变量被修改，exec 指令返回 NULL，表示事务执行失败
4. 否则执行事务

注意 watch 之后即便是当前事务所在的客户端对关键变量进行修改，事务也会报错，同时Redis 禁止在 multi 和 exec 之间执行 watch 指令。

### 3.3 分布式锁
在集群环境下，主从切换可能会导致锁信息的丢失从而出现问题。为了解决这个问题，Redis 使用了 Redlock 算法。

为了使用 Redlock，需要提供多个 Redis 实例，这些实例之间相互独立，没有主从关系。加锁时客户端向过半节点发送set(key, value, nx=True, err=XXX)，只要过半节点 set 成功，加锁成功。释放锁是向所有节点发送 del 指令，不过Redlock 还需要考虑出错重试，时钟漂移等很多细节问题。


## 4. 惰性删除

## 5. Redis 加密
Redis 中的安全措施

### 5.1 指令安全
Redis 在配置文件中 rename-command 指令，用于将某些危险的指令修改成特别的名称，比如在配置文件的 security 块增加:

```bash
rename-command keys abckeysabc
rename-command flushall "" # 禁用指令
```

### 5.2 端口安全

### 5.3 增加密码访问限制

### 5.4 Lua 脚本安全
必须禁止Lua脚本由用户输入(UGC)生成

### 5.5 使用 spiped SSL 代理
Redis 不支持 SSL 连接，可以用 SSL 代理，官方推荐 spiped。