---
title: 5. x86 实模式(一)
date: 2021-07-05
categories:
    - Go
tags:
	- x86 汇编
---

CPU 实模式(二)
<!-- more -->

## 1. 内容概述
前面，我们通过一个在屏幕显示字符的例子，介绍了基本的汇编指令以及内存分段机制。我们把主引导扇区改造成一个程序加载器，或者说是一个加载程序，它的功能是加载用户程序，并执行该程序（将处理器的控制权交给该程序）。接下来我们将依次讲解以下内容:
1. 栈
2. 用户程序加载器
2. 过程调用
3. 中断


## 2. 栈
栈是什么就不多说了，栈有栈顶用栈指针寄存器SP （Stack Pointer）表示，SP 指向了数据从哪里出栈。。定义栈需要两个连续的步骤，即初始化段寄存器SS 和栈指针SP 的内容。

到目前为止，我们已经定义了3 个段，如下图所示，
1. 假定数据段的长度是64KB（实际上它的长度无关紧要）， 占据了物理地址0x07C00 ～ 0x17BFF ， 对应的逻辑地址范围是0x07C0:0x0000 ～ 0x07C0:0xFFFF；
2. 代码段和栈段是同一个段，占据着物理地址0x00000～0x0FFFF，对应的逻辑地址范围是0x0000:0x0000～0x0000:0xFFFF。

![内存代码段划分](/images/assembly/memery_stack.png)

### 2.1 入栈和出栈
```assembley
     ; ax 保存着被除数
     @d:
         inc cx     ;记录当前是多少位，后面用于展示
         xor dx,dx
         div bx
         or dl,0x30 ;相当于 “加上”0x30，得到 ascii 码
         push dx    ;入栈
         cmp ax,0   ;
         jne @d     ; 余数不为 0 时跳转
```

push dx 表示将 dx 寄存中的值压入栈中。处理器在执行push 指令时，首先将栈指针寄存器 SP 的内容减去操作数的字长（以字节为单位的长度，在 16 位处理器上是2），然后，把要压入栈的数据存放到逻辑地址SS:SP 所指向的内存位置。就8086 处理器来说，因为压入栈的内容必须是字。

很明显，不同于代码段，代码段在处理器上执行时，是由低地址端向高地址端推进的，而压栈操作则正好相反，是从高地址端向低地址端推进的。

```assembley
     
     @a:
         pop dx            ; 出栈
         mov [es:di],dl    ; 保存至显存
         inc di
         mov byte [es:di],0x07
         inc di            
         loop @a            ; cx 中记录了要出栈的次数
```

pop dx 指令的功能是将逻辑地址SS:SP 处的一个字弹出到寄存器DX 中，然后将SP 的内容加上操作数的字长（2）

# 3. 用户程序结构
一个规范的程序，应当包括代码段、数据段、附加段和栈段。NASM 编译器使用汇编指令“SECTION”或者“SEGMENT”来定义段。格式如下:

```
SECTION 段名称
SEGMENT 段名称
```

Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的，汇编语言源程序中定义的各个段，也有对齐方面的要求，具体的方式是在段定义中使用“align=”子句，用于指定某个SECTION 的汇编地址对齐方式。一个段的定义示例如下:

```
SECTION data align=16 vstart=0                     ;定义用户程序头部段 
    ....
```

其中:
1. align=16: 指定段的对其方式
2. “vstart=”: 
    - 尽管定义了段，但是引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的
    - 有“vstart=0”子句，标号的汇编地址要从它所在段的开头计算，而且从0 开始计算
    - 没有包含“vstart=0”子句，标号的汇编地址就要从整个程序开头计算

为了方便取得该段的汇编地址，NASM 编译器提供了以下的表达式，section.名称.start

## 3. 用户程序加载器
一般来说，加载器和用户程序是由不同人开发的，加载器必须了解一些必要的信息才能知道如何加载用户程序。这部分内容就跟气门前面提到的内核映像格式有关了。

这里我们要自己约定一个用户程序格式。经验表明，把这个约定的地点放在用户程序的开头，这就是用户程序头部。下面是我们接下来要使用的用户程序头部的一个示例:

```
SECTION header vstart=0                     ;定义用户程序头部段 
    program_length  dd program_end          ;程序总长度[0x00]
    ;用户程序入口点
    code_entry      dw start                ;偏移地址[0x04]
                    dd section.code_1.start ;段地址[0x06] 
    
    realloc_tbl_len dw (header_end-code_1_segment)/4
                                            ;段重定位表项个数[0x0a]
    
    ;段重定位表           
    code_1_segment  dd section.code_1.start ;[0x0c]
    code_2_segment  dd section.code_2.start ;[0x10]
    data_1_segment  dd section.data_1.start ;[0x14]
    data_2_segment  dd section.data_2.start ;[0x18]
    stack_segment   dd section.stack.start  ;[0x1c]
    
    header_end:     
```

### 3.2 加载程序（器）的工作流程
加载器要加载一个用户程序，并使之开始执行，需要决定两件事:
1. 第一，看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序
2. 第二，用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少

对于内存，我们按照如下的结构进行组织:
1. 物理地址0x0FFFF 以下，是加载器及其栈
2. 物理地址A0000 以上，是BIOS 和外围设备
3. 可用的空间就位于0x10000～9FFFF，用于装载我们的用户程序

![加载器程序内存组织](/images/assembly/memery_stack.png)

对于磁盘，我们假设，用户程序固定存放在逻辑扇区号为 100 的位置。
