---
title: 5. 用户程序加载程序
date: 2021-07-05
categories:
    - Go
tags:
	- x86 汇编
---

CPU 实模式(二)
<!-- more -->

## 1. 内容概述
前面，我们通过一个在屏幕显示字符的例子，介绍了基本的汇编指令以及内存分段机制。这一节我们把主引导扇区改造成一个程序加载器，或者说是一个加载程序，它的功能是加载用户程序，并执行该程序（将处理器的控制权交给该程序）。接下来我们将依次讲解以下内容:
1. 模拟操作系统加载应用程序的过程，演示段的重定位方法
2. 学习x86 处理器过程调用的程序执行机制
3. 以读硬盘扇区和控制屏幕光标为实例，了解x86 处理器访问外围硬件设备的方法

## 2. 用户程序结构
一个规范的程序，应当包括代码段、数据段、附加段和栈段。NASM 编译器使用汇编指令“SECTION”或者“SEGMENT”来定义段。格式如下:

```
SECTION 段名称
SEGMENT 段名称
```

Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的，汇编语言源程序中定义的各个段，也有对齐方面的要求，具体的方式是在段定义中使用“align=”子句，用于指定某个SECTION 的汇编地址对齐方式。一个段的定义示例如下:

```
SECTION data align=16 vstart=0                     ;定义用户程序头部段 
    ....
```

其中:
1. align=16: 指定段的对其方式
2. “vstart=”: 
    - 尽管定义了段，但是引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的
    - 有“vstart=0”子句，**标号的汇编地址**要从它所在段的开头计算，而且从0 开始计算
    - 没有包含“vstart=0”子句，标号的汇编地址就要从整个程序开头计算

为了方便取得该段的汇编地址，NASM 编译器提供了以下的表达式，section.段名称.start 表示段相对于整个程序开头的汇编地址，这是一个特殊的内部标号。

### 2.1 用户程序格式
一般来说，加载器和用户程序是由不同人开发的，加载器必须了解一些必要的信息才能知道如何加载用户程序。用户程序的编译、链接、加载与执行可以参考[程序员的自我修养](https://book.douban.com/subject/3652388/)。

这里我们自己约定一个用户程序格式。经验表明，把这个约定的地点放在用户程序的开头，这就是用户程序头部。下面是我们接下来要使用的用户程序头部的一个示例:

```
SECTION header vstart=0                     ;定义用户程序头部段 
    program_length  dd program_end          ;程序总长度[0x00]，program_end 是一个尾部段的标号
    ;用户程序入口点
    code_entry      dw start                ;偏移地址[0x04]
                    dd section.code_1.start ;段地址[0x06] 
    
    realloc_tbl_len dw (header_end-code_1_segment)/4
                                            ;段重定位表项个数[0x0a]
    
    ;段重定位表           
    code_1_segment  dd section.code_1.start ;[0x0c]
    code_2_segment  dd section.code_2.start ;[0x10]
    data_1_segment  dd section.data_1.start ;[0x14]
    data_2_segment  dd section.data_2.start ;[0x18]
    stack_segment   dd section.stack.start  ;[0x1c]
    
    header_end:     

SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐） 
start:
         ;初始执行时，DS和ES指向用户程序头部段
         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 
         mov ss,ax
         ........

;中间部分暂时省略，trail 是用户程序最尾部的段
SECTION trail align=16
program_end:
```

其中:
1. 程序的长度取自程序尾部段中的一个标号“program_end”，trail 段没有设置 vstart=0 所以 标号“program_end”所代表的汇编地址是从整个程序的开头计算的
2. 应用程序的入口点:
    - 偏移地址是代码段code_1 中的标号“start”
    - 段地址是 section.code_1.start 
    - 入口点的段地址是用伪指令dd 声明的，这是一个32 位的地址，因为段地址起始于任何20 位的物理地址处，所以只能保存为 32 位的形式
3. 段重定位表:
    - 程序的加载是由加载器完成的，加载的位置是不确定的，加载后每个段的地址必须重新确定一下
    - 段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，为此在 header 需要一张段重定位表

约定好用户程序的格式，接下来我们就先来介绍加载器程序的汇编源码:

## 3. 加载器
下面是加载器程序的代码框架:

```
; 开头部分
         ;代码清单8-1
         ;文件名：c08_mbr.asm
         ;文件说明：硬盘主引导扇区代码（加载程序） 
         ;创建日期：2011-5-5 18:17
         
         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                         ;常数的声明不会占用汇编地址
SECTION mbr align=16 vstart=0x7c00       ; 将主引导扇区程序定义成一个段
    .......                              ; 准备加载用户程序   

read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
    .......
calc_segment_base:                       ;计算16位段地址，用于重定位
    .......

; 结尾部分
;-------------------------------------------------------------------------------
        phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa
```
加载器要加载一个用户程序，并使之开始执行，需要决定两件事:
1. 第一，看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序
2. 第二，用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少

加载程序的开头部分，伪指令 equ 用于声明一个常量 app_lba_start 表示程序所在的逻辑扇区号。我们假设，用户程序固定存放在逻辑扇区号为 100 的位置。用equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。

加载程序的结尾部分，`phy_base dd 0x10000` 定义了用户程序加载的内存地址。我们将按照如下的结构组织内存:
1. 物理地址0x0FFFF 以下，是加载器及其栈
2. 物理地址A0000 以上，是BIOS 和外围设备
3. 可用的空间就位于0x10000～9FFFF，用于装载我们的用户程序

![加载器程序内存组织](/images/assembly/loader_memory_space.png)

### 3.1 准备加载用户程序
```
SECTION mbr align=16 vstart=0x7c00                                     

         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax
         mov sp,ax
      
         mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
         mov dx,[cs:phy_base+0x02]
         mov bx,16        
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax                        
    
         ;以下读取程序的起始部分 
         xor di,di
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         call read_hard_disk_0
      
         ;以下判断整个程序有多大
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0
         jnz @1                          ;未除尽，因此结果比实际扇区数少1 
         dec ax                          ;已经读了一个扇区，扇区总数减1 
   @1:
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
      
         ;计算入口点代码段基址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序  
```

我们将主引导扇区程序定义成一个段: `SECTION mbr align=16 vstart=0x7c00`。vstart=0x7c00 表示段内所有元素的汇编地址都将从0x7c00 开始计算。避免了因为主引导程序的实际加载地址是0x0000:0x7c00，当我们引用一个标号时，还得手工加上那个落差0x7c00。

```
         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax
         mov sp,ax
```

栈的段地址是0x0000，段的长度是64KB，栈指针将在段内0xFFFF 和0x0000 之间变化。注意，SP 指针是 16 位的，所以 0000 - 1后是 FFFF，这个值是 0FFFF，不是0xFFFFF，所以栈段位于 0xFFFF 和0x0000 之间。

```
         mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
         mov dx,[cs:phy_base+0x02]
         mov bx,16        
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax                        
```
用户加载的起始地址保存在 phy_base 处的一个双字单元里，这是一个32 位的数。`dx:ax div 16` 的商就是该物理地址 16 位的段地址。

```
;以下读取程序的起始部分 
         xor di,di
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         call read_hard_disk_0
```
按照约定，用户程序的元数据都位于程序的开头处，我们需要先读取用户程序开头的第一个扇区，才能知道如何加载整个用户程序:
1. read_hard_disk_0 是读取一个磁盘扇区的调用过程
2. di,si,bx 是 read_hard_disk_0 会用到的参数寄存器

不过在介绍 read_hard_disk_0 调用过程之前，我们需要先简单介绍一个处理器如何与外围的硬件设备打交道。

### 3.2 外围设备及其接口
简单来说，所有的外围设备都有自己定义的信号传输标准和协议，为了便于处理器统一处理，很明显，这里需要一些信号转换器和变速齿轮，这就是I/O 接口。I/O 接口可以说是一个翻译器，在一边，它按处理器的信号规程工作，负责把处理器的信号转换成外围设备能接受的另一种信号；在另一边，它也做同样的工作，把外围设备的信号变换成处理器可以接受的形式。

整个处理器与外围设备的链接如下图所示:
1. 处理器通过 IO 总线与外围设备相连
2. 所有的外围设备都连接到输入输出控制设备集中器（I/O Controller Hub，ICH）芯片，该芯片的作用是连接不同的总线，并协调各个I/O 接口对处理器的访问
3. 处理器通过局部总线连接到ICH 内部的处理接口电路，在ICH 内部，又通过总线与各个I/O 接口相连。
4. 不管是什么设备，都必须通过它自己的I/O 接口电路同ICH 相连。
6. ICH 还提供了对PCI 或者PCI Express 总线的支持，该总线向外延伸，连接着主板上的若干个扩展槽，每个设备的I/O 接口电路都设计成插卡。这样，想接上该设备时，就把它的I/O 接口卡插上，不需要时，随时拔下。
7. 除了局部总线和PCI Express 总线，每个I/O 接口卡可能连接不止一个设备
8. 当处理器想同某个设备说话时，ICH 会接到通知。然后，它负责提供相应的传输通道和其他辅助支持，并命令所有其他无关设备闭嘴

![加载器程序内存组织](/images/assembly/ich.png)

#### 端口
外围设备和处理器之间的通信是通过相应的I/O 接口进行的。具体地说，处理器是通过端口（Port）来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫做端口的寄存器位于I/O 接口电路中。
端口是处理器和外围设备通过I/O 接口交流的窗口，每一个I/O 接口都可能拥有好几个端口，分别用于不同的目的。

比如，连接硬盘的PATA/SATA 接口就有几个端口，分别是
1. 命令端口（当向该端口写入0x20 时，表明是从硬盘读数据；写入0x30 时，表明是向硬盘写数据）、
2. 状态端口（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）、
3. 参数端口（处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号）和数据端口（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）。

端口只不过是位于I/O 接口上的寄存器，所以，每个端口有自己的数据宽度。在早期的系统中，端口可以是8 位的，也可以是16 位的，现在有些端口会是32 位的。到底是8 位还是16 位，这是设备和I/O 接口制造者的自由。比如，PATA/STAT 接口中的数据端口就是16 位的，这有助于加快数据传输速率，提高传输效率。

端口在不同的计算机系统中有着不同的实现方式:
1. 在一些计算机系统中，端口号是映射到内存地址空间的。比如，0x00000～0xE0000 是真实的物理内存地址，而0xE0001～0xFFFFF 是从很多I/O 接口那里映射过来的，当访问这部分地址时，实际上是在访问I/O 接口。
2. 而在另一些计算机系统中，端口是独立编址的，不和内存发生关系。如图8-10 所示，在这种计算机中，处理器的地址线既连接内存，也连接每一个I/O 接口。但是，处理器还有一个特殊的引脚M/IO#，在这里，“#”表示低电平有效。也就是说，当处理器访问内存时，它会让M/IO#引脚呈高电平，这里，和内存相关的电路就会打开；相反，如果处理器访问I/O 端口，那么M/IO#引脚呈低平，内存电路被禁止。与此同时，处理器发出的地址和M/IO#信号一起用于打个某个I/O 接口，如果该I/O 接口分配的端口号与处理器地址相吻合的话。

Intel 处理器，早期是独立编址的，现在既有内存映射的，也有独立编址的。在本章中，我们只讲独立编址的端口。所有端口都是统一编号的，比如0x0001、0x0002、0x0003、…。每个I/O 接口电路都分配了若干个端口，比如，I/O 接口A 有3 个端口，端口号分别是0x0021～0x0023；I/O 接口B 需要5 个端口，端口号分别是0x0303～0x0307。

一个现实的例子是个人计算机中的PATA/SATA 接口（图8-9），每个PATA 和SATA 接口分配了8个端口。但是，ICH 芯片内部通常集成了两个PATA/SATA 接口，分别是主硬盘接口和副硬盘接口。这样一来，主硬盘接口分配的端口号是0x1f0～0x1f7，副硬盘接口分配的端口号是0x170～0x177。


![加载器程序内存组织](/images/assembly/m_io.png)

#### in/out 
在Intel 的系统中，只允许65536（十进制数）个端口存在，端口号从0 到65535（0x0000～0xffff）。因为是独立编址，所以，端口的访问不能使用类似于mov 这样的指令，取而代之的是in 和out 指令：
1. in 指令是从端口读，它的一般形式是 `in al dx`/`in ax dx`
    - in 指令的目的操作数必须是寄存器AL 或者AX，当访问8 位的端口时，使用寄存器AL；访问16 位的端口时，使用AX
    - in 指令的源操作数应当是寄存器DX
    - 不允许使用别的通用寄存器，也不允许使用内存单元作为操作数
    - in al,dx 的机器指令码是0xEC，in ax,dx 的机器指令码是0xED
    - 了方便，in 指令还有两字节的形式。此时，前一字节是操作码0xE4 或者0xE5，分别用于指示8 位或者16 位端口访问；后一字节是立即数，指示端口号，比如 `in al 0xff`/`in ax 0xf03`。很显然，因为这种指令形式的操作数部分只允许一字节，故只能访问0～255（0x00～0xff）号端口，不允许访问大于255 的端口号
2. out 指令是从端口写，目的操作数可以是8 位立即数或者寄存器DX，源操作数必须是寄存器AL 或者AX

#### 通过硬盘控制器端口读扇区数据
现在要从硬盘上读逻辑扇区，那么，整个过程如下:

第1 步，设置要读取的扇区数量。这个数值要写入**0x1f2 端口**
```
mv dx, 0x1f2
mv al, 0x01  ;1个扇区
out dx, al
```

注意，如果写入的值为0，则表示要读取256 个扇区。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。

第2 步，设置起始LBA(逻辑扇区编址) 扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28 位的扇区号太长，需要将其分成4 段，分别写入端口**0x1f3、0x1f4、0x1f5 和0x1f6 号端口**。其中，0x1f3 号端口存放的是0～7 位；0x1f4 号端口存放的是8～15 位；0x1f5 号端口存放的是16～23 位，最后4 位在0x1f6 号端口。假定我们要读写的起始逻辑扇区号为0x02:

```
mov dx, 0x1f3 
mov al, 0x02
out dx, al ; 将 al 写入 dw 端口
inc dx
mov al, 0x00
out dx, al
inc dx
out dx, al
inc dx
mov al, 0xe0
out dx, al
```

在现行的体系下，每个PATA/SATA 接口允许挂接两块硬盘，分别是主盘（Master）和从盘（Slave）0x1f6 端口的低4 位用于存放逻辑扇区号的24～27位，第4 位用于指示硬盘号，0 表示主盘，1 表示从盘。高3 位是“111”，表示LBA 模式。

![加载器程序内存组织](/images/assembly/LBA.png)

第3 步，向端口0x1f7 写入0x20，请求硬盘读。

```
mov dx, 0x1f7
mov al, 0x20
out dx, al
```

第4 步，等待读写操作完成。端口0x1f7 既是命令端口，又是状态端口。在它内部操作期间，它将0x1f7 端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3 位置“1”，意思是准备好了，请求主机发送或者接收数据（图8-12）。

![加载器程序内存组织](/images/assembly/disk_state.png)

完成这一步的典型代码如下:

```
    mov dx, 0x1f7
.waits:
    in al, dx ; 读取端口内保存的磁盘状态
    and al, 0x88
    cmp al, 0x08
    jnz .waits ; 不相等时
```

and al,0x88。0x88 的二进制形式是10001000，这意味着我们想用这条指令保留住寄存器AL 中的第7 位和第3 位。此时，如果寄存器AL 中的二进制数是00001000（0x08），那就说明可以退出等待状态，继续往下操作，否则继续等待。

第5 步，连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。下面的代码假定是从硬盘读一个扇区（512 字节，或者256 字节），读取的数据存放到由段寄存器DS 指定的数据段，偏移地址由寄存器BX 指定：

```
mov cx, 256 ; 要读取的字节数
mov dx, 0x1f0

.readw
    in ax, dw ; 从 dw 端口读到 ax
    mov [bx], ax
    add bx, 2
    loop .readw
```

最后，0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。

### 3.3 过程调用
所谓过程调用，就是我们常说的函数，读取磁盘分区的代码会发生多次，因此我们可以抽象成过程调用便于复用。过程调用需要配合 call，ret 两个指令，调用的执行流如下:

![加载器程序内存组织](/images/assembly/call_ret.png)

过程调用需要传递参数，参数传递最简单的办法是通过寄存器。在这里:
1. 主程序把起始逻辑扇区号的高16 位存放在寄存器DI 中（只有低12 位是有效的，高4 位必须保证为“0”），低16 位存放在寄存器SI 中；
2. 约定将读出来的数据存放到由段寄存器 DS 指向的数据段中，起始偏移地址在寄存器BX 中。

即磁盘读取的过程调用会用到 DI:SI + DS:BX 四个寄存器。磁盘读取的过程调用代码如下:

```
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax                         ; 1. 保存用到的寄存器里的初始值
         push bx
         push cx
         push dx
      
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数

         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di                       ;2. 逻辑扇区的高 12 位，剩余 4 位在 ah
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘；1110 0000
         or al,ah                        ;LBA地址27~24 ah 中有剩余的 4 位地址，所以需要做 or 操作
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al

  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx
         pop cx
         pop bx
         pop ax
      
         ret                             ; 返回调用 call 的下一条指令
```

调用过程的指令是“call”。8086 处理器支持四种调用方式:
1. 第一种是16 位相对近调用目标过
    - 程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可
    - 16 位相对近调用是三字节指令，操作码为0xE8，后跟16 位的操作数，因为是相对调用，故该操作数是当前call 指令相对于目标过程的偏移量
    - 近调用的特征是在指令中使用关键字“near”。“proc_1”是程序中的一个标号。在编译阶段，编译器用标号proc_1 处的汇编地址减去本指令的汇编地址，**再减去3**，作为机器指令的操作数。
    - 如果call 指令中没有提供任何关键字，则编译器认为该指令是近调用
    - 在指令执行阶段，它用指令指针寄存器IP 的当前内容加上指令中的操作数，**再加上3**，得到一个新的偏移地址。接着，**将IP 的原有内容压入栈**。最后，用刚才计算出的偏移地址取代IP 原有的内容。这直接导致处理器的执行流转移到目标位置处。
2. 第二种是16 位间接绝对近调用:
    - 也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址
    - 这个偏移地址不是直接出现在指令中，而是由16 位的通用寄存器或者16 位的内存单元间接给出
    - 间接绝对近调用指令在执行时，处理器首先按以上的方法计算被调用过程的偏移地址，然后将指令指针寄存器IP 的当前值压栈，最后用**计算出来的偏移地址取代**寄存器IP 原有的内容。
3. 第三种是16 位直接绝对远调用
    - 这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用（far call），段地址和偏移地址直接在call 指令中给出了，按规定，偏移地址在前，段地址在后。
    - 处理器在执行时，首先将**代码段寄存器CS 的当前内容压栈**，接着再把指令指针寄存器IP 的当前内容压栈。紧接着，用指令中给出的段地址代替CS 原有的内容，用指令中给出的偏移地址代替IP 原有的内容。这直接导致处理器从新的位置开始执行。
4. 第四种是16 位间接绝对远调用
    - 这也属于段间调用，被调用过程位于另一个代码段内，而且，被调用过程所在的段地址和偏移地址是间接给出的
    - 间接远调用必须使用关键字“far”

下面是一个间接绝对远调用的例子

```
;0x0102 是偏移地址； 0x2000 是段地址
proc_1: dw 0x0102:0x2000
call far [proc_1]

```
当这条指令执行时，处理器访问由段寄存器DS 指向的数据段，从指令中指定的偏移地址（由标号proc_1 提供）处取得两个字（分别是段地址0x2000 和偏移地址0x0102）；接着，将代码段寄存器CS 和指令指针寄存器IP 的当前内容分别压栈；最后，用刚才取得的段地址和偏移地址分别取代CS 和IP 的原值。

#### 调用过程的返回
ret 和retf 经常用做call 和call far 的配对指令。ret 是近返回指令，当它执行时，处理器只做一件事，那就是从栈中弹出一个字到指令指针寄存器IP 中。

retf 是远返回指令（return far），它的工作稍微复杂一点点。当它执行时，处理器分别从栈中弹出两个字到指令指针寄存器IP 和代码段寄存器CS 中。

### 3.3 加载用户程序
现在我们可以继续之前准备加载用户程序的汇编代码了:

```
         ........
         call read_hard_disk_0           ; 1. 读取用户的第一个逻辑分区
      
         ;以下判断整个程序有多大
         mov dx,[2]                      ; program_length  dd program_end
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0                        ; dx 表示余数
         jnz @1                          ; jnz 不为 0；未除尽，余数充当一个扇区，已经读取一个扇区，抵充 
         dec ax                          ; 为 0 表示除尽，已经读了一个扇区，扇区总数减1
   @1:
         cmp ax,0                        ; ax 中是要读取的扇区数，考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
```

`add ax,0x20` 的原因是用户程序被加载的位置是由DS 和ES 所指向的逻辑段。一个逻辑段最大也才64KB，当用户程序特别大的时候，根本容纳不下。要解决这个问题最好的办法是，每次往内存中加载一个扇区前，都重新在前面的数据尾部构造一个新的逻辑段，并把要读取的数据加载到这个新段内。因为每个段的大小是512(2^10) 字节，即，十六进制的0x200,右移4 位（相当于除以16 或者0x10）后是0x20。

### 3.4 用户程序重定位
户程序在编写的时候是分段的。因此，加载器下一步的工作是计算和确定每个段的段地址。

```
         ;计算入口点代码段基址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序 

 calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
         push dx                          
         
         add ax,[cs:phy_base]
         adc dx,[cs:phy_base+0x02]        ;phy_base 对应的高 16 位地址
         shr ax,4
         ror dx,4
         and dx,0xf000
         or ax,dx
         
         pop dx
         
         ret
;----------------------------------------------------------------
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
```

用户程序的结构是
```
SECTION header vstart=0                     ;定义用户程序头部段 
    program_length  dd program_end          ;程序总长度[0x00]，program_end 是一个尾部段的标号
    ;用户程序入口点
    code_entry      dw start                ;偏移地址[0x04]
                    dd section.code_1.start ;段地址[0x06] 

    realloc_tbl_len dw (header_end-code_1_segment)/4
                                            ;段重定位表项个数[0x0a]
    
    ;段重定位表           
    code_1_segment  dd section.code_1.start ;[0x0c]
```

在上面的指令中:
1. adc 是带进位加法，它将目的操作数和源操作数相加，然后再加上标志寄存器CF 位的值（0 或者1），因为前面 `add ax,[cs:phy_base]` 是有可能发生进位的
2. shr 是逻辑右移指令，shr 的配对指令是逻辑左移指令shl（SHift logical Left）
3. ror 循环右移（ROtate Right）循环右移指令执行时，每右移一次，移出的比特既送到标志寄存器的CF 位，也送进左边空出的位。ror 的配对指令是循环左移指令rol（ROtate Left）
4. `jmp far [0x04]` 用户程序已经在内存中准备就绪，加载器通过一个16 位的间接绝对远转移指令，跳转到用户程序入口点。注意此时 `DS=[cs:phy_base]`

![加载器程序内存组织](/images/assembly/ror.png)

在重定位用户程序之后，段重定位表存放的就是重定位后，用户程序可用的地址段。当控制前从加载器转移到用户程序后，用户程序需要读取重定位表，设置自己的代码段和数据段。这一部分需要用户程序自己完成。

#### jump 
无条件转移指令jmp 的有四种用法:
1. 相对短转移，相对的意思表示偏移地址
    - jump short infinite
    - 操作数 infinite 是相对于目标位置的偏移量，仅1 字节
    - 编译器用目标位置的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（2），保留1 字节的结果
    - 在指令执行时，处理器把指令中的操作数加上2，再加到指令指针寄存器IP 上
2. 16 位相对近转移，近转移，即只在段内转移
    - jump short infinite
    - 与相对短转移类似，只是指令的长度为3 字节，，偏移量为 2 个字节，
3. 16 位间接绝对近转移
    - 间接表示偏移地址是用一个16 位的通用寄存器或者内存地址来间接给出的。
    - 绝对表示直接给出 IP 寄存器值，而不是相对于当前指令的偏移
    - jump near bx 要转移的绝对偏移地址位于寄存器BX 中
    - `jmp near [bx]` 偏移地址位于由BX 所指向的内存字单元中
4. 16 位直接绝对远转移
    - 直接的意思是直接给出跳转地址
    - 远跳转表示给出段地址
    - jump 0x0000:0x7c00 分别是段地址和偏移地址
    - 字的存放是按照低端字节序的。而且，在编译之后，偏移地址在前，段地址在后。
5. 16 位间接绝对远转移（jmp far）
    - 相对于 16 位直接绝对远转移，这个地址是在寄存器和内存中的
    - jfar dw 0x7c00,0x0000 偏移地址和段地址
    - `jump far [jfar]`
    - 处理器执行这条指令后，访问段寄存器DS 所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS 和指令指针寄存器IP 的内容。

## 4.用户程序的执行
因为加载器已经完成了重定位工作，所以用户程序的头等大事是初始化处理器的各个段寄存器DS、ES、SS，初始化的代码如下

```
  start:
         ;初始执行时，DS和ES指向用户程序头部段
         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 
         mov ss,ax
         mov sp,stack_end
         
         mov ax,[data_1_segment]          ;设置到用户程序自己的数据段
         mov ds,ax

         mov bx,msg0
         call put_string                  ;显示第一段信息 

         push word [es:code_2_segment]
         mov ax,begin
         push ax                          ;可以直接push begin,80386+
         
         retf                             ;转移到代码段2执行 

SECTION stack align=16 vstart=0
           
         resb 256

stack_end:  
```
注意，在刚刚进入用户程序时，段寄存器DS 和ES 依然指向段header，而栈段寄存器SS 依然指向加载器的栈空间。

标号stack_end 所代表的数值传送到栈指针寄存器SP，在它的前面，是伪指令resb，用来保留256 字节的栈空间。伪指令resb（REServe Byte）的意思是从当前位置开始，保留指定数量的字节。resb 不是唯一用来声明未初始化数据的指令，还有 resw，resd，w 和 d 表示单位字和双字。

设置好所有段寄存器后，即可执行用户程序自己的逻辑。后面的代码我们就不在详述。这里需要注意的是 retf 返回指令的使用。我们知道，ret 和retf 指令分别用于近返回和远返回。返回指令的动作是从栈中弹出内容到指令指针寄存器IP，如果是远返回的话，还要接着弹出内容到代码段寄存器CS。假如要想切换到另一个代码段中执行，可以使用远调用指令（call far）或者远转移指令（jmp far）。问题在于，为了实现段间控制转移，必须事先开辟两个连续的内存单元，存放另一个代码段的入口点偏移地址和段地址，代价似乎有点高。为了省事，可以使用指令retf 来模拟段间返回，以实现段间转移。

`push word [es:code_2_segment]` 先在栈中压入代码段code_2 的段地址，`push ax` 压入偏移地址，该偏移地址就是标号begin 在编译阶段的汇编地址。注意此时 es 寄存器依旧指向的是 header 段，所以可以取到重定位表中的值。

当处理器执行指令retf 时，这个被蒙在鼓里的家伙从栈中将偏移地址和段地址分别弹出到代码段寄存器CS 和指令指针寄存器IP，于是控制立即转移到段code_2 中，从标号begin处开始执行。

最后源程序中的 put_string，put_char 例程是想屏幕显示字符的通用例程，后面的代码还会使用。

