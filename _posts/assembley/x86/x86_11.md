---
title: 11. 任务和特权级保护
date: 2021-07-11
categories:
    - Go
tags:
	- x86 汇编
---

保护模式五
<!-- more -->

## 1. 内容概述
在保护模式下，通过将内存分成大小不等的段，并用描述符对每个段的用途、类型和长度进行指定，就可以在程序运行时由处理器硬件施加访问保护。段保护是处理器提供的基本保护功能，但对于现实的需求来说，仍是不够的。一个失控的程序，或者一个恶意的程序，依然可以通过追踪和修改描述符表来达到它们访问任何内存位置的目的。多任务系统，对任务之间的隔离和保护，以及任务和操作系统之间的隔离和保护都提出了要求，这可以看做对段保护机制的进一步强化。本章我们将介绍处理器的任务隔离和特权级，内容包括:
1. 任务的概念及其组成要素，包括任务的全局空间和局部空间、TSS、LDT、特权级等
2. 了解特别级不是指任务的特权级，而是指组成任务的各个部分的特权级。比如，任务的全局部分一般是0、1 和2 特权级别的，任务的私有部分一般是3 特权级别的
3. 理解CPL、DPL 和RPL 的含义，以及不同特权级别之间的控制转移规则
4. 熟悉调用门的用法

## 2. 任务
### 2.1 任务、任务的LDT 和TSS
![多任务系统的组成示意图](/images/assembly/task.png)

运行中的程序称为一个任务，如上图所示，为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，称为**局部描述符表LDT（Local Descriptor Table）**，并且把专属于自己的那些段放到LDT 中。

每个任务都有自己的LDT，每个任务私有的段，都应当在LDT 中进行描述。另外，LDT 的第1 个描述符，也就是0 号槽位，也是有效的、可以使用的。为了追踪和访问这些LDT，处理器使用了局部描述符表寄存器（LDT Register：LDTR）。因为LDTR 寄存器只有一个，所以，它只用于指向当前任务的LDT。每当发生任务切换时，LDTR 的内容被更新，以指向新任务的LDT。

段选择子的位2 是表指示器（Table Indicator：TI），若TI＝0，表示从GDT 中加载描述符；TI＝1，表示从当前任务的LDT 中加载描述符。

在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，以便在下次重新执行时恢复它们。为了保存任务的状态，每个任务都应当用一个额外的内存区域保存相关信息，这叫做**任务状态段（Task State Segment：TSS）**

#### TSS 格式
![TSS 格式](/images/assembly/tss.png)

如图所示，任务状态段TSS 具有固定的格式，最小尺寸是104 字节，图中所标注的偏移量是十进制的。处理器固件能够识别TSS 中的每个元素，并在任务切换的时候读取其中的信息。和LDT 一样，处理器用**TR 寄存器（Task Register：TR）**来指向当前任务的TSS。和GDTR、LDTR 一样，TR 寄存器在处理器中也只有一个。当任务切换发生的时候，TR 寄存器的内容也会跟着指向新任务的TSS。

任务切换时，处理器将当前任务的现场信息保存到由TR 寄存器指向的TSS；然后，再使TR 寄存器指向新任务的TSS，并从新任务的TSS 中恢复现场。

### 2.2 全局空间和局部空间
每个任务实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。

任务实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。地址空间的访问是依靠分段机制来进行的。

具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。

从程序员的角度来看，任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供的服务时，转入全局空间执行。

### 2.3 特权级
引入LDT 和TSS，只是从任务层面上进一步强化了分段机制，从安全保障的角度来看，只相当于构建了可靠的硬件设施。当然，仅有设施是不够的，还需要规章制度，还要有人来执行，处理器也一样。为此，**在分段机制的基础上，处理器引入了特权级**，并由固件负责实施特权级保护。

特权级（Privilege Level），也叫特权级别，是存在于**描述符及其选择子**中的一个数值。Intel 处理器可以识别4 个特权级别，分别是0 到3，较大的数值意味着较低的特权级别，如图所示，是Intel 处理器所提供的4 级环状保护结构。

![处理器的4 级环状保护结构](/images/assembly/privilege.png)

1. 特权级0是操作系统内核
2. 特权级1、2是系统服务程序，包括设备驱动程序
3. 特权级3是应用程序

实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们。每个描述符都有一个两比特的DPL 字段是**描述符特权级（Descriptor Privilege Level）**。描述符总是指向它所描述的目标对象，代表着该对象，因此，该字段实际上是目标对象的特权级。
1. 对于数据段来说，DPL 决定了访问它们所应当具备的最低特权级别。
2. 当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（Current Privilege Level，CPL）。正在执行的这个代码段，其选择子位于段寄存器CS 中，其最低两位就是当前特权级的数值。

操作系统的代码工作在0 特权级别上，当前特权级CPL 就是0，普通的应用程序则工作在特权级别3 上。这实际上就是把一个任务分成特权级截然不同的两个部分，全局部分是特权级0 的，而局部空间则是特权级3 的。那些只有在当前特权级CPL 为0 时才能执行的指令，称为特权指令（Privileged Instructions）。

### 2.4 输入输出特权级
除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O 操作进行控制。通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的。在处理器的标志寄存器EFLAGS 中，位13、位12 是IOPL 位，也就是输入/输出特权级（I/O Privilege Level），它代表着当前任务的I/O 特权级别。

![输入/输出特权级（I/O Privilege Level）](/images/assembly/io_privilege.png)

任务是由操作系统加载和创建的，与任务相关的信息都在它自己的任务状态段（TSS）中，其中就包括一个EFLAGS 寄存器的副本，用于指示与当前任务相关的机器状态。

处理器不限制0 特权级程序的I/O 访问，它总是允许的。但是，可以限制低特权级程序的I/O访问权限。

### 2.4 控制转移
代码段的特权级检查是很严格的。一般来说，控制转移只允许发生在两个特权级相同的代码段之间。不过，为了让特权级低的应用程序可以调用特权级高的操作系统例程，处理器也提供了相应的解决办法。

#### 依从代码段
第一种方法是将高特权级的代码段定义为依从的。这种方法具有如下特点:
1. 设置: 代码段描述符的TYPE 字段有C 位，如果C＝0，这样的代码段只能供同特权级的程序使用；否则，如果C＝1，则这样的代码段称为依从的代码段，可以从特权级比它低的程序调用并进入。
2. 控制转移条件: 要求**当前特权级CPL 必须低于，或者和目标代码段描述符的DPL 相同**。任何时候，都不允许将控制从较高的特权级转移到较低的特权级
3. 权限变化: 
    - 依从的代码段不是在它的 DPL 特权级上运行，而是在调用程序的特权级上运行
    - 即当控制转移到依从的代码段上执行时，不改变当前特权级CPL
    - 被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为“依从的”代码段
3. 理解: **因为高特权级的代码是操作系统可控的，所以可以进入，用户代码是不可控的所以不允许进入。而对数据段，操作系统的数据是机密，不允许随便访问。**

#### 调用门
另一种在特权级之间转移控制的方法是使用门。门（Gate）是另一种形式的描述符，称为门描述符，简称门。，段描述符用于描述内存段，门描述符则用于描述可执行的代码，比如一段程序、一个过程（例程）或者一个任务。

根据不同的用途，门的类型有好几种:
1. 不同特权级之间的过程调用可以使用调用门
2. 中断门/陷阱门是作为中断处理过程使用的
3. 任务门对应着单个的任务，用来执行任务切换

接下来我们先来介绍调用门。调用门具有如下特点:
1. 定义: 在调用门描述符中，定义了目标过程（例程）所在代码段的选择子，以及段内偏移。
2. 使用: 通过调用门进行控制转移，可以使用jmp far 或者call far 指令，并把调用门描述符的选择子作为操作数
    - jmp far 指令，可以将控制通过门转移到比当前特权级高的代码段，但**不改变当前特权级别**
    - call far 指令，则当前特权级会提升到目标代码段的特权级别。但是，除了从高特权级别的例程（通常是操作系统例程）返回外，不允许从特权级高的代码段将控制转移到特权级低的代码段，因为操作系统不会引用可靠性比自己低的代码。

调用门的设置我们后面在详述。

#### mbr 启动过程中的控制转移
特权级保护机制只在保护模式下才能启用，进入保护模式之后，处理器自动将当前特权级CPL 设定为0，以0 特权级的身份开始执行保护模式的初始指令。

### 2.5 RPL
RPL 的意思是请求特权级（Requested Privilege Level）。RPL 与 CPL 的区别在于，RPL 用于标识请求的真正来源。比如用户程序 C1 通过调用门进入操作系统的例程 A1 将磁盘读取到指定的数据段 DS 内。前面我们说到通过 call far 进行调用门控制转移时，CPL 会提升到目标代码的特权级别。此时 A1 是可以将磁盘数据写入操作系统数据段的。此时如果不区分请求的来源，就有可能出现用户程序破坏操作系统数据的情况。

![正常通过调用门读取数据到应用程序的数据段](/images/assembly/rpl_client.png)


![通过调用门读取数据到操作系统数据段](/images/assembly/rpl_core.png)

所以引入请求特权级（RPL）的原因是处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁。RPL 只是处理器和操作系统之间的一种协议，处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL；内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符，因为这是处理器无能为力的。

每当处理器执行一个将段选择子传送到段寄存器（DS、ES、FS、GS）的指令，会检查以下两个条件是否都能满足。
1. 当前特权级CPL 高于或者和**数据段描述符**的DPL 相同。
2. 请求特权级RPL 高于或者和数据段描述符的DPL 相同。

### 2.6 基本特权级检查
最后，我们来总结一下基本的特权级检查规则:
1. 首先，将控制直接转移到非依从的代码段，要求当前特权级CPL 和请求特权级RPL 都等于目标代码段描述符的DPL。
2. 其次，要将控制直接转移到依从的代码段，要求当前特权级CPL 和请求特权级RPL 都低于，或者和目标代码段描述符的DPL 相同，控制转移后，当前特权级保持不变。
3. 第三，高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。即要求当前特权级CPL 和请求特权级RPL 都必须高于，或者和目标数据段描述符的DPL 相同。
4. 最后，处理器要求，**在任何时候，栈段的特权级别必须和当前特权级CPL 相同**。

## 3. 调用门
### 3.1 调用门描述符格式
调用门（Call-Gate）用于在不同特权级的程序之间进行控制转移，该描述符的格式如下图所示:

![调用门描述符格式](/images/assembly/call_gate.png)

调用门描述符给出了例程所在代码段的选择子，有了段选择子，就能访问描述符表得到代码段的基地址，这样做无非是间接了一点，但却可以在**通过调用门进行控制转移时，实施代码段描述符有效性、段界限和特权级的检查**。描述符中的TYPE 字段用于标识门的类型，共4 比特，值“1100”表示调用门。

### 3.2 控制转移中的栈切换
通过调用门实施特权级之间的控制转移时，使用call far 指令会改变当前特权级CPL。因为栈段的特权级必须同当前特权级保持一致，因此，还要切换栈，即，从低特权级的栈切换到高特权级的栈。为了切换栈，每个任务除了自己固有的栈之外，还必须额外定义几套栈，具体数量取决于任务的特权级别。比如 特权级的任务最多额外定义3 个栈，描述符特权级分别是0、1 和2，在控制转移到0、1 和2 特权级时使用。这些额外创建的栈，其描述符位于任务自己的LDT 中。同时，还要在任务的TSS 中登记，原因是，栈切换是由处理器固件自动完成的，处理器需要根据TSS 中的信息来完成这一过程。

![TSS 格式](/images/assembly/tss.png)

在TSS 内，从偏移4～24 处登记有特权级0 到2 的栈段选择子，以及相应的ESP 初始值。任务自己固有的栈信息则位于偏移量为56（ESP）和80（SS）的地方。

通过调用门使用高特权级的例程服务时，调用者会传递一些参数给例程。如果参数是通过栈传递的，当栈切换时，参数还在旧栈中。为了使例程能获得参数，必须将参数从旧栈复制到新栈中。

参数的复制工作是由处理器固件完成的，但它必须事先知道参数的个数，并根据该数量决定复制多少内容。所以，调用门描述符中还有一个参数个数字段，共5 比特。就是说，至多允许传送31 个参数。

栈切换前，段寄存器 SS 指向的是旧栈，ESP 指向旧栈的栈顶，即最后一个被压入的过程参数；栈切换后，处理器自动替换SS 和ESP 寄存器的内容，使它们分别为新栈的选择子和新栈的栈顶（最后一个被复制的参数）。

### 3.3 调用门的控制转移规则
调用门描述符中的DPL 和目标代码段描述符的DPL 用于决定哪些特权级的程序可以访问此门，以下两个条件必须同时满足:
1. 当前特权级CPL 和请求特权级RPL 高于，或者和调用门描述符特权级DPL 相同。
1. 当前特权级CPL 低于，或者和目标代码段描述符特权级DPL 相同。
即，调用门的DPL 是特权级检查的下限，调用门描述符中的目标代码段描述符的DPL，决定了调用门特权级检查的上限。只有那些特权级低于或者等于目标代码段DPL 的程序才允许使用此门。

## 4. 加载用户程序并创建任务
### 4.1 TCB
在内核初始化完成后，接下来的工作就是加载和重定位用户程序（ 应用程序），并移交控制权。按处理器的要求标准，要使一个程序成为“任务”，必须要有LDT 和TSS。同时为了在任务之间切换和轮转，必须能追踪到所有正在运行的任务，记录它们的状态。

为了满足以上的要求，内核应当为每一个任务创建一个内存区域，来记录任务的信息和状态，称为任务控制块（Task Control Block，TCB）。如图所示，这是任务控制块的结构:

![TCB 格式](/images/assembly/tcb.png)

为了能够追踪到所有任务，应当把每个任务控制块TCB 串起来，形成一个链表。标号tcb_chain 并初始化为一个双字用于指向第一个任务，每个TCB 的第一个双字，也是一个双字长度的指针，用于指向下一个任务的TCB。。如果该位置是零，表示后面没有任务，这是链上的最后一个任务。

![任务控制块链](/images/assembly/tcb_chain.png)

### 4.2 使用栈传递参数
加载和重定位用户程序，依然是在过程load_relocate_program 中进行。该过程需要传入两个参数，分别是用户程序的起始逻辑扇区号，以及它的任务控制块TCB 线性地址。和上一章不同的是，参数不是用寄存器传入的，而是采用栈。再执行下面的代码后，栈的结构将如下图所示:

```
         ;创建任务控制块。这不是处理器的要求，而是我们自己为了方便而设立的
         mov ecx,0x46
         call sys_routine_seg_sel:allocate_memory
         call append_to_tcb_link            ;将任务控制块追加到TCB链表 
         push dword 50                      ;用户程序位于逻辑50扇区
         push ecx                           ;压入任务控制块起始线性地址 
       
         call load_relocate_program

load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入: PUSH 逻辑扇区号
                                            ;      PUSH 任务控制块基地址
                                            ;输出：无 
         pushad
      
         push ds
         push es
      
         mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
```

![栈的内存分布](/images/assembly/load_stack.png)

当前的栈顶位置是SS:EBP，指向一个双字，是段寄存器ES 的内容。按照参数的位置:
1. TCB 线性地址在栈中的位置是SS∶EBP＋44
2. 用户程序起始逻辑扇区号在栈中的位置是SS∶EBP＋48

### 4.3 加载用户程序
当用户程序被读入内存，并处于运行或者等待运行的状态时，就视为一个任务。每个任务都允许有自己的LDT，而且可以定义在任何内存位置。所以，我们现在要做三件事：
1. 分配一块内存，作为LDT 来用，为创建用户程序各个段的描述符做准备；
2. 将LDT 的大小和起始线性地址登记在任务控制块TCB 中；
3. 分配内存并加载用户程序，并将它的大小和起始线性地址登记到TCB 中。

### 4.4 创建局部描述符表
创建局部描述符表的过程如下:

```
         mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
         ;建立程序头部段描述符
         mov edi,[es:esi+0x06]              ;获得程序加载基地址
         mov eax,edi                        ;程序头部起始线性地址
         mov ebx,[edi+0x04]                 ;段长度
         dec ebx                            ;段界限
         mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3 
         ;调用过程sys_routine_seg_sel:make_seg_descriptor 后，会在EDX:EAX 中返回64 位的段描述符
         call sys_routine_seg_sel:make_seg_descriptor
      
         ;安装头部段描述符到LDT中 
         mov ebx,esi                        ;TCB的基地址
         call fill_descriptor_in_ldt

         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
         mov [es:esi+0x44],cx               ;登记程序头部段选择子到TCB 
         mov [edi+0x04],cx                  ;和头部内 

```

fill_descriptor_in_ldt 是当前内核代码段的内部（近）过程，用于在当前任务的LDT 中安装描述符。它需要传入两个参数：
1. 一个是要安装的描述符，由EDX:EAX 共同提供；
2. 另一个是当前任务控制块的基地址，由EBX 寄存器提供。它用这个地址来访问TCB 以获得LDT 的基地址和当前的大小（界限值），并在安装描述符后更新LDT 的界限值。


### 4.5 重定位U-SALT 表
重定位过程无非就是找到名字相同的 C-SALT 条目，把它的地址部分复制到U-SALT 的对应条目中。在第上一章里，复制的是16 位的代码段选择子和32 位的段内偏移。在本章中，这些地址不再是普通的段选择子和段内偏移，而是调用门选择子和段内偏移。

当初，在创建这些调用门时，选择子的RPL 字段是0。也就是说，这些调用门选择子的请求特权级是0。当它们被复制到U-SALT 中时，应当改为用户程序的特权级（3）。

```
mov ax,[esi+4]
         or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
                                            ;故RPL=3 
         mov [es:edi-252],ax                ;回填调用门选择子 
```

### 4.6 创建0、1 和2 特权级的栈
通过调用门的控制转移通常会改变当前特权级CPL，同时还要切换到与目标代码段特权级相同的栈。为此，必须为每个任务定义额外的栈。对于当前的3 特权级任务来说，应当创建特权级0、1 和2 的栈。而且，应当将它们定义在每个任务自己的LDT 中。

这些额外的栈是动态创建的，而且需要登记在任务状态段（TSS）中，以便处理器固件能够自动访问到它们。但是，现在的问题是还没有创建TSS，有必要先将这些栈信息登记在任务控制块（TCB）中暂时保存。

创建 0 特权级的栈代码如下:
```
         mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址

         ;创建0特权级堆栈
         mov ecx,4096
         mov eax,ecx                        ;为生成堆栈高端地址做准备 
         mov [es:esi+0x1a],ecx
         shr dword [es:esi+0x1a],12         ;登记0特权级堆栈尺寸到TCB 
         call sys_routine_seg_sel:allocate_memory
         add eax,ecx                        ;堆栈必须使用高端地址为基地址
         mov [es:esi+0x1e],eax              ;登记0特权级堆栈基地址到TCB 
         mov ebx,0xffffe                    ;段长度（界限）
         mov ecx,0x00c09600                 ;4KB粒度，读写，特权级0
         call sys_routine_seg_sel:make_seg_descriptor
         mov ebx,esi                        ;TCB的基地址
         call fill_descriptor_in_ldt
         ;or cx,0000_0000_0000_0000          ;设置选择子的特权级为0
         mov [es:esi+0x22],cx               ;登记0特权级堆栈选择子到TCB
         mov dword [es:esi+0x24],0          ;登记0特权级堆栈初始ESP到TCB
```

### 4.7 安装LDT 描述符到GDT 中
尽管局部描述符表（LDT）和全局描述符表（GDT）都用来存放各种描述符，比如段描述符，但这掩盖不了它们也是内存段的事实。简单地说，它们也是段。但是，因为它们用于系统管理，故称为系统的段或系统段。

全局描述符表（GDT）是唯一的，只需要用GDTR 寄存器存放其线性基地址和段界限即可；但LDT 不同，每个任务一个，所以，为了追踪它们，处理器要求在GDT 中安装每个LDT 的描述符。当要使用这些LDT 时，可以用它们的选择子来访问GDT，将LDT 描述符加载到LDTR 寄存器。如果不这样，处理器将没有机会来做存储器和特权级的保护工作。

```
         ;在GDT中登记LDT描述符
         mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
         movzx ebx,word [es:esi+0x0a]       ;LDT段界限
         mov ecx,0x00408200                 ;LDT描述符，特权级0
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
```

LDT 描述符的格式如下图所示:

![LDT 描述符的格式](/images/assembly/ldt_seg.png)

LDT 本身也是一种特殊的段:
1. 最大尺寸是64KB
2. 段基地址指示LDT 在内存中的起始地址，段界限指示LDT 的范围；描述符的G 位是粒度位，适用于LDT 描述符，以表示LDT 的界限值是以字节为单位，还是以4KB 为单位。即使是以4KB 为单位，它也不能超过64KB 的大小。
3. D 位（或者叫B 位）和L 位对LDT 描述符来说没有意义，固定为0。
4. AVL 和P 位的含义和存储器的段描述符相同。
5. LDT 描述符中的S 位固定为0，表示系统的段描述符或者门描述符，以相对于存储器的段描述符（S＝1），因为LDT 描述符属于系统的段描述符。在S＝0 的前提下，TYPE 字段为0010（二进制）表明这是一个LDT 描述符。

### 4.8 任务状态段 TSS
在创建TSS之前，我们先来全面了解一下TSS 的各个组成部分。

![TSS 格式](/images/assembly/tss.png)

和LDT 一样，必须在全局描述符表（GDT）中创建每个TSS 的描述符。

#### I/O 映射基地址
每个任务都有EFLAGS 寄存器的副本，其内容在任务创建的时候由内核或者操作系统初始化。EFLAGS 寄存器的IOPL 位决定了当前任务的I/O 特权级别。如果当前特权级CPL 高于，或者和任务的I/O 特权级IOPL 相同时，所有I/O 操作都是允许的，针对任何硬件端口的访问都可以通过。

相反，如果当前特权级CPL 低于任务的I/O 特权级IOPL，也并不意味着所有的硬件端口都对当前任务关上了大门。事实上，处理器的意思是总体上不允许，但个别端口除外。至于个别端口是哪些端口，要找到当前任务的TSS，并检索I/O 许可位串。

![I/O 许可位串](/images/assembly/io_bytes.png)

每个比特的取值决定了相应的端口是否允许访问。为1 时，禁止访问；为0 时，允许访问。同其他和任务相关的信息一样，I/O 许可位串位于任务的TSS 中。

如下图所示，任务状态段TSS 的最小长度是104 字节，这是包含基本信息的最小长度。整个TSS 还可以包括一个I/O 许可位串，它所占用的区域称为I/O 许可位映射区。在TSS 内偏移为102 的那个字单元，保存着I/O 许可位串（I/O 许可位映射区）的起始位置，从TSS 的起始处（0）算起。因此，如果该字单元的内容大于或者等于TSS 的段界限（在TSS 描述符中），则表明没有I/O 许可位串。必须在GDT 中创建TSS 的描述符，TSS 描述符中包括了TSS 的基地址和界限，该界限值包括I/O 许可位映射区在内。


![TSS 中的I/O 许可位映射区](/images/assembly/tss_with_io.png)

/O 端口是按字节编址的。这句话的意思是，每个端口仅被设计用来读写一个字节的数据，当以字或者双字访问时，实际上是访问连续的2 个或者4 个端口。这种操作方式直接导致了另一个问题。即，如果要检查的比特在最后一字节中，那么，这个两字节的读操作将会越界。为防止这种情况，处理器要求I/O 许可位映射区的最后必须附加一个额外的字节，并要求它的所有比特都是“1”，即0xFF。当然，它必须位于TSS 的界限之内。

显然，EFLAGS 寄存器中的IOPL 位对于控制任务的I/O 特权来说是很重要的。尽管不存在对EFLAGS 寄存器整体写入或者读出的指令，但存在将标志寄存器入栈和出栈的指令：popf pushf。通过将EFLAGS 寄存器的内容压入栈，局部修改后，再弹出到EFLAGS，可以间接地改变它的各种标志位。


能够修改这 IOPL 和 IF 两个标志的指令是: popf iret cli sti。另外，中断是由操作系统或者内核统一管理的，cli 和sti指令不能由低特权级的程序随便执行。遗憾的是，这些指令并不是特权指令，原因很简单，其他特权级的程序也离不开它们。最好的办法是用IOPL 本身来控制它们。如果当前特权级CPL 高于，或者和当前I/O 特权级IOPL 相同，则允许执行以上4 条指令，也允许访问所有的硬件端口。否则，如果当前特权级CPL 低于当前的I/O 特权级IOPL，则执行popf 和iret 指令时，会引发处理器异常中断；执行cli 和sti 时，不会引发异常中断，但不改变标志寄存器的IF 位。同时，是否能访问特定的I/O 端口，要参考TSS中的I/O 许可位映射串。

#### 创建任务状态段
```
         ;创建用户程序的TSS
         mov ecx,104                        ;tss的基本尺寸
         mov [es:esi+0x12],cx              
         dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
         call sys_routine_seg_sel:allocate_memory
         mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
      
         ;登记基本的TSS表格内容
         mov word [es:ecx+0],0              ;反向链=0
      
         mov edx,[es:esi+0x24]              ;登记0特权级堆栈初始ESP
         mov [es:ecx+4],edx                 ;到TSS中
         .....
       
         ;在GDT中登记TSS描述符
         mov eax,[es:esi+0x14]              ;TSS的起始线性地址
         movzx ebx,word [es:esi+0x12]       ;段长度（界限）
         mov ecx,0x00408900                 ;TSS描述符，特权级0
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [es:esi+0x18],cx               ;登记TSS选择子到TCB

         pop es                             ;恢复到调用此过程前的es段 
         pop ds                             ;恢复到调用此过程前的ds段
      
         popad
      
         ret 8                              ;丢弃调用本过程前压入的参数 
```

和局部描述符表（LDT）一样，也必须在GDT 中安装TSS 的描述符。这样做，一方面是为了对TSS 进行段和特权级的检查；另一方面，也是执行任务切换的需要。当call far 和jmp far 指令的操作数是TSS 描述符选择子时，处理器执行任务切换操作。

TSS 描述符中的B 位是“忙”位（Busy）。在任务刚刚创建的时候，它应该为二进制的1001，即，B 位是0，表明任务不忙。当任务开始执行时，或者处于挂起状态（临时被中断执行）时，由处理器固件把B 位置1。任务是不可重入的。在TSS 描述符中设置B 位，并由处理器固件进行管理，可以防止任务重入情况的发生。

### 4.11 带参数的过程返回指令
一旦ret 指令执行完毕，控制将返回到调用者，且栈中只剩下两个参数。如果希望过程在返回时弹出参数，使ESP 寄存器指向调用过程前的栈位置（使栈平衡），可以使用带操作数的过程返回指令：ret imm16/retf imm16 。立即数是16 位的指示在将控制返回到调用者之前，应当从栈中弹出多少字节的数据。

## 5. 用户程序的执行
接下来的工作是将控制转到用户程序那里。我们创建的是一个3 特权级的任务，所以这是一个从0 特权级到3 特权级的控制转移。或者，换一种更体面的说法，是从任务自己的0 特权级全局空间转移到3 特权级局部空间执行。通常情况下，这既不允许，也不太可能。办法总是有的，就是假装从调用门返回

### 5.1 通过调用门的控制转移和返回过程
先来看看完整的调用门控制转移和返回过程是怎样的。当通过调用门转移控制时，如果改变了当前的特权级别，则必须切换栈。在栈切换前，处理器要检查新栈是否有足够的空间完成本次控制转移。栈切换过程如下：(内容太长，此处省略)

### 5.2 进入3 特权级的用户程序的执行
任务寄存器TR 总是指向当前任务的任务状态段（TSS），而LDTR 寄存器也总是指向当前任务的LDT。TSS 是任务的主要标志，因此要使TR 寄存器指向任务；而使用LDTR 的原因是可以在任务执行期间加速段的访问。

而要进入用户程序，我们当前面临的问题是: 如何从任务的0 特权级全局空间转移到它自己的3 特权级空间正常执行？答案是先确立身份，即，使TR 和LDTR 寄存器指向这个任务，然后假装从调用门返回。

```
         ltr [ecx+0x18]                     ;加载任务状态段 
         lldt [ecx+0x10]                    ;加载LDT
      
         mov eax,[ecx+0x44]
         mov ds,eax                         ;切换到用户程序头部段 

         ;以下假装是从调用门返回。摹仿处理器压入返回参数 
         push dword [0x08]                  ;调用前的堆栈段选择子
         push dword 0                       ;调用前的esp

         push dword [0x14]                  ;调用前的代码段选择子 
         push dword [0x10]                  ;调用前的eip
      
         retf                  ; 执行一个远返回指令retf，假装从调用门返回。
```


![I/O 许可位串](/images/assembly/ldtr_tr.png)


TR 和LDTR 寄存器都包括16 位的选择器部分，以及的描述符高速缓存器部分。选择器部分的内容是TR 和LDT 描述符的选择子；描述符高速缓存器部分的内容则指向当前任务的TSS 和LDT。

加载任务寄存器TR 需要使用ltr 指令。在将TSS 选择子加载到TR 寄存器之后，处理器用该选择子访问GDT 中对应的TSS 描述符，将段界限和段基地址加载到任务寄存器TR 的描述符高速缓存器部分。同时，处理器将该TSS 描述符中的B 位置“1”，也就是标志为“忙”，但并不执行任务切换。

加载局部描述符表寄存器（LDTR）使用的是lldt 指令，其格式和ltr 是一样的。

最后，如下图所示，这是一个任务的全景图，给出了与一个任务相关的各个组成部分。

![与任务相关的各部分逻辑关系示意图](/images/assembly/task_info.png)

### 5.3 调整 RPL
处理器提供了arpl 指令。arpl 指令的作用是调整段选择子RPL 字段的值（Adjust RPL Field of Segment Selector），其格式为 arpl r/m16 r16。

该指令比较两个段选择子的RPL 字段，目的操作数可以是包含了16 位段选择子的通用寄存器，或者指向一个16 位单元的内存地址，该字单元里存放的是段选择子；源操作数只能是包含了段选择子的16 位通用寄存器。

该指令执行时，处理器检查目的操作数的RPL 字段，如果它在数值上小于源操作数的RPL 字段，则设置ZF 标志，并增加目的操作数RPL 字段的值，使之和源操作数RPL 字段的值相同。否则，ZF 标志清零，而且除此之外什么也不会发生。

arpl 是典型的操作系统指令，它通常用于调整应用程序传递给操作系统的段选择子，使其RPL 字段的值和应用程序的特权级相匹配。在这种情况下，传递给操作系统的段选择子是作为目的操作数出现的；而应用程序的段选择子是作为源操作数出现的（可以从栈中取得）。arpl 也可以在应用程序中使用。

这样，为了防止恶意的数据访问，操作系统应该从当前栈中取得用户程序的代码段选择子（调用者代码段寄存器CS 的内容）作为源操作数，并把作为参数传递进来的数据段选择子作为目的操作数，来执行arpl 指令，把数据段选择子的请求特权级RPL 调整（恢复）到调用者的特权级别上。