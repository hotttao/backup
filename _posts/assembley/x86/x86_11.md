---
title: 11. 任务和特权级保护
date: 2021-07-11
categories:
    - Go
tags:
	- x86 汇编
---

保护模式五
<!-- more -->

## 1. 内容概述
在保护模式下，通过将内存分成大小不等的段，并用描述符对每个段的用途、类型和长度进行指定，就可以在程序运行时由处理器硬件施加访问保护。段保护是处理器提供的基本保护功能，但对于现实的需求来说，仍是不够的。一个失控的程序，或者一个恶意的程序，依然可以通过追踪和修改描述符表来达到它们访问任何内存位置的目的。多任务系统，对任务之间的隔离和保护，以及任务和操作系统之间的隔离和保护都提出了要求，这可以看做对段保护机制的进一步强化。本章我们将介绍处理器的任务隔离和特权级，内容包括:
1. 任务的概念及其组成要素，包括任务的全局空间和局部空间、TSS、LDT、特权级等
2. 了解特别级不是指任务的特权级，而是指组成任务的各个部分的特权级。比如，任务的全局部分一般是0、1 和2 特权级别的，任务的私有部分一般是3 特权级别的
3. 理解CPL、DPL 和RPL 的含义，以及不同特权级别之间的控制转移规则
4. 熟悉调用门的用法

## 2. 任务
### 2.1 任务、任务的LDT 和TSS
![多任务系统的组成示意图](/images/assembly/task.png)

运行中的程序称为一个任务，如上图所示，为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，称为**局部描述符表LDT（Local Descriptor Table）**，并且把专属于自己的那些段放到LDT 中。

每个任务都有自己的LDT，每个任务私有的段，都应当在LDT 中进行描述。另外，LDT 的第1 个描述符，也就是0 号槽位，也是有效的、可以使用的。为了追踪和访问这些LDT，处理器使用了局部描述符表寄存器（LDT Register：LDTR）。因为LDTR 寄存器只有一个，所以，它只用于指向当前任务的LDT。每当发生任务切换时，LDTR 的内容被更新，以指向新任务的LDT。

段选择子的位2 是表指示器（Table Indicator：TI），若TI＝0，表示从GDT 中加载描述符；TI＝1，表示从当前任务的LDT 中加载描述符。

在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，以便在下次重新执行时恢复它们。为了保存任务的状态，每个任务都应当用一个额外的内存区域保存相关信息，这叫做**任务状态段（Task State Segment：TSS）**

#### TSS 格式
![TSS 格式](/images/assembly/tss.png)

如图所示，任务状态段TSS 具有固定的格式，最小尺寸是104 字节，图中所标注的偏移量是十进制的。处理器固件能够识别TSS 中的每个元素，并在任务切换的时候读取其中的信息。和LDT 一样，处理器用**TR 寄存器（Task Register：TR）**来指向当前任务的TSS。和GDTR、LDTR 一样，TR 寄存器在处理器中也只有一个。当任务切换发生的时候，TR 寄存器的内容也会跟着指向新任务的TSS。

任务切换时，处理器将当前任务的现场信息保存到由TR 寄存器指向的TSS；然后，再使TR 寄存器指向新任务的TSS，并从新任务的TSS 中恢复现场。

### 2.2 全局空间和局部空间
每个任务实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。

任务实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。地址空间的访问是依靠分段机制来进行的。

具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。

从程序员的角度来看，任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供的服务时，转入全局空间执行。

### 2.3 特权级
引入LDT 和TSS，只是从任务层面上进一步强化了分段机制，从安全保障的角度来看，只相当于构建了可靠的硬件设施。当然，仅有设施是不够的，还需要规章制度，还要有人来执行，处理器也一样。为此，**在分段机制的基础上，处理器引入了特权级**，并由固件负责实施特权级保护。

特权级（Privilege Level），也叫特权级别，是存在于**描述符及其选择子**中的一个数值。Intel 处理器可以识别4 个特权级别，分别是0 到3，较大的数值意味着较低的特权级别，如图所示，是Intel 处理器所提供的4 级环状保护结构。

![处理器的4 级环状保护结构](/images/assembly/privilege.png)

1. 特权级0是操作系统内核
2. 特权级1、2是系统服务程序，包括设备驱动程序
3. 特权级3是应用程序

实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们。每个描述符都有一个两比特的DPL 字段是**描述符特权级（Descriptor Privilege Level）**。描述符总是指向它所描述的目标对象，代表着该对象，因此，该字段实际上是目标对象的特权级。
1. 对于数据段来说，DPL 决定了访问它们所应当具备的最低特权级别。
2. 当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（Current Privilege Level，CPL）。正在执行的这个代码段，其选择子位于段寄存器CS 中，其最低两位就是当前特权级的数值。

操作系统的代码工作在0 特权级别上，当前特权级CPL 就是0，普通的应用程序则工作在特权级别3 上。这实际上就是把一个任务分成特权级截然不同的两个部分，全局部分是特权级0 的，而局部空间则是特权级3 的。那些只有在当前特权级CPL 为0 时才能执行的指令，称为特权指令（Privileged Instructions）。

### 2.4 输入输出特权级
除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O 操作进行控制。通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的。在处理器的标志寄存器EFLAGS 中，位13、位12 是IOPL 位，也就是输入/输出特权级（I/O Privilege Level），它代表着当前任务的I/O 特权级别。

![输入/输出特权级（I/O Privilege Level）](/images/assembly/io_privilege.png)

任务是由操作系统加载和创建的，与任务相关的信息都在它自己的任务状态段（TSS）中，其中就包括一个EFLAGS 寄存器的副本，用于指示与当前任务相关的机器状态。

处理器不限制0 特权级程序的I/O 访问，它总是允许的。但是，可以限制低特权级程序的I/O访问权限。

### 2.4 控制转移
代码段的特权级检查是很严格的。一般来说，控制转移只允许发生在两个特权级相同的代码段之间。不过，为了让特权级低的应用程序可以调用特权级高的操作系统例程，处理器也提供了相应的解决办法。

#### 依从代码段
第一种方法是将高特权级的代码段定义为依从的。这种方法具有如下特点:
1. 设置: 代码段描述符的TYPE 字段有C 位，如果C＝0，这样的代码段只能供同特权级的程序使用；否则，如果C＝1，则这样的代码段称为依从的代码段，可以从特权级比它低的程序调用并进入。
2. 控制转移条件: 要求**当前特权级CPL 必须低于，或者和目标代码段描述符的DPL 相同**。任何时候，都不允许将控制从较高的特权级转移到较低的特权级
3. 权限变化: 
    - 依从的代码段不是在它的 DPL 特权级上运行，而是在调用程序的特权级上运行
    - 即当控制转移到依从的代码段上执行时，不改变当前特权级CPL
    - 被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为“依从的”代码段
3. 理解: **因为高特权级的代码是操作系统可控的，所以可以进入，用户代码是不可控的所以不允许进入。而对数据段，操作系统的数据是机密，不允许随便访问。**

#### 调用门
另一种在特权级之间转移控制的方法是使用门。门（Gate）是另一种形式的描述符，称为门描述符，简称门。，段描述符用于描述内存段，门描述符则用于描述可执行的代码，比如一段程序、一个过程（例程）或者一个任务。

根据不同的用途，门的类型有好几种:
1. 不同特权级之间的过程调用可以使用调用门
2. 中断门/陷阱门是作为中断处理过程使用的
3. 任务门对应着单个的任务，用来执行任务切换

接下来我们先来介绍调用门。调用门具有如下特点:
1. 定义: 在调用门描述符中，定义了目标过程（例程）所在代码段的选择子，以及段内偏移。
2. 使用: 通过调用门进行控制转移，可以使用jmp far 或者call far 指令，并把调用门描述符的选择子作为操作数
    - jmp far 指令，可以将控制通过门转移到比当前特权级高的代码段，但**不改变当前特权级别**
    - call far 指令，则当前特权级会提升到目标代码段的特权级别。但是，除了从高特权级别的例程（通常是操作系统例程）返回外，不允许从特权级高的代码段将控制转移到特权级低的代码段，因为操作系统不会引用可靠性比自己低的代码。

调用门的设置我们后面在详述。

#### mbr 启动过程中的控制转移
特权级保护机制只在保护模式下才能启用，进入保护模式之后，处理器自动将当前特权级CPL 设定为0，以0 特权级的身份开始执行保护模式的初始指令。

### 2.5 RPL
RPL 的意思是请求特权级（Requested Privilege Level）。RPL 与 CPL 的区别在于，RPL 用于标识请求的真正来源。比如用户程序 C1 通过调用门进入操作系统的例程 A1 将磁盘读取到指定的数据段 DS 内。前面我们说到通过 call far 进行调用门控制转移时，CPL 会提升到目标代码的特权级别。此时 A1 是可以将磁盘数据写入操作系统数据段的。此时如果不区分请求的来源，就有可能出现用户程序破坏操作系统数据的情况。

![正常通过调用门读取数据到应用程序的数据段](/images/assembly/rpl_client.png)


![通过调用门读取数据到操作系统数据段](/images/assembly/rpl_core.png)

所以引入请求特权级（RPL）的原因是处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁。RPL 只是处理器和操作系统之间的一种协议，处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL；内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符，因为这是处理器无能为力的。

每当处理器执行一个将段选择子传送到段寄存器（DS、ES、FS、GS）的指令，会检查以下两个条件是否都能满足。
1. 当前特权级CPL 高于或者和**数据段描述符**的DPL 相同。
2. 请求特权级RPL 高于或者和数据段描述符的DPL 相同。

### 2.6 基本特权级检查
最后，我们来总结一下基本的特权级检查规则:
1. 首先，将控制直接转移到非依从的代码段，要求当前特权级CPL 和请求特权级RPL 都等于目标代码段描述符的DPL。
2. 其次，要将控制直接转移到依从的代码段，要求当前特权级CPL 和请求特权级RPL 都低于，或者和目标代码段描述符的DPL 相同，控制转移后，当前特权级保持不变。
3. 第三，高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。即要求当前特权级CPL 和请求特权级RPL 都必须高于，或者和目标数据段描述符的DPL 相同。
4. 最后，处理器要求，**在任何时候，栈段的特权级别必须和当前特权级CPL 相同**。

## 3. 调用门
### 3.1 调用门描述符格式
调用门（Call-Gate）用于在不同特权级的程序之间进行控制转移，该描述符的格式如下图所示:

![调用门描述符格式](/images/assembly/call_gate.png)

调用门描述符给出了例程所在代码段的选择子，有了段选择子，就能访问描述符表得到代码段的基地址，这样做无非是间接了一点，但却可以在**通过调用门进行控制转移时，实施代码段描述符有效性、段界限和特权级的检查**。描述符中的TYPE 字段用于标识门的类型，共4 比特，值“1100”表示调用门。

### 3.2 控制转移中的栈切换
通过调用门实施特权级之间的控制转移时，使用call far 指令会改变当前特权级CPL。因为栈段的特权级必须同当前特权级保持一致，因此，还要切换栈，即，从低特权级的栈切换到高特权级的栈。为了切换栈，每个任务除了自己固有的栈之外，还必须额外定义几套栈，具体数量取决于任务的特权级别。比如 特权级的任务最多额外定义3 个栈，描述符特权级分别是0、1 和2，在控制转移到0、1 和2 特权级时使用。这些额外创建的栈，其描述符位于任务自己的LDT 中。同时，还要在任务的TSS 中登记，原因是，栈切换是由处理器固件自动完成的，处理器需要根据TSS 中的信息来完成这一过程。

![TSS 格式](/images/assembly/tss.png)

在TSS 内，从偏移4～24 处登记有特权级0 到2 的栈段选择子，以及相应的ESP 初始值。任务自己固有的栈信息则位于偏移量为56（ESP）和80（SS）的地方。

通过调用门使用高特权级的例程服务时，调用者会传递一些参数给例程。如果参数是通过栈传递的，当栈切换时，参数还在旧栈中。为了使例程能获得参数，必须将参数从旧栈复制到新栈中。

参数的复制工作是由处理器固件完成的，但它必须事先知道参数的个数，并根据该数量决定复制多少内容。所以，调用门描述符中还有一个参数个数字段，共5 比特。就是说，至多允许传送31 个参数。

栈切换前，段寄存器 SS 指向的是旧栈，ESP 指向旧栈的栈顶，即最后一个被压入的过程参数；栈切换后，处理器自动替换SS 和ESP 寄存器的内容，使它们分别为新栈的选择子和新栈的栈顶（最后一个被复制的参数）。

### 3.3 调用门的控制转移规则
调用门描述符中的DPL 和目标代码段描述符的DPL 用于决定哪些特权级的程序可以访问此门，以下两个条件必须同时满足:
1. 当前特权级CPL 和请求特权级RPL 高于，或者和调用门描述符特权级DPL 相同。
1. 当前特权级CPL 低于，或者和目标代码段描述符特权级DPL 相同。
即，调用门的DPL 是特权级检查的下限，调用门描述符中的目标代码段描述符的DPL，决定了调用门特权级检查的上限。只有那些特权级低于或者等于目标代码段DPL 的程序才允许使用此门。

## 4. 加载用户程序并创建任务
### 4.1 TCB
在内核初始化完成后，接下来的工作就是加载和重定位用户程序（ 应用程序），并移交控制权。按处理器的要求标准，要使一个程序成为“任务”，必须要有LDT 和TSS。同时为了在任务之间切换和轮转，必须能追踪到所有正在运行的任务，记录它们的状态。

为了满足以上的要求，内核应当为每一个任务创建一个内存区域，来记录任务的信息和状态，称为任务控制块（Task Control Block，TCB）。如图所示，这是任务控制块的结构:

![TCB 格式](/images/assembly/tcb.png)

为了能够追踪到所有任务，应当把每个任务控制块TCB 串起来，形成一个链表。标号tcb_chain 并初始化为一个双字用于指向第一个任务，每个TCB 的第一个双字，也是一个双字长度的指针，用于指向下一个任务的TCB。。如果该位置是零，表示后面没有任务，这是链上的最后一个任务。

![任务控制块链](/images/assembly/tcb_chain.png)

### 4.2 使用栈传递参数
加载和重定位用户程序，依然是在过程load_relocate_program 中进行。该过程需要传入两个参数，分别是用户程序的起始逻辑扇区号，以及它的任务控制块TCB 线性地址。和上一章不同的是，参数不是用寄存器传入的，而是采用栈。再执行下面的代码后，栈的结构将如下图所示:

```
         push dword 50                      ;用户程序位于逻辑50扇区
         push ecx                           ;压入任务控制块起始线性地址 
       
         call load_relocate_program

load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入: PUSH 逻辑扇区号
                                            ;      PUSH 任务控制块基地址
                                            ;输出：无 
         pushad
      
         push ds
         push es
      
         mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
```

![栈的内存分布](/images/assembly/load_stack.png)

当前的栈顶位置是SS:EBP，指向一个双字，是段寄存器ES 的内容。按照参数的位置:
1. TCB 线性地址在栈中的位置是SS∶EBP＋44
2. 用户程序起始逻辑扇区号在栈中的位置是SS∶EBP＋48
