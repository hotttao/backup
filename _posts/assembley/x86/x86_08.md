---
title: 7. 进入保护模式
date: 2021-07-07
categories:
    - Go
tags:
	- x86 汇编
---

进入保护模式
<!-- more -->

## 1. 内容概述
上一节我们简单介绍了 32 位计算机保护模式的基本概念和基本术语，这一节我们将学习如何在保护模式下进行编程，内容包括:
1. 定义全局描述符表GDT，认识段描述符的各个组成部分以及它们的含义和作用。
2. 认识全局描述符表寄存器GDTR、段寄存器（由段选择器和描述符高速缓存器组成）、控制寄存器CR0 和段选择子
2. 了解进入32 位保护模式的方法和步骤。

### 2. 全局描述符表 GDT
出现全局描述符表 GDT 的逻辑是这样的:
1. 首先在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，与实模式不同的是，在每个段能够访问之前，必须先进行登记。并且当访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断。
2. 和一个段有关的信息需要8 个字节来描述，称为**段描述符（Segment Descriptor）**
3. 每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个**描述符表**。
4. 最主要的描述符表是**全局描述符表（Global Descriptor Table，GDT）**，因为是全局的，所以进入保护模式前，需要先定义 GDT。
5. 为了跟踪全局描述符表，处理器内部有一个48 位的寄存器，称为**全局描述符表寄存器（GDTR）**。如下图所示，它分为两部分，分别是32 位的线性地址和16 位的边界。32 位线性基地址部分保存的是全局描述符表在内存中的起始线性地址，16 位边界部分保存的是全局描述符表的边界（界限），其在数值上等于表的大小（总字节数）减一。

![GDT](/images/assembly/gdt.png)

GDT 的界限是16 位的，所以，该表最大是2^16 字节，也就是65536 字节（64KB）。又因为一个描述符占8 字节，故最多可以定义8192 个描述符。

理论上，全局描述符表可以位于内存中的任何地方。由于刚开机时，处理器是处于实模式中，在实模式下只能访问1MB 的内存，故GDT 通常都定义在1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。注意在 GDT 的设置必须在进入保护模式之前定义。

在 32 位实模式下之所以可以对用户程序进行保护，是因为:
1. 在保护模式下，在访问内存之前，必须先在GDT 内定义要访问的内存段
2. 而描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT 的，所以每个程序只能自己限定的范围内访问内存。

## 3. 段描述符
### 3.1 段描述格式
如下图所示，每个描述符在 GDT 中占8 字节，下面是低32 位，上面是高32 位。

![存储器的段描述符格式](/images/assembly/seg_desc.png)

1. 段基地址可以是0～4GB 范围内的任意地址，不过，还是建议应当选取那些16 字节对齐的地址。
2. 20 位的段界限用来限制段的扩展范围
    - 对于向上扩展的段，如代码段和数据段来说，偏移量是从0 开始递增，段界限决定了偏移量的最大值；
    - 对于向下扩展的段，如栈段来说，段界限决定了偏移量的最小值。
3. G 位是粒度（Granularity）位，用于解释段界限的含义
    - 当G 位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1 字节到1 兆字节（1B～1MB）
    - 当G 位是“1”，那么，段界限是以4KB 为单位的。这样，段的扩展范围是从4KB 到 4GB
7. D/B 位
    - 是“默认的操作数大小”（Default Operation Size）或者“默认的栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。
    - 设立该标志位，主要是为了能够在32 位处理器上兼容运行16 位保护模式的程序
    - 该标志位对不同的段有不同的效果。对于代码段，此位称做“D”位，用于指示指令中默认的偏移地址和操作数尺寸。D＝0 表示指令中的偏移地址或者操作数是16 位的；D＝1，指示32 位的偏移地址或者操作数。
    - 对于栈段来说，该位被叫做“B”位，用于在进行隐式的栈操作时，是使用SP 寄存器还是ESP 寄存器。B=0，表示使用使用SP 寄存器。
    - 同时，B 位的值也决定了栈的上部边界。如果B＝0，那么栈段的上部边界（也就是SP 寄存器的最大值）为0xFFFF；如果B＝1，那么栈段的上部边界（也就是ESP 寄存器的最大值）为0xFFFFFFFF。
8. L 位是64 位代码段标志（64-bit Code Segment），保留此位给64 位处理器使用
10. AVL 是软件可以使用的位（Available），通常由操作系统来用，可以理解为多余位
6. P 是段存在位（Segment Present）
    - P 位用于指示描述符所对应的段是否存在。
    - P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P 位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P 位置1。
5. DPL 表示描述符的特权级（Descriptor Privilege Level，DPL）
    - 共有4 种处理器支持的特权级别，分别是0、1、2、3，其中0 是最高特权级别，3 是最低特权级别。
    - 在这里，描述符的特权级用于指定要访问该段所必须具有的最低特权级。
    - 操作系统代码具有最高特权级0，用户程序特权级通常是 3
    - 不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0 特权级的程序来执行，为的就是安全。
4. S 位用于指定描述符的类型（Descriptor Type）。
    - 当该位是“0”时，表示是一个系统段；
    - 为“1”时，表示是一个代码段或者数据段（栈段也是特殊的数据段）
9. TYPE 字段共4 位，用于指示描述符的子类型，如下图所示，对于数据段来说，这4 位分别是X、E、W、A 位；而对于代码段来说，这4 位则分别是X、C、R、A 位。

![段描述符 TYPE 位](/images/assembly/seg_type.png)

TYPE 位中:
1.  表示是否可以执行（eXecutable）
    - 数据段总是不可执行的，X＝0；
    - 代码段总是可以执行的，因此，X＝1
2. E 位指示段的扩展方向
    - E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；
    - E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是栈段
3. W 位指示段的读写属性，或者说段是否可写
    - W＝0 的段是不允许写入的，否则会引发处理器异常中断；
    - W ＝1 的段是可以正常写入的
4. C 位指示段是否为特权级依从的（Conforming）
    - C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；
    - C＝1 表示允许从低特权级的程序转移到该段执行
5. R 位指示代码段是否允许读出
    - R＝0 表示不能读出，如果企图去读一个R＝0 的代码段，会引发处理器异常中断；
    - R＝1，则代码段是可以读出的，即可以把这个段的内容当成ROM 一样使用
    - 这里的R 属性并非用来限制处理器，而是用来限制程序和指令的行为。一个典型的例子是使用段超越前缀“CS:”来访问代码段中的内容
6. A 位是已访问（Accessed）位，用于指示它所指向的段最近是否被访问过。
    - 在描述符创建的时候，应该清零
    - 每当该段被访问时，处理器自动将该位置“1”
    - 对该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率
    - 当内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理

## 4. 安装存储器的段描述符并加载GDTR
现在开始安装各个描述符:

```
         ;设置堆栈段和栈指针 
         mov ax,cs      
         mov ss,ax
         mov sp,0x7c00
      
         ;计算GDT所在的逻辑段地址 
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16        
         div bx            
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
      
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

         ;创建#1描述符，保护模式下的代码段描述符
         mov dword [bx+0x08],0x7c0001ff     
         mov dword [bx+0x0c],0x00409800     

         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） 
         mov dword [bx+0x10],0x8000ffff     
         mov dword [bx+0x14],0x0040920b     

         ;创建#3描述符，保护模式下的堆栈段描述符
         mov dword [bx+0x18],0x00007a00
         mov dword [bx+0x1c],0x00409600

         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一）   
                                             
         lgdt [cs: gdt_size+0x7c00]
         
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 

         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器 
         [bits 32] 
    flush:
         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx
         ............

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
```

#### lgdt
加载描述符表的线性基地址和界限到 GDTR 寄存器，要使用lgdt 指令。lgdt 指令格式为 `lgdt m48`:
1. 该指令的操作数是一个48 位（6字节）的内存区域。在16 位模式下，该地址是16 位的；在32 位模式下，该地址是32 位的。
2. 在这6 字节的内存区域中，要求前（低）16 位是GDT 的界限值，后（高）32 位是GDT 的基地址。
3. 在初始状态下（计算机启动之后），GDTR 的基地址被初始化为0x00000000；界限值为0xFFFF。

## 5.模式切换
lgt 之后我们已经达到了是模式与保护模式的分界线，而控制这两种模式切换的开关是在一个叫CR0 的寄存器中。CR0 是处理器内部的控制寄存器（Control Register，CR）包含了一系列用于控制处理器操作模式和运行状态的标志位。它的第1 位（位0）是保护模式允许位（Protection Enable，PE），如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。代码如下:

```
         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
```

保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS 中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断。

## 6. 实模式下的段访问
8086 处理器的段寄存器是16 位的，共有4 个：CS、DS、ES 和SS。而在32 位处理器内，在原先的基础上又增加了两个段寄存器FS 和GS。而这 6 个段寄存器又分为两部分:
1. 前16 位和8086 相同，用于向后兼容
2. 第二部分称为描述符高速缓存器，用来存放段的线性基地址、段界限和段属性。这一部分不可见的部分，由处理器内部进行访问
![段描述符 TYPE 位](/images/assembly/seg_cache.png)

实模式下的6 个段寄存器CS、DS、ES、FS、GS 和SS，在保护模式下叫做段选择器。保护模式下尽管访问内存时也需要指定一个段，但传送到段选择器的内容不是逻辑段地址，而是段描述符在描述符表中的索引号，又称**段选择子**。

段选择子的格式如下:
1. 第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。
2. TI 是描述符表指示器（Table Indicator）
    - TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中
    - RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。

![段描述符 TYPE 位](/images/assembly/seg_select.png)

```
    flush:
         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx

         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'
```

上面的代码中，将描述符选择子0x0010（二进制数0000_0000_ 00010_0_00）传送到段选择器DS 中，0x0010 指定的描述符索引号是2，指定的描述符表是GDT，请求特权级RPL 是00。

### 6.1 段加载过程
当处理器在执行任何改变段选择器的指令时（比如pop、mov、jmp far、call far、iret、retf），就将指令中提供的索引号乘以8 作为偏移地址，同GDTR 中提供的线性基地址相加，以访问GDT。如果没有发现什么问题（比如超出了GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。

加载的部分包括段的线性基地址、段界限和段的访问属性。此后，每当有访问内存的指令时，就不再访问GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址

## 7. 清空流水线
我们在讲解上面的汇编代码时，跳过了两条指令:

```
         ;以下进入保护模式... ...
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器 
         [bits 32] 
```

这两条指令是干嘛的呢？我们通过 CR0 寄存器从实模式切换到了保护模式，看似切换已经完成，但是仍有两个亟待解决的问题。
1. 在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20 位有效，高12 位是全零。当处理器进入保护模式后，这些内容依然残留着，但不影响使用，程序可以继续执行。但是，这些残留的内容在保护模式下是无效的，迟早会在执行某些指令的时候出问题。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS 和GS 的内容，包括它们的段选择器和描述符高速缓存器。
2. 在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16 位操作数和16 位地址长度进行译码的，即使是那些用bits 32 编译的指令。进入保护模式后，受CS 段描述符高速缓存器中实模式残留内容的影响，处理器进入16 位保护模式工作。如果保护模式下的代码是16 位的，影响可能不大，但如果是用bits 32 编译的，那么，由于对对操作数和默认地址大小的解释不同，指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。

这里有一个两全其美的方案，那就是使用远转移指令jmp 或者远过程调用指令call。处理器最怕转移指令，遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。一个建议的方法是在设置了控制寄存器CR0 的PE 位之后，立即用jmp 或者call 转移到当前指令流的下一条指令上。

`jmp dword 0x0008:flush`

这条指令和位于它前面的指令一样，默认地是用“bits 16”编译的，而且使用了关键字“dword”，该关键字修饰偏移地址，意思是要求使用32 位的偏移量。因此，会有指令前缀0x66。

因为现在已经处于保护模式下，处理器都将把第一个操作数0x0008 视为段选择子，而不是实模式下的逻辑段地址。选择子为0x0008（索引号为1，TI 位是0，RPL 为00）。当指令执行时，处理器加载段选择器CS，从GDT 中取出相应的描述符加载到CS 描述符高速缓存。

保护模式下的代码段，基地址为0x00007c00，段界限为0x1ff，长度为0x200，正好对应着当前程序在内存中的区域。在这种情况下，上面那条指令执行时，目标位置在段内的偏移量就是标号flush 的汇编地址，处理器用它的数值来代替指令指针寄存器EIP 的原有内容。

`[bits 32]`

进入保护模式开始，之后的指令都应当是按32 位操作数方式编译的。因此，第53 行，使用了伪指令[bits 32]。当处理器执行到这里时，它会按32 位模式进行译码。

最后注意在保护模式下，不允许使用mov 指令改变段寄存器CS 的内容

## 8. 保护模式下的栈
栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。
1. 对于向上扩展的段，段内偏移量是从0 开始递增，偏移量的最大值是界限值和粒度的乘积；
2. 而对于向下扩展的段来说，段内偏移量的最小值是界限值和粒度的乘积加一。

栈操作时，必须符合条件：`ESP > 段界限 * 粒度值`

