---
title: 4. x86 实模式(一)
date: 2021-07-04
categories:
    - Go
tags:
	- x86 汇编
---

CPU 实模式(一)
<!-- more -->

## 1. 内容概述
按照 CPU 功能升级迭代的顺序，CPU 的工作模式有实模式、保护模式、长模式。今天我们就来学习最基本的实模式，通过实模式我们将了解:
1. 内存分段使用机制
2. 过程调用和栈
3. 中断和外围设备的访问，包括常见设备的使用原理
4. 操作系统加载用户程序并实施重定位的一般原理

接下来我们通过一个示例: 如何在屏幕上显示文字来学习一些基本的汇编指令和程序法分段机制。

## 2. 在屏幕上显示文字
为了显示文字，通常需要两种硬件，一是显示器，二是显卡:
1. 显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态
2. 显示器的职责是将那些内容以视觉可见的方式呈现在屏幕上

显卡控制显示器的最小单位是像素，一个像素对应着屏幕上的一个点。屏幕上通常有数十万乃至更多的像素，通过控制每个像素的明暗和颜色，我们就能让这大量的像素形成文字和美丽的图像。

显卡都有自己的存储器，因为它位于显卡上，故称显示存储器（Video RAM：VRAM），简称显存。显存的第1 个字节对应着屏幕左上角连续的8 个像素；第2 个字节对应着屏幕上后续的8 个像素，后面的以此类推。

显卡有**文本模式**和**图形模式**两种基本工作模式，可以用指令访问显卡，设置它的显示模式。不同的工作模式下，显卡对显存内容的解释是不同的。

### 2.1 图形模式
在图形模式下，显卡周期性地从显存中提取这些比特，并把它们按顺序显示在屏幕上，如下图所示，显存中，第1 个字节的内容是11110000，屏幕左上角先是显示4 个亮点，再显示4 个黑点。

![显存的图形模式](/images/assembly/video.png)

黑色和白色只需要1 个比特就能表示，但要显示更多的颜色，1 个比特就不够了。现在最流行的，是用24 个比特，即3 个字节，来对应一个像素。

### 2.2 文字模式
操作显存里的比特，使得屏幕上能显示出字符的形状，是非常麻烦，工程师们设计了文字模式，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化到80× 25 的文本模式。在这种模式下，屏幕上可以显示25 行，每行80 个字符，每屏总共2000 个字符。如下图所示，为了给出要显示的字符，处理器只需要访问显存，把字符的 ASCII 码写进去。第1 个代码对应着屏幕左上角第1 个字符，第2 个代码对应着屏幕左上角第2 个字符，然后由字符发生器和控制电路来控制屏幕上的像素。

![显存的文字模式](/images/assembly/video_text.png)

前面我们介绍了 8086 的内存地址空间，因此只需要将字符的 ASCII 码写入显存映射的内存空间，就可以将字符ASCII码写入显存，从而往显卡在屏幕上显示对应的字符。如图所示，8086 可以访问1MB 内存。其中:
1. 0x00000～9FFFF 属于常规内存，由内存条提供；
2. 0xF0000～0xFFFFF 由主板上的一个芯片提供，即ROM-BIOS。
3. 中间还有一个320KB 的空洞，即0xA0000～0xEFFFF，这段地址空间由特定的外围设备来提供，其中就包括显卡。
4. 0xB8000～0xBFFFF 这段物理地址空间，就是留给显卡的，由显卡来提供，用来显示文本。

由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化到80× 25 的文本模式。在这种模式下，屏幕上可以显示25 行，每行80 个字符，每屏总共2000 个字符。

![内存地址空间](/images/assembly/memory_address.png)

和访问主内存一样，为了访问显存，也需要使用逻辑地址，也就是采用“段地址：偏移地址”的形式，文本模式下显存的起始物理地址是0xB8000，这块内存可以看成是段地址为0xB800，偏移地址从0x0000 延伸到0xFFFF 的区域，因此我们可以把段地址定为0xB800。(这里介绍的显存映射的内存地址空间与前面所说的范围 A0000-BFFFF 不同，应该是文字模式和图形模式之间的差别，并没有求证。)

用于初始化访问显存的汇编代码如下:

```assembley
mov ax,0xb800                 ;使用 ES 来指向显存所在的段
mov es,ax
```

#### 显示字符

用于显示字符的 ASCII 码这里就不过多介绍，不过需要了解的是，屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的ASCII 代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）

![显存的文字模式](/images/assembly/video_text_show.png)

如图所示，字符的显示属性（1 字节）分为两部分，低4 位定义的是前景色，高4 位定义的是背景色。色彩主要由红（R）、绿（G）、蓝（B）这3 位决定，K 是闪烁位，为0 时不闪烁，为1 时闪烁；I 是亮度位，为0时正常亮度，为1 时呈高亮。屏幕上什么都没有时，显示的全是黑底白字的空白字符，也叫空格字符（Space），ASCII代码是0x20。

下面是显示字符的汇编代码示例:

```assembley
mov byte [es:0x00],'L' ;等效于 mov byte [es:0x00],0x4c
mov byte [es:0x01],0x07
```

可以使用字符的字面值，这个字符必须用引号围起来，就像上面一样。在源程序的编译阶段，汇编语言编译器会将它转换成ASCII 码的形式。如果没有附加任何指示，段地址默认在段寄存器DS，显存的段地址位于段寄存器ES 中，因此，这里使用了段超越前缀“es:”

还需要注意的是，因为目的操作数给出的是一个内存地址，我们要用源操作数来修改这个地址里的内容，所以，目的操作数必须用方括号围起来，以表明它是一个地址，处理器应该用这个地址再次访问内存，将源操作数写进这个单元。实际上，这类似于高级语言里的指针。

最后，关键字“byte”用来修饰目的操作数，指出本次传送是以字节的方式进行的。在16 位的处理器上，单次操作的数据宽度可以是8 位，也可以是16 位。到底是8 位，还是16 位，可以根据目的操作数或者源操作数(即使用的寄存器的宽度)来判断。如果无法判断必须用“byte”或者“word”进行修饰。

### 2.3 示例代码
```assembley
         ;代码清单5-1 
         ;文件名：c05_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2011-3-31 21:15 
         
         mov ax,0xb800                 ;指向文本模式的显示缓冲区
         mov es,ax

         ;以下显示字符串"Label offset:"
         mov byte [es:0x00],'L'
         mov byte [es:0x01],0x07
         mov byte [es:0x02],'a'
         mov byte [es:0x03],0x07
         mov byte [es:0x04],'b'
         mov byte [es:0x05],0x07
         mov byte [es:0x06],'e'
         mov byte [es:0x07],0x07
         mov byte [es:0x08],'l'
         mov byte [es:0x09],0x07
         mov byte [es:0x0a],' '
         mov byte [es:0x0b],0x07
         mov byte [es:0x0c],"o"
         mov byte [es:0x0d],0x07
         mov byte [es:0x0e],'f'
         mov byte [es:0x0f],0x07
         mov byte [es:0x10],'f'
         mov byte [es:0x11],0x07
         mov byte [es:0x12],'s'
         mov byte [es:0x13],0x07
         mov byte [es:0x14],'e'
         mov byte [es:0x15],0x07
         mov byte [es:0x16],'t'
         mov byte [es:0x17],0x07
         mov byte [es:0x18],':'
         mov byte [es:0x19],0x07

         mov ax,number                 ;取得标号number的偏移地址
         mov bx,10

         ;设置数据段的基地址
         mov cx,cs
         mov ds,cx

         ;求个位上的数字
         mov dx,0
         div bx
         mov [0x7c00+number+0x00],dl   ;保存个位上的数字

         ;求十位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x01],dl   ;保存十位上的数字

         ;求百位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x02],dl   ;保存百位上的数字

         ;求千位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x03],dl   ;保存千位上的数字

         ;求万位上的数字 
         xor dx,dx
         div bx
         mov [0x7c00+number+0x04],dl   ;保存万位上的数字

         ;以下用十进制显示标号的偏移地址
         mov al,[0x7c00+number+0x04]
         add al,0x30
         mov [es:0x1a],al
         mov byte [es:0x1b],0x04
         
         mov al,[0x7c00+number+0x03]
         add al,0x30
         mov [es:0x1c],al
         mov byte [es:0x1d],0x04
         
         mov al,[0x7c00+number+0x02]
         add al,0x30
         mov [es:0x1e],al
         mov byte [es:0x1f],0x04

         mov al,[0x7c00+number+0x01]
         add al,0x30
         mov [es:0x20],al
         mov byte [es:0x21],0x04

         mov al,[0x7c00+number+0x00]
         add al,0x30
         mov [es:0x22],al
         mov byte [es:0x23],0x04
         
         mov byte [es:0x24],'D'
         mov byte [es:0x25],0x07
          
   infi: jmp near infi                 ;无限循环
      
  number db 0,0,0,0,0
  
  times 203 db 0
            db 0x55,0xaa
```

大多数代码都比较直观，但是有以下需要注意的几个点:
1. `infi: jmp near infi`: 表示无限循环
    - infi 是一个标号，以代表和指示该指令的汇编地址
    - 标号之后的冒号是可选的，也单独占用一行的位置
    - jmp 是代码跳转指令，关键字near表示目标位置依然在当前代码段内
    - jmp near 对应的是一个3 字节指令，操作码是0xE9，后跟一个16 位（两字节）的操作数。但是，该操作数并非目标位置的偏移地址，而是目标位置相对于当前指令处的偏移量（以字节为单位）。在编译阶段，编译器是这么做的：用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3），在指令执行阶段，处理器用指令指针寄存器IP 的内容加上该指令的操作数，再加上该指令的长度（3），就得到了要转移的实际偏移地址，同时CS 寄存器的内容不变。
    - jmp 是如何区分绝对地址跳转还是相对跳转呢？很简单，当它看到JMP 之后是一个绝对地址，如0xF000:0x2000 时，它就知道应当编译成使用操作码0xEA 的直接绝对转移指令。相反地，如果它发现JMP 之后是一个标号，那么，它就会编译成使用操作码为0xE9 的相对转移指令。关键字“near”不是最主要的，它仅仅用于指示相对量是16 位的。
2. `db 0,0,0,0,0`: 在程序中声明并初始化数据
    - DB 的意思是声明字节（Declare Byte）
    - DW（Declare Word）用于声明字数据
    - DQ（Declare Quad Word）用于声明四字数据
    - DB、DW、DD 和DQ 并不是处理器指令，它只是编译器提供的汇编指令
    - 和指令不同，对于在程序中声明的数值，在编译阶段，编译器会在它们被声明的汇编地址处原样保留
3. `mov dx,0 - div bx`: 32 位除法
    - 通常用“DX:AX”来描述32 位的被除数
    - div 指令用DX:AX 作为被除数，除以BX 的内容，执行后得到的商在AX 中，余数在DX 中。因为除数是10，余数自然比10 小，我们可以从DL 中取得
    - `xor dx,dx ` 用于将 dx 清零
4. `mov al,[0x7c00+number+0x01]`:
    - 0x7c00 的由来是，主引导扇区代码是被加载到0x0000:0x7C00 处的，而非0x0000:0x0000
5. `db 0x55,0xaa`:
    - 一个有效的主引导扇区，其最后两个字节的数据必须是0x55 和0xAA
    - 如果采用dw 版本，应该这样写：dw 0xaa55，因为，在Intel 处理器上，将一个字写入内存时，是采用低端字节序的，低字节0x55 置入低地址端（在前），高字节0xAA 在高地址端（在后）
6. `times 203 db 0`
    - 伪指令times 可用于重复它后面的指令若干次。用于将代码填充到正好一个扇区大小(512bytes)

### 2.4 示例代码的改进
上面的代码，有一些"问题"，下面是其改进后的版本:

```assembley
         ;代码清单6-1
         ;文件名：c06_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2011-4-12 22:12 
      
         jmp near start
         
  mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\
            'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
  number db 0,0,0,0,0
  
  start:
         mov ax,0x7c0                  ;设置数据段基地址 
         mov ds,ax
         
         mov ax,0xb800                 ;设置附加段基地址 
         mov es,ax
         
         cld
         mov si,mytext                 
         mov di,0
         mov cx,(number-mytext)/2      ;实际上等于 13
         rep movsw
     
         ;得到标号所代表的偏移地址
         mov ax,number
         
         ;计算各个数位
         mov bx,ax
         mov cx,5                      ;循环次数 
         mov si,10                     ;除数 
  digit: 
         xor dx,dx
         div si
         mov [bx],dl                   ;保存数位
         inc bx 
         loop digit
         
         ;显示各个数位
         mov bx,number 
         mov si,4                      
   show:
         mov al,[bx+si]
         add al,0x30
         mov ah,0x04
         mov [es:di],ax
         add di,2
         dec si
         jns show
         
         mov word [es:di],0x0744

         jmp near $

  times 510-($-$$) db 0
                   db 0x55,0xaa
```

改进的地方有以下几点:
1. 数据段的起始地址改为 0x7c0，避免了 0x7c00+number 这种重复硬编码
2. `rep movsw`: 
    - 使用 movsb 或者 movsw 指令进行数据传送
    - movsb 每次传送一个字节
    - movsw 每次传送一个字
    - 指令前缀rep（repeat），意思是CX 不为零则重复。rep movsw 的操作码是0xF3 0xA5，它将重复执行movsw 直到CX 的内容为零。
3. loop: 使用循环分解数位
4. `jns show`: 条件跳转指令，另一种循环表示
5. `jmp near $`: 无线循环指令
    - NASM 编译器提供了一个标记“$”，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的标号。
    - 因此，jmp near $的意思是，转移到当前指令继续执行
5. `times 510-($-$$) db 0`
    - $是当前行的汇编地址；$$是NASM 编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。
    - 当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是0（程序起始处）

接下来分别来介绍这些指令的详细用法。

## 3. 常用指令
### 3.1 movsw/movsb
movsw/movsb: 用于把数据从内存中的一个地方批量地传送（复制）到另一个地方 movsb 和 movsw 指令执行时:
- 原始数据串的段地址由DS 指定，偏移地址由SI 指定，简写为DS:SI；
- 要传送到的目的地址由ES:DI 指定；
- 传送的字节数（movsb）或者字数（movsw）由CX指定。
- 还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的低地址端到高地址端，反向传送则正好相反。正反向由 FLAG 寄存器的 DF 位设置，如下图所示

![mvsw 影响的 FLAG 寄存器](/images/assembly/mvsw.png)

在8086 处理器里，有一个特殊的寄存器，叫做标志寄存器FLAGS。作为一个例子，它的第6 位是ZF（Zero Flag），即零标志。当处理器执行一条算术或者逻辑运算指令后，算术逻辑部件送出的结果除了送到指令中指定位置（目的操作数指定的位置）外，还送到一个或非门。或非门的输出送到一个触发器，这就是标志寄存器的ZF 位。这就是说，如果计算结果为0，这一位被置成1，表示计算结果为零是“真”的；否则清除此位（0）。

源程序第19 行是方向标志清零指令cld。这是个无操作数指令，与其相反的是置方向标志指令std。cld 指令将DF 标志清零，以指示传送是正方向的。和cld 功能相反的是std 指令，它将DF标志置位（1）。此时，传送的方向是从高地址到低地址。

### 3.2 loop
loop 指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事：
1. 将 CX 寄存器减去 1
2. 如果 CX 不为 0，执行跳转，否则继续往下执行

```
  digit: 
         xor dx,dx
         div si
         mov [bx],dl                   ;保存数位
         inc bx 
         loop digit
```

loop digit 指令，它的机器指令操作码是0xE2，后面跟着一个字节的操作数，而且也是相对于标号处的偏移量，是在编译阶段，编译器用标号digit 所在位置的汇编地址减去loop 指令的汇编地址，再减去loop 指令的长度（2）来得到的。

### 3.3 8086 的通用寄存器
8086 处理器内部有8 个16 位的通用寄存器，分别被命名为AX、BX、CX、DX、SI、DI、BP、SP。，其中:
1. 寄存器BX 最初的功能之一就是用来提供数据访问的基地址，所以又叫基址寄存器（Base Address Register）。
2. AX是累加器（Accumulator），与它有关的指令还会做指令长度上的优化（较短）；
3. CX 是计数器（Counter）；
4. DX 是数据（Data）寄存器，除了作为通用寄存器使用外，还专门用于和外设之间进行数据传送；
5. SI 是源索引寄存器（Source Index）；
6. DI 是目标索引寄存器（Destination Index），用于数据传送操作，

像上面 `mov [bx],dl` 一样，要用寄存器来提供偏移地址，只能使用BX、SI、DI、BP，不能使用其他寄存器。像 `mov al,[bx+si]` SI 的作用相当于索引，因此它被称为索引寄存器（Index Register），或者叫变址寄存器。另一个常用的变址寄存器是DI。注意，INTEL8086 处理器只允许以下几种基址寄存器和变址寄存器的组合：
- `[bx+si]`
- `[bx+di]`
- `[bp+si]`
- `[bp+di]`

### 3.5 负数的表示
在计算机中如何表示负数呢。-1 = 0 - 1，所以计算机使用二进制数 0 减去二进制数 1 来表示 -1，相减的过程要向左借位直至截断。你会发现，0x80 既是十进制数128，又是十进制数-128，为此计算机中的数分成两大类：无符号数和有符号数。有符号数是分正、负的，而且规定，数的正负要通过它的最高位来辨别。如果最高位是0，它就是正数；如果是1，就是负数。

正的有符号数，和与它同值的无符号数相同。但是，负数就不同了，在这里，10000000～11111111 这些负数，都是用0减去它们相对应的正数得到的。想知道它们各自对应的正数是谁吗？很简单，因为“负数的负数”是正数，所以只需要用0 减去这个负数就行。8086 处理器中，neg 只能专门用来实现这个功能: 用 0 减去指令中指定的操作数。

一个8 位的有符号数，要想用16 位的形式来表示，只需将其最高位，也就是用来辨别符号的那一位（几乎所有的书上都称之为符号位，实际上这并不严谨），扩展到高8 位即可。为了方便，处理器专门设计了两条指令来做这件事：cbw（Convert Byte to Word）和cwd（Convert Word to Double-word）。

### 3.4 jns 条件跳转
指令jns show 的意思是，如果未设置符号位，则转移到标号“show”所在的位置处执行，如果计算结果的最高位是比特“0”，处理器把SF 位置“0”，否则SF 位置“1”。所以上面代码的逻辑是，如果 si 未被剪成负数，则跳转到 digit。

jns 是条件转移指令，处理器在执行它的时候要参考标志寄存器的SF 位。除了只是在符合条件的时候才转移之外，它和jmp 指令很相似，它也是相对转移指令，编译后的机器指令操作数也是一个相对偏移量，是用标号处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度得到的。

#### FLAG 寄存器的其他位
除了上面介绍的 SF 符号位，ZF 零位。FLAG 寄存器还有下面一些标志位
1. 零位 ZF: 如果计算结果为0，这一位被置成1，表示计算结果为零是“真”的；否则清除此位（0）。
1. 奇偶标志位PF: 最低8 位中，有偶数个为1 的比特，则PF=1；否则PF=0。
2. 进位标志CF: 
    - 如果最高位有向前进位或借位的情况发生，则CF=1；否则CF=0
    - CF 标志始终忠实地记录进位或者借位是否发生，但少数指令除外（如inc 和dec）
3. 溢出标志OF: 
    - 对于无符号数运算来说，进位标志CF 通常意味着得到了错误的计算结果，因为目的操作数没能容纳那个进位。
    - 但是对于有符号数运算，进位的是否导致溢出是不确定的，比如 112+112=-32 将导致溢出，但是 -1 + 2 并没有溢出。如果运算结果是正确的，那么OF=0，否则OF=1

#### 条件转移指令
“jcc”不是一条指令，而是一个指令族（簇），功能是根据某些条件进行转移，比如:
1. jns，意思是SF≠1（那就是SF=0 了）则转移
2. js 是 jns 相反的指令，意思是SF=1 则转移
3. jz 的意思是ZF 标志为1 则转移；jnz 的意思是ZF 标志不为1（为0）则转移。
4. jo 的意思是OF 标志为1 则转移，jno 的意思是OF 标志不为1（为0）则转移。
5. jc 的意思是CF 标志为1 则转移，jnc 的意思是CF 标志不为1（为0）则转移。
6. jp 的意思是PF 标志为1 则转移，jnp 的意思是PF 标志不为1（为0）则转移

转移指令必须出现在影响标志的指令之后。但是通常情况下，我们的转移条件并不是某个标志位达到 0，比如AX等于0x30，好在 CPU  提供了 cmp 指令，cmp，它需要两个操作数。

cmp 指令在功能上和sub 指令相同，唯一不同之处在于，cmp 指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果，因此也就不会改变两个操作数的原有内容。cmp 指令将会影响到CF、OF、SF、ZF、AF 和PF 标志位。

cmp ax,bx 来说，我们关心的是AX 中的内容是否等于BX 中的内容，AX 是被测量的对象，BX 是测量的基准。cmp 指令设置完相应标志位之后，我们就可以使用如下的跳转指令进行指令跳转了。

![jcc指令](/images/assembly/jcc.png)

最后一个要讲述的条件转移指令是jcxz（jump if CX is zero），意思是当CX 寄存器的内容为零时则转移。执行这条指令时，处理器先测试寄存器CX 是否为零。如果CX 寄存器的内容为零，则转移；否则不转移，继续往下执行。
