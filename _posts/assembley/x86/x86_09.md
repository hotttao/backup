---
title: 9. 存储器的保护
date: 2021-07-09
categories:
    - Go
tags:
	- x86 汇编
---

保护模式三
<!-- more -->

## 1. 内容概述
存储器的保护功能可以禁止程序的非法内存访问。本章我们将通过实例来认识处理器是如何进行存储器的保护的。内容包括:
1. 段别名
2. 修改段寄存器时的保护
3. 地址变换时的保护

## 2. 段别名
在保护模式下，代码段是不可写入的。所谓不可写入，并非是说改变了内存的物理性质，使得内存写不进去，而是说，通过该段的描述符来访问这个区域时，处理器不允许向里面写入数据或者更改数据。

如果需要访问代码段内的数据，只能重新为该段安装一个新的描述符，并将其定义为可读可写的数据段。这样，当需要修改代码段内的数据时，可以通过这个新的描述符来进行。像下面这样:

```
         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;创建以上代码段的别名描述符
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符
```

像这样，当两个以上的描述符都描述和指向同一个段时，把另外的描述符称为别名（alias）。别名技术并非仅仅用于读写代码段，如果两个程序想共享同一个内存区域，可以分别为每个程序都创建一个描述符，而且它们都指向同一个内存段，这也是别名应用的例子。


## 3. 修改段寄存器时的保护
```
         jmp dword 0x0010:flush
         mov eax,0x0018                      
         mov ds,eax
      
         mov eax,0x0008                     ;加载数据段(0..4GB)选择子
         mov es,eax
         mov fs,eax
         mov gs,eax
```

以上的指令涉及所有段寄存器，当这些指令执行时，处理器把指令中给出的选择子传送到段寄存器的选择器部分。但是，处理器的固件在完成传送之前，需要进行一系列的检查:

首先是段选择的界限检查，换句话说，处理器从GDT 中取某个描述符时，就要求描述符的8 个字节都在GDT 边界之内，也就是索引号×8＋7 小于等于边界。如果检查到指定的段描述符，其位置超过表的边界时，处理器中止处理，产生异常中断13，同时段寄存器中的原值不变。

然后，检查描述符的类别是否和段寄存器的用途匹配。检查规则如下:

![描述符的类别是否和段寄存器的用途匹配检查](/images/assembly/seg_check.png)

最后还要检查描述符中的P 位。如果P＝0，表明虽然描述符已被定义，但该段实际上并不存在于物理内存中。此时，处理器中止处理，引发异常中断11。一般来说，应当定义一个中断处理程序，把该描述符所对应的段从硬盘等外部存储器调入内存，然后置P 位。中断返回时，处理器将再次尝试刚才的操作。如果P＝1，则处理器将描述符加载到段寄存器的描述符高速缓存器，同时置A 位。

显然，只有可以写入的数据段才能加载到SS 的选择器，CS 寄存器只允许加载代码段描述符。

## 4. 地址变换时的保护
### 4.1 代码段执行时的保护
每个代码段都有自己的段界限，位于其描述符中。当处理器在该段内取指令执行时，偏移地址由EIP 提供。指令很有可能是跨越边界的，一部分在边界之内，一部分在边界之外，或者一条单字节指令正好位于边界上。因此，要执行的那条指令，其长度减1 后，与EIP 寄存器的值相加，结果必须小于等于实际使用的段界限，否则引发处理器异常。即:

`0 <= (EIP + 指令长度 -1) <= 实际使用的段界限`

任何指令都不允许，也不可能向代码段写入数据。而且，只有在代码段可读的情况下（由其描述符指定），才能由指令读取其内容。

### 4.2 栈操作时的保护
栈段一直是使用向下扩展的内存段，段界限的检查和向上扩展的数据段和代码段不同。实际使用的段界限就是段内不允许访问的最低端偏移地址，至于最高端的地址，则没有限制。也就是说，在进行栈操作时，必须符合以下规则：

`实际使用的段界限+1 <= (ESP的内容 - 操作数的长度) <= 0xFFFFFFFF`

栈指针寄存器 ESP 的内容仅仅在访问栈时提供偏移地址，操作数在压入栈时的物理地址要用**段寄存器的描述符高速缓存器中的段基址**和**ESP 的内容**相加得到。下面定义的栈段:

```
         mov dword [ebx+0x20],0x7c00fffe
         mov dword [ebx+0x24],0x00cf9600
         xor esp,esp                        ;ESP <- 0
      
```

1. 线性基地址为0x00007C00
2. 段界限为0xFFFFE，粒度为4KB，并设置栈指针寄存器ESP 的初值为0。

因为段界限的粒度是4KB（G＝1），故实际使用的段界限为 `0xFFFFE * 0x1000 + 0xFFF = 0xFFFFEFFF`，又因为ESP 的最大值是0xFFFFFFFF，因此，如图12-4 所示，在操作该段时，处理器的检查规则是：

`0xFFFFF000 <= (ESP 的内容 - 操作数的长度) <=0xFFFFFFFF`

线性基地址为 0x00007C00:
- 该栈最低端的有效物理地址是: `0x00007C00 + 0xFFFFF000 = 0x00006c00`
- 最高端的有效物理地址是: `0x00007C00 + 0xFFFFFFFF = 0x00007cvFF`

也就是说，当前程序所定义的栈空间介于地址为0x00006C00～0x00007BFF 之间，大小是4KB。

### 4.3 数据访问时的保护
这里所说的数据段，特指向上扩展的数据段，有别于栈和向下扩展的数据段。因为是向上扩展的，所以代码段的检查规则同样适用于数据段。不同之处仅仅在于，对于取指令来说，是否越界取决于指令的长度；而对于数据段来说，则取决于操作数的尺寸。

在32 位模式下，处理器使用32 位的段基地址加上32 位的偏移量，共同形成32 位的物理地址来访问内存。段基地址由段描述符指定，而偏移量由指令直接或者间接给出。