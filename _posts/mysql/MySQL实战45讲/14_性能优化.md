---
title: 14 MySQL 性能优化
date: 2020-03-14
categories:
    - 存储
tags:
    - mysql运维
---

MySQL 中怎么做问题追踪与性能优化

<!-- more -->


## 1. 问题排查的工具
mysql 中有以下几种问题排查的工具:
1. `show processlist`
2. `show engine innodb status`
3. `information_schema.innodb_trx`
4. `optimizer_trace`
5. 慢查询日志
6. `performance_schema 和 sys 系统库`


## 1. show processlist
show processlist
- 作用: 查看当前连接的线程的状态

### 1.1 等待 MDL 锁
![show_processlist](/images/mysql/MySQL45讲/show_processlist.png)

上面是一个等待 MDL 写锁的示例。这类问题的处理方式，就是找到谁持有 MDL 写锁，然后把它 kill 掉。但是，由于在 show processlist 的结果里面，持有 MDL 写锁线程的 Command 列可能是“Sleep”，导致查找起来很不方便。

通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。

![schema_table_lock_waits](/images/mysql/MySQL45讲/schema_table_lock_waits.png)


不过启用 performance_schema 和 sys(mariadb 中为 information_schema) 系统库需要 MySQL 在启动时设置 `performance_schema=on`，相比于设置为 off 会有 10% 左右的性能损失。


### 1.2 等 flush
flush tables:
- flush tables t with read lock: 只关闭表 t
- flush tables with read lock: 关闭 MySQL 里所有打开的表。
- 正常这两个语句执行起来都很快，除非它们也被别的线程堵住了

![wait_flush](/images/mysql/MySQL45讲/wait_flush.png)

出现上面 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。


### 1.3 innodb 行锁
![line_lock](/images/mysql/MySQL45讲/line_lock.png)

state 为 statistics 的线程被阻塞。这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是 MySQL 5.7 版本，可以通过 sys.innodb_lock_waits 表查到。

![innodb_lock_waits](/images/mysql/MySQL45讲/innodb_lock_waits.png)

可以看到，4 号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是 KILL QUERY 4 或 KILL 4。
- 不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止 4 号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id=1 上的行锁。
- 实际上，KILL 4 才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。


