---
title: 1 MYSQL 锁
date: 2020-03-13
categories:
    - 存储
tags:
    - mysql运维
---

全局锁 - 表锁 - 行锁

<!-- more -->

## 1. 全局锁
全局锁:
- 作用: 对整个数据库实例加锁
- 加锁: `Flush tables with read lock`
- 解锁: `unlock tables`，客户端断开时会自动释放锁
- 场景: 全库逻辑备份，即把整库每个表都 select 出来存成文本
- 加锁范围: 数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句都会被阻塞

做全库备份时，对于 Innodb，通过可重复度隔离级别我们就可以获取数据库的一致视图，但是对 于MyISAM 这些不支持事务的存储引擎，只能使用 `Flush tables with read lock` 让整个库处于只读状态。


既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：
1. 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大
2. 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

## 2.表级锁
MySQL 表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁:
- 加锁: `lock tables … read/write`
- 解锁: `unlock tables`，客户端断开时会自动释放锁
- 加锁范围: 除了会限制别的线程的读写外，也限定了本线程接下来的操作对象，如果在某个线程 A 中执行 lock tables t1 read, t2 write;线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表，线程A只能访问他锁定的表

元数据锁:
- 加锁: MDL 不需要显式使用，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。MDL 的作用是，保证读写的正确性
- 解锁: 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放

在做表结构变更的时候，如果操作不慎，就会导致锁住线上查询和更新。

![mdl](/images/mysql/MySQL45讲/mdl.png)

1. session A 先启动，这时候会对表 t 加一个 MDL 读锁
2. 由于 session B 需要的也是 MDL 读锁，因此可以正常执行
3. 因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞
4. session D 等后续所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了
5. 如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。

因为MDL锁只有在事务提交之后才会释放，因此对于存在长事务，或者操作非常频繁的表做DDL时要非常小心。比较理想的机制是，在 alter table 语句里面设定等待时间:

```bash
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```


