---
title: 1 MYSQL 基础架构
date: 2020-03-10
categories:
    - 存储
tags:
    - mysql运维
---

一条 SQL 查询语句是如何执行的，一条更新语句又是如何执行的

<!-- more -->


## 1.查询语句的执行流程
### 1.1 MySQL 基础架构
![mysql_structure](/images/mysql/MySQL45讲/mysql_structure.png)
MySQL 可以分为 Server 层和存储引擎层两部分:
1. Server 包括: 
	- 连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能
	- 所有的内置函数（如日期、时间、数学和加密函数等）
	- 所有跨存储引擎的功能，比如存储过程、触发器、视图等都在这一层实现
2. 存储引擎层: 负责数据的存储和提取


### 1.2 连接器
连接器: 负责跟客户端建立连接、获取权限、维持和管理连接
1. 权限获取: 
	- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
2. 连接管理: 
	- 连接分为短连接，长连接，长时间空闲的链接连接称为空闲连接
	- 空闲连接的保持时长由 wait_timeout 参数配置，默认为 8 小时，超时后连接就会自动断开
	- 全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了，解决办法有如下两个:
		- 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
		- MySQL>=5.7，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 1.3 查询缓存
查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。大多数情况下，建议按需启用查询缓存。QUERY_CACHE_TYPE: 是否启用查询缓存,可选值:
- OFF: 不启用，显示指定 SQL_CACHE 也不会缓存
- ON: 启用，可以使用 SQL_NO_CACHE 显示指定不缓存查询结果
- DEMAND: 按需启用，即可以使用 SQL_CACHE 显示指定缓存查询结果
- MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

### 1.4 分析器
分析器，包括词法分析和语法分析，语法错误，会在此阶段爆出。

### 1.5 优化器
优化器主要是优化SQL语句的执行:
1. 在表里面有多个索引的时候，决定使用哪个索引
2. 在一个语句有多表关联（join）的时候，决定各个表的连接顺序

### 1.6 执行器
执行器负责执行语句
1. 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)
2. 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
3. 慢查询日志中记录有一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。

## 2.更新语句的执行流程
首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。

### 2.1 redo log
为了提高磁盘的IO效率，避免大规模的随机IO，MySQL 采用一种叫做 WAL 技术(Write-Ahead Logging)它的关键点就是先写日志，再写磁盘:
1. 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做
2. InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![redo_log](/images/mysql/MySQL45讲/redo_log.png)

1. write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头
2. checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
3. write pos 和 checkpoint 之间是可用部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，这时候不能再执行新的更新，得停下来将数据更新到数据文件，把 checkpoint 推进一下

有了 redo log，InnoDB 既保证了即使数据库发生异常重启，之前提交的记录都不会丢失(数据已记录到文件，这个能力称为 crash-safe)，也避免了大规模的随机IO带来的效率低下。

### 2.2 bin log
redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。binlog 的主要作用有两个:
1. 备份和数据恢复
2. 主从同步的数据复制

bin log 与 redo log
1. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”
2. binlog 是逻辑日志，记录的是这个语句的原始逻辑，用于数据归档。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

### 2.3 Innodb 更新语句的执行流程

```bash
mysql> update T set c=c+1 where ID=2;
```
我们以上面更新语句为例，来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

![commit_log](/images/mysql/MySQL45讲/commit_log.png)
- 浅色框表示是在 InnoDB 内部执行的
- 深色框表示是在执行器中执行的。

#### 两阶段提交
redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。要明白为什么 redo log 需要使用两阶段提交，我们需要明白下面几点:
1. redo log 与 bin log 存在的目的不同:
	- redo log: 为了兼顾crash-safe 和IO效率
	- bin log: 是为了备份和数据
2. mysql 要保证已经提交 commit 的事务数据不能丢失，这就包括事务提交后，mysql 服务奔溃数据不丢失，误操作进行数据恢复时或主从同步时数据不丢失，前者是 redo log 保证的，后者是 binlog 保证，因此需要保证redo log 与 bin log 之间数据一致
3. 两阶段提交的目的是为了让两份日志之间的逻辑一致。

## 3. 日志相关参数
MySQl 有两个与 redo log/bin log 写操作相关重要参数:  
1. innodb_flush_log_at_trx_commit:
	- =1: 表示每次事务的 redo log 都直接持久化到磁盘。建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失
2. sync_binlog:
	- =1: 表示每次事务的 binlog 都持久化到磁盘。建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失

