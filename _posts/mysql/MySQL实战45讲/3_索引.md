---
title: 1 MYSQL 索引
date: 2020-03-12
categories:
    - 存储
tags:
    - mysql运维
---

B+树索引

<!-- more -->

## 1. InnoDB 的索引模型
实现索引的方式有很多方式，N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。

根据叶子节点的内容，索引类型分为主键索引和非主键索引。
1. 主键索引: 又称聚簇索引 clustered index，叶子节点保存的是整行数据。
2. 非主键索引: 又称为二级索引 secondary index，叶子节保存的是主键的值。InnoDB会把主键字段放到索引定义字段后面，
当然同时也会去重。

下面是一个示例，可以帮助我们理解主键，非主键索引的关系: 
```bash
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```
索引:
- 主键: 是 a,b 字段的聚簇索引，相当于 order by a,b
- 索引 c:  按 c 排序，同时记录主键，因为主键有排序，所以相当于 order by c,a,b
- 索引 ca: 先按 c 排序，再按 a 排序，同时记录主键，主键部分是 b，不是 ab，而是只有 b,相当于 order by c,a
- 索引 cb: 先按 c 排序，在按 b 排序，同时记录主键，主键部分只有 a，相当于 order by c,b

所以索引 ca 这里是重复的，应该被删除。

### 1.1 主键的选择
由于树的有序性，并且每个叶子节点对应的数据页所能容纳的行数是有限制的，因此在数据的插入和删除过程中就会发生页的分裂和合并，因而会影响数据更新的性能。所以大多数情况下我们都建议使用自增主键

自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。同时每个非主键索引的叶子节点上都是主键的值。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

### 1.2 索引优化
B+树索引有四种常见的优化方式:
1. 覆盖索引: 索引包含的字段能够覆盖查询的需求，不用回表进行二次查询
2. 左前缀索引: 合理调整索引字段的顺序，可以提高索引复用率，减少索引个数
	- 常用的查询字段或者查询组合应该应该靠前
	- 其次，考虑空间因素，例如name 字段是比 age 字段大的 ，应该创建一个（name,age) 的联合索引和一个 (age) 的单字段索引，而不是 (age, name) (name) 两个索引
3. 索引下推:  MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
4. 索引可能因为删除，或者页分裂等原因，导致数据页有空洞，适时地重建索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
5. 对于主键索引，不论是删除主键还是创建主键，都会将整个表重建，因此主键索引的重建应该使用 `alter table T engine=InnoDB`，而不是 `drop primary key, add primary key`

