---
title: 4 索引基本原理
date: 2019-10-04
categories:
    - 存储
tags:
    - 高性能的MySQL
---

mysql 索引的基本原理

<!-- more -->

## 1. 前言

索引对性能至关重要，接下来的 3 篇文章我们将会讲解索引的相关内容。本文是第一篇有关的索引的基本原理。在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准，每一种存储引擎都有自己的索引实现。常见的索引类型有如下几种:
1. B-Tree索引
2. 哈希索引
3. 空间数据索引（R-Tree）
4. 全文索引

我们将分别介绍他们的实现原理和适用的查询类型


## 2. B-Tree 索引
B-Tree 索引顾名思义就是使用 B-Tree 结构实现的索引。实际上大多数存储引擎包括 Innodb 使用的是 B+ 树。下面是 B+ 数索引的结构示意图:

[B+树索引](/images/mysql/b_tree.jpg)

一个 B+ 树在结构上有如下一些特点:
1. 一个 B+ 树是一个平衡多叉树，每一个叶子页到根的距离相同
2. 叶子节点除了被索引的列，还保存了对应行的引用，在 Innodb 中保存的就是对应的行的主键
3. 索引列在每个叶子节点中都是顺序保存的
4. 每个叶子节点都包含指向下一个叶子节点的指针，便于进行范围查找

B+ 索引的顺序存储特性，使得 B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY和GROUP BY操作。

因为最左前缀匹配，如果不是按照索引的最左列开始查找，则无法使用索引，同时也不能跳过索引中的列使用索引。因此索引列的顺序变得至关重要。如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。

## 3. 哈希索引
哈希索引即基于哈希实现的索引。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code）。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

哈希的特性是只支持精确匹配，因此哈希索引有如下一些限制:
1. 哈希索引只包含哈希值和行指针，而不存储字段值，因此不存在覆盖索引
2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
3. 不支持索引列部分匹配，只支持等值比较查询，不支持范围查询

在MySQL中，只有Memory引擎显式支持哈希索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这是与众不同的。除了Memory引擎外，NDB集群引擎也支持唯一哈希索引。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

可以在 Innodb 中模拟哈希索引，还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。例如需要存储大量的URL，并需要根据URL进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身都很长。可以删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的方式查询：

```SQL
# 1. 添加一个 CRC32(url_crc) 的 B-Tree 索引

CREATE TABLE pseudohash (
   id int unsigned NOT NULL auto_increment,
   url varchar(255) NOT NULL,
   url_crc int unsigned NOT NULL DEFAULT 0,
   PRIMARY KEY(id),
   INDEX(url_crc)
);

# 2. 查询必须待上原值，因为哈希可能存在哈希冲突
mysql> SELECT id FROM url WHERE url="http://www.mysql.com"
    ->    AND url_crc=CRC32("http://www.mysql.com");

# 3. 使用触发器实现 url_crc 的维护

DELIMITER //  # 先临时修改一下语句分隔符，这样就可以在触发器定义中使用分号：

CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;
//

CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;
//

DELIMITER ;
```
注意如果采用这种方式，记住不要使用SHA1()和MD5()作为哈希函数。因为这两个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，比较时也会更慢。还可以使用如FNV64()函数作为哈希，哈希值为64位，速度快，且冲突比CRC32()要少很多。

## 4. 其他索引类别
mysql 还有很多存储引擎使用不同的数据结构来存储索引，包括:
1. 全文索引，查找的是文本中的关键词，而不是直接比较索引中的值
2. TokuDB使用分形树索引，既有B-Tree的很多优点，也避免了B-Tree的一些缺点

## 5. 索引的优点
索引有众多优点，总结下来包括如下三个：
1.索引大大减少了服务器需要扫描的数据量  -- 快速定位行位置
2.索引可以帮助服务器避免排序和临时表  -- B-Tree 索引的有序存储，可以实现 ORDER BY和GROUP BY
3.索引可以将随机I/O变为顺序I/O  -- 覆盖索引优化

Lahdenmaki和Leach在书中介绍了如何评价一个索引是否适合某个查询的“三星系统”（three-star system）:
1. 索引将相关的记录放到一起则获得一星
2. 如果索引中的数据顺序和查找中的排列顺序一致则获得二星
3. 如果索引中的列包含了查询中需要的全部列则获得“三星”

## 6. 索引的适用
索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于中到大型的表，索引非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以**直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配**，例如可以使用分区技术。

如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。
