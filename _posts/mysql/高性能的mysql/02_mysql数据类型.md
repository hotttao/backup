---
title: 2 Schema 与数据类型
date: 2019-10-10
categories:
    - 存储
tags:
    - mysql
---

mysql 的数据类型。

<!-- more -->

## 1. 前言
本章是mysql 的数据类型方面的内容。这一部分内容大家可能都比较熟悉，但是其中的一些细节依然值得一在强调。

本文大部分内容摘自：《高性能MySQL》 — 〔美〕施瓦茨 (Baron Schwartz)  〔美〕扎伊采夫 (Peter Zaitsev)  〔美〕特卡琴科 (Vadim Tkachenko)
可在豆瓣阅读书店查看：https://read.douban.com/ebook/35648568/

## 2. 数据类型
在详细介绍具体的数据类型之前，简单说一下选择最优的数据类型的几个简单原则:
1. 更小的通常更好
  - 应该尽量使用可以正确存储数据的最小数据类型
  - 但是要确保没有低估需要存储的值的范围
2. 简单就好
  - 简单数据类型的操作通常需要更少的CPU周期
3. 尽量避免NULL
  - 通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。
  - 如果查询中包含可为NULL的列，对MySQL来说更难优化
  - 因为可为NULL的列使得索引、索引统计和值比较都更复杂
  - 可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理
  - 如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。
  - InnoDB是一个例外，它使用单独的位（bit）存储NULL值，所以对于稀疏数据有很好的空间效率

与VARCHAR（5）相比 更长的列 VARCHAR（5）会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。所以最好的策略是只分配真正需要的空间。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。下一步是选择具体类型，相同大类型的不同子类型数据有时也有一些特殊的行为和属性。接下来我们就简要说明一下 MySQL 中基本类型的一些重要特性。


### 2.1 整数
整数类型有：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64位存储空间，可以存储−2^{（N−1）}到2^{（N−1）}−1 的值，其中N是存储空间的位数。MySQL可以为整数类型指定宽度，但它不会限制值的合法范围，对于存储和计算来说，INT（1）和INT（20）是相同的。整数的类型只影响存储，整数计算一般使用64位的BIGINT整数。

### 2.2 实数
FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。DECIMAL类型用于存储精确的小数。在MySQL 5.0和更高版本，DECIMAL类型支持精确计算。因为CPU不支持对DECIMAL的直接计算，而支持原生浮点计算，所以FLOAT和DOUBLE比 DECIMAL 计算快。

MySQL 5.0和更高版本将 DECIMAL 打包保存到一个二进制字符串中（每4个字节存9个数字）。例如，DECIMAL（18,9）小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。MySQL 5.0和更高版本中的DECIMAL类型允许最多65个数字。

有多种方法可以指定浮点列所需要的精度，但是浮点数的精度定义是非标准的，所以建议只指定数据类型，不指定精度。和整数类型一样，能选择的只是浮点数的存储类型；MySQL使用DOUBLE作为内部浮点计算的类型。

### 2.2 字符串
从MySQL 字符串类型有很多变种，包括:
1. VARCHAR和CHAR: 两种最主要的字符串类型。
2. BINARY和VARBINARY: 存储的是二进制字符串，二进制字符串存储的是字节码而不是字符
3. BLOB和TEXT: 为存储很大的数据而设计的字符串数据类型，分别为二进制和字符


#### VARCHAR 和 CHAR
很难精确地解释VARCHAR和CHAR是怎么存储在磁盘和内存中的，因为这跟存储引擎的具体实现有关。下面论述以InnoDB和/或者MyISAM为基础。需要注意的是存储引擎存储CHAR或者VARCHAR值的方式在内存中和在磁盘上可能不一样，所以MySQL服务器从存储引擎读出的值可能需要转换为另一种存储格式。下面 VARCHAR 与 CHAR 的典型对比
1. VARCHAR:
  - 存储可变长字符串，需要使用1或2个额外字节记录字符串的长度，列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节
  - VARCHAR节省了存储空间，但在UPDATE时可能使行变得比原来更长时需要做额外的工作，如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，则需要进一步处理(不同的存储引擎处理方式不一样)
  - VARCHAR 节省存储空间有一个例外情况，即 MySQL 表使用ROW_FORMAT=FIXED创建，此时每一行都会使用定长存储
  - 在5.0或者更高版本，MySQL在存储和检索时会保留末尾空格。但在4.1或更老的版本，MySQL会剔除末尾空格
2. CHAR:
  - CHAR类型是定长的
  - 当存储CHAR值时，MySQL会删除所有的末尾空格
  - CHAR适合存储很短的字符串，或者所有值都接近同一个长度
  - 对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片
  - 对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率

#### BINARY和VARBINARY
MySQL填充BINARY采用的是`\0`（零字节）而不是空格，在检索时也不会去掉填充值

当需要存储二进制数据，并进行二进制比较时 BINARY和VARBINARY 非常有用。二进制比较的优势并不仅仅体现在大小写敏感上。MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单很多，所以也就更快

#### BLOB 和 TEXT
MySQL把每个BLOB和TEXT值当作一个独立的对象处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实际的值。

BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小max_sort_length的配置，或者使用ORDER BY SUSTRING（column，length）。

MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

因为Memory引擎不支持BLOB和TEXT类型，所以，如果查询使用了BLOB或TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，即使只有几行数据也是如此。这会导致严重的性能开销。即使配置MySQL将临时表存储在内存块设备上（RAM Disk），依然需要许多昂贵的系统调用。

最好的解决方案是尽量避免使用BLOB和TEXT类型。如果实在无法避免，有一个技巧是在所有用到BLOB字段的地方都使用SUBSTRING（column，length）将列值转换为字符串（在ORDER BY子句中也适用），这样就可以使用内存临时表了。但是要确保截取的子字符串足够短，不会使临时表的大小超过max_heap_table_size或tmp_table_size，超过以后MySQL会将内存临时表转换为MyISAM磁盘临时表。最坏情况下的长度分配对于排序的时候也是一样的，所以这一招对于内存中创建大临时表和文件排序，以及在磁盘上创建大临时表和文件排序这两种情况都很有帮助。

### 2.3 枚举（ENUM）类型
MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。

但是让人吃惊的地方是，枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。一种绕过这种限制的方式是按照需要的顺序来定义枚举列。另外也可以在查询中使用FIELD()函数显式地指定排序顺序，但这会导致MySQL无法利用索引消除排序。

枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素，这样在MySQL 5.1中就可以不用重建整个表来完成修改。

把列都转换成ENUM以后，关联变得很快。在特定情况下，把CHAR/VARCHAR列与枚举列进行关联可能会比直接关联CHAR/VARCHAR列更慢。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。

使用 ENUM 替换字符串类型最大好处是，可以使得表更小，相比于字符串主键，转换后主键以及依赖于主键的非主键索引也会更小。

### 2.4 日期和时间
MySQL可以使用许多类型来保存日期和时间值，例如YEAR和DATE。大部分时间类型都没有替代品，因此没有什么是最佳选择的问题。唯一的问题是如何保存日期和时间，MySQL提供两种相似的日期类型：DATETIME和TIMESTAMP。
1. DATETIME:
  - 这个类型能保存大范围的值，从1001年到9999年，精度为秒
  - 它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间
2. TIMESTAMP
  - UNIX时间戳，只使用4个字节的存储空间，只能表示从1970年到2038年
  - FROM_UNIXTIME()把Unix时间戳转换为日期，UNIX_TIMESTAMP()把日期转换为Unix时间戳
  - TIMESTAMP显示的值也依赖于时区，MySQL服务器、操作系统，以及客户端连接都有时区设置
  - 默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间
  - 在更新一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值
  - 可以配置任何TIMESTAMP列的插入和更新行为
  - 最后，TIMESTAMP列默认为NOT NULL，这也和其他的数据类型不一样

除了特殊行为之外，通常也应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。有时候人们会将Unix时间截存储为整数值，但这不会带来任何收益。用整数保存时间截的格式通常不方便处理。

MySQL能存储的最小时间粒度为秒，如果需要存储比秒更小粒度的日期和时间值可以使用  BIGINT 模拟也可以改使用 MariaDB （MariaDB支持微秒级别的时间类型）。

### 2.5 位数据类型
MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。
#### BIT:
可以使用BIT列在一列中存储一个或多个true/false值，最大长度是64个位。

BIT的行为因存储引擎而异。MyISAM会打包存储所有的BIT列，所以17个单独的BIT列只需要17个位存储（假设没有可为NULL的列），这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎例如Memory和InnoDB，为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。

MySQL把BIT当作字符串类型，而不是数字类型。但是 BIT 的使用依赖于其使用的上下文。例如，如果存储一个值b'00111001'（二进制值等于57）到BIT（8）的列并且检索它，得到的内容是字符码为57的字符串。也就是说得到ASCII码为57的字符“9”。但是在数字上下文场景中，得到的是数字57：

![bit 使用](/images/mysql/bit.jpg)

所以我们认为应该谨慎使用BIT类型。对于大部分应用，最好避免使用这种类型。

#### SET
SET:
- 在MySQL内部是以一系列打包的位的集合,如果需要保存很多true/false值，可以考虑合并这些列到一个SET
- FIND_IN_SET()和FIELD()这样的函数，方便地在查询中使用
- 缺点是改变列的定义的代价较高：需要ALTER TABLE，一般来说，也无法在SET列上通过索引查找

一种替代SET的方式是使用一个整数包装一系列的位，并且按位操作来使用。好处是可以不使用ALTER TABLE改变字段代表的“枚举”值，缺点是查询语句更难写，并且更难理解。最后 MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串。

### 2.6 选择标识符
为标识列（identifier column）选择合适的数据类型非常重要，不仅仅需要考虑存储类型，还需要考虑MySQL对这种类型怎么执行计算和比较。一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确匹配，包括像UNSIGNED这样的属性。混用不同数据类型可能导致性能问题，即使没有性能影响，在比较操作时隐式类型转换也可能导致很难发现的错误。下面是各类型作为标识符的适用情况:
2. 整数: 通常是标识列最好的选择，很快并且可以使用AUTO_INCREMENT
3. EMUM和SET: 通常是一个糟糕的选择，它们仅适合在存储固定信息作为标识列类型
4. 字符串:
  - 如果可能，应该避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢
  - MyISAM默认对字符串使用压缩索引，这会导致查询慢得多

特别的对于像 MD5() 生成的随机字符串，作为标识符需要注意。随机字符串分布在很大的空间内，会导致INSERT以及一些SELECT语句变得很慢。
1. 因为插入值会随机地写到索引的不同位置，所以使得INSERT语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片
2. SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
3. 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效。
4. 如果存储UUID值，则应该移除“-”符号；更好的做法是，用UNHEX()函数转换UUID值为16字节的数字，并且存储在一个BINARY（16）列中。检索时可以通过HEX()函数来格式化为十六进制格式。
5. UUID()生成的值与加密散列函数例如SHA1()生成的值有不同的特征：UUID值虽然分布也不均匀，但还是有一定顺序的。尽管如此，但还是不如递增的整数好用。

### 2.7 IP 的存储
应该用无符号整数存储IP地址。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。
