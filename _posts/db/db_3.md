---
title: 3. 数据模型与查询语言
date: 2019-04-03
categories:
    - 存储
tags:
    - 数据密集型应用
---

用于数据存储和查询的通用数据模型

![big data](/images/db/db_start.jpg)

<!-- more -->


## 1. 数据抽象
上一节我们讲解了，在进行应用程序设计时，我们要达到的目标(可靠性，可扩展性和可维护性)，并精确的解释了这些术语的含义。下面我们就正式进入数据系统设计的细节。

需要强调的是在设计我们的应用时，应用的需求决定了我们要设计怎样的系统。而另一方面，我们的应用是建立在层层抽象的基础上的。只有系统提供的抽象与应用的需求相符时，我们才能达到设计可靠、可扩展、可维护应用的目标。因为我们设计的是数据密集型应用，因此书中将系统的抽象称为数据模型。

我们可以理解为多数应用是使用层层叠加的数据模型构建的，每层数据模型的关键问题是，如何用低一层数据模型来表示，而每一层都通过提供一个明确的数据模型来隐藏更低层次的复杂性。本节我们将研究一系列用于数据存储和查询的通用数据模型，包括:
1. 关系模型
2. 文档模型
3. 基于图形的数据模型

通过本节的学习，你将明白主流数据库提供的数据模型的优劣，支持的查询语言以及它们的适用场景。

## 2. 数据模型
目前大多数应用程序开发都使用面向对象的编程语言来开发，程序运行时，数据是程序中的对象，保存在程序的数据结构中，数据之间通过引用，可以进行任意关联。当数据被存储时，程序中的对象被转换成数据模型模型，数据结构之间的任意引用需要抽象成模型反映的数据关系中。因此，对于数据而言，应用的需求就是如何表示程序中的对象，以反应应用内**数据之间的关系**(一对一，一对多，多对一还是多对多)。

### 2.1 关系模型
关系模型中，数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。数据库中表存在固定的模式，为了消除重复，对于存在一对多关系的程序对象，需要拆分成多表进行存储，并通过外键和链接，来表示数据之间的联系。这些特性使得关系模型具有如下一些特性:
- 从应用程序代码中的对象到关系模型的表，行，列需要一个显示的中间转换层，虽然对象关系映射（object-relational mapping, ORM） 框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异
- 固定的模型导致架构的不灵活性


### 2.2 文档模型
文档有多种形式，比如 xml，json，最常见属 json。 json 通过在其父记录中存储嵌套记录，而不是在单独的表中，可以很自然的表示一对多关系。这种自包含的文档比关系型中的多表模式具有更好的局部性。但是在文档数据库中，一对多树结构没有必要用连接，因此对连接的支持通常很弱。

但是这种局部性的性能优势，只有在应用程序经常需要访问整个文档时才会显现。只访问其中的一小部分，这对于大型文档来说是很浪费的。更新文档时，通常需要整个重写。只有不改变文档大小的修改才可以容易地原地执行。因此，通常建议保持相对小的文档，并避免增加文档大小的写入。这些性能限制大大减少了文档数据库的实用场景。

### 2.3 模型比较
支持文档数据模型的主要论据是架构灵活性，因局部性而拥有更好的性能，以及对于某些应用程序而言更接近于应用程序使用的数据结构。关系模型通过为连接提供更好的支持以及支持多对一和多对多的关系来反击。

如果应用程序中的数据具有类似文档的结构（即，一对多关系树，通常一次性加载整个树） ，那么使用文档模型可能是一个好主意。将类似文档的结构分解成多个表的关系技术可能导致繁琐的模式和不必要的复杂的应用程序代码。文档模型有一定的局限性：例如，不能直接引用文档中的嵌套的项目，而是需要说“用户251的位置列表中的第二项”。但是，只要文件嵌套不太深，这通常不是问题。

文档数据库对连接的糟糕支持也许或也许不是一个问题，这取决于应用程序。例如，分析应用程可能永远不需要多对多的关系，如果它使用文档数据库来记录何事发生于何时但是，如果你的应用程序确实使用多对多关系，那么文档模型就没有那么吸引人了。通过反规范化可以减少对连接的需求，但是应用程序代码需要做额外的工作来保持数据的一致性。通过向数据库发出多个请求，可以在应用程序代码中模拟连接，但是这也将复杂性转移到应用程序中，并且通常比由数据库内的专用代码执行的连接慢。在这种情况下，使用文档模型会导致更复杂的应用程序代码和更差的性能

对于高度相联的数据，选用文档模型是糟糕的，选用关系模型是可接受的，而选用图形模型（参见“图数据模型”） 是最自然的

文档数据库有时称为无模式（schemaless） 一个更精确的术语是读时模式（schema-on-read） （数据的结构是隐含的，只有在数据被读取时才被解释） ，相应的是写时模式（schema-on-write） （传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式） 

当由于某种原因（例如，数据是异构的） 集合中的项目并不都具有相同的结构时,读时模式更具优势。例如，
- 如果：存在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的。
- 数据的结构由外部系统决定。你无法控制外部系统且它随时可能变化。

在上述情况下，模式的坏处远大于它的帮助，无模式文档可能是一个更加自然的数据模型。但是，要是所有记录都具有相同的结构，那么模式是记录并强制这种结构的有效机制。


### 2.4 模型的融合
随着时间的推移，关系模型和文档模型已经开始相互借鉴。SQL 标准增加了对结构化数据类型， XML 和 json 数据的支持；这允许将多值存储在单行内，并支持在这些文档内的查询和索引。

文档数据也越来越多的支持连接。RethinkDB在其查询语言中支持类似关系的连接，一些MongoDB驱动程序可以自动解析数据库引用。在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同。在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为外键，在文档模型中称为文档引用。该标识符在读取时通过连接或后续查询来解析。

随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 ，如果一个数据库能够处理类似文档的数据，并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。关系模型和文档模型的混合是未来数据库一条很好的路线。

## 3. 查询语言
