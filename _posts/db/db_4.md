---
title: 4. 复制
date: 2019-04-04
categories:
    - 分布式
tags:
    - 数据密集型应用
---

数据复制

<!-- more -->

## 1. 为什么需要多台机器上分布数据
通过数据复制，通常希望达到以下目的:
1. 在地理位置上更接近用户，从而降低访问延迟
2. 当部分组件出现故障，系统依然可以继续工作，从而提高可用性
3. 扩展至多台机器以同时提供数据访问服务，从而提高读吞吐量

复制的技术挑战在于处理那些**持续更改的数据**。接下来我们将讨论三种流行的复制数据变化的方法:
1. 主从复制
2. 多主节点复制
3. 无主节点复制

复制技术存在许多需要这种考虑的地方，例如采用同步复制还是异步复制，如何处理失败的副本，以及数据的一致性问题。

## 1. 主从复制
### 1.1 主从复制架构

### 1.2 主从复制需要解决的问题
#### 同步复制还是异步复制

#### 配置新的从节点

#### 处理节点失效
从节点失效: 追赶式恢复

主节点失效: 节点切换
1. 选择某一从节点为主节点
2. 客户端需要更新，保证后续写请求路由到新的主节点
3. 其他从节点需要更新，以从新的主节点接收并更数据

### 1.3 主从复制的问题
主从复制的主要问题是复制延迟带来的问题。

使用最终一致性系统时，最好先考虑这样的问题: 如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子。如果带来糟糕的用户体验，那么在设计系统时 就要考虑提供一个更强的一致性保证，比如写后读一致性，单调读，前缀读。 

## 2. 多主复制
多主复制的问题在于如何解决冲突。

这种冲突产生的原因在于多个主节点都只是按照它所看到的写入顺序执行，缺乏全局的写入顺序。数据库最终将处于不一致的状态。

所有的复制模型至少应该确保数据在所有副本中最终状态一定是一致的。因此数据库必须以一种收敛趋同的方式来解决冲突。这也意味着所有更改最终被复制、同步之后，所有副本的最终值是相同的。

多主复制需要解决的问题分成了两个方面:
1. 假设对主节点，多节点可以达成共识，我们如何解决多个主节点之间的写冲突问题
2. 在后面的共识的问题中，我们需要解决如何对主节点达成共识的问题

### 2.1 冲突解决
1. 最终写入者获胜 LWW
2. Happens-before 关系和并发: 我们需要的是一个算法来判定两个操作是否并发
3. 版本向量


## 3. 无主节点复制
主从复制，主主复制的系统由主节点决定操作的写入顺序，而对于无主节点复制的系统，并没有固定的写入顺序。


## 4. 总结
产生冲突的最终原因是，网络延迟的不稳定和局部失效，请求在不同节点上可能会呈现不同的顺序。进而导致他们无法以趋同的方式收敛。

因此我们需要某种算法对写入的最终顺序进行确定，即达成共识。这就涉及到两个问题:
1. 如何达成共识
2. 如何让客户端感知到共识发生了变化


如果我们假设网络始终稳定，且不存在单点故障(类似单机情况下)通过锁就可以解决并发问题。但是这些问题无法避免单点故障可能导致数据丢失，这就需要多台机器提供冗余，此时就需要对同一项配置达成共识，我们需要共识算法。

共识算法需要解决的另一个问题是，当配置发生变化时，如何让客户端感知到共识发生了变化。我们可以让所有节点抖注册监听器，但是这样会引起惊群效应。因此我们只能让少量节点，即所谓的主节点注册监听器。然后通过版本向量，让与主节点同步的从节点感知配置的变化。

kafka 为什么要引入 Zookeeper 是因为如果对所有 kafka 的节点都通过共识算法解决数据一致性问题，效率将非常低。数据一致性是以吞吐量为代价的。