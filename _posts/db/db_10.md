---
title: 10. 一致性与共识
date: 2019-04-10
categories:
    - 分布式
tags:
    - 数据密集型应用
---

一致性与共识

<!-- more -->

1. 写后读
2. 单调读
3. 前缀一致读
4. 线性化
5. 顺序一致性，满足线性化的写，不满足线性化的读
5. 因果一致性


因果一致性可以认为是，不会由于网络延迟而显著影响性能，又能对网络故障提供容错的最强的一致性模型。


## 1.共识算法实现的逻辑
1. 共识算法，比如 Raft，Zab 都是通过全序关系广播来实现
2. 全序关系广播通常需要一个主节点
3. 主节点的选取通常需要共识算法，这就导致了奇怪的循环
4. 解决的办法是，每个主节点都有一个单调递增的版本号，又称为世代编号(epoch)
5. 主节点在做出任何决定时:
    - 首先必须将提议发送给其他所有节点，等待多数节点的响应
    - 节点只有在没有发现更高 epoch 主节点存在时，才会对当前提议(带 epoch 号码)进行投票
    - 这里实际存在两轮不同的投票，首先投票决定谁是主节点，然后对节点的提议进行投票
    - 最关键一点是参与两轮的 quorum 必须由重叠: 如果某个提议获得通过，那么其中参与投票的节点必须至少有一个也参加了最近一次的主节点选举
    - 换言之，如果在针对提议的投票中没有出现更高 epoch 号码，那么可以得出这样的结论: 因为没有发生更高 epoch 的主节点选举，当前主节点地位没有改变，所以可以安全就提议进行投票

## 2. 为什么要使用 Zookeeper
1. 要在多节点集群中达成共识，可以自己实现一个共识算法(很难)，所以可以直接使用 Zookeeper 提供的服务
2. Zookeeper 通常在固定数量的节点上运行投票，相比于在 1000 甚至更多的节点上达成共识效率更高


因此我们需要某种算法对写入的最终顺序进行确定，即达成共识。这就涉及到两个问题:
1. 如何达成共识
2. 如何让客户端感知到共识发生了变化

如果我们假设网络始终稳定，且不存在单点故障(类似单机情况下)通过锁就可以解决并发问题。但是这些问题无法避免单点故障可能导致数据丢失，这就需要多台机器提供冗余，此时就需要对同一项配置达成共识，我们需要共识算法。

共识算法需要解决的另一个问题是，当配置发生变化时，如何让客户端感知到共识发生了变化。我们可以让所有节点抖注册监听器，但是这样会引起惊群效应。因此我们只能让少量节点，即所谓的主节点注册监听器。然后通过版本矢量，让与主节点同步的从节点感知配置的变化。

kafka 为什么要引入 Zookeeper 是因为如果对所有 kafka 的节点都通过共识算法解决数据一致性问题，效率将非常低。数据一致性是以吞吐量为代价的。