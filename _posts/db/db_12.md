---
title: 12. 流处理系统
date: 2019-04-12
categories:
    - 分布式
tags:
    - 数据密集型应用
---

派生数据

<!-- more -->

## 1. 流处理系统
前面讨论的批处理系统存在一个重要的假设: 输入是有界的，是已知的有限大小，所以批处理知道何时读完他们。比如MapReduce 核心的排序操作必须读取整个输入，然后才开始生成输出。

而实际上，有很多数据是无限的，而且随着时间的推移逐渐到达。数据集永远不会以任何有意义的方式"完成"。而批处理则必须人为将数据划分为固定时间段的数据库分批处理。批处理的问题是，输入的更改只会在一天之后的输出中反映出来。为了更快的响应用户，我们需要完全放弃固定的时间片，每当有事件就开始处理，这就是流处理背后的思想。

### 1.1 发送事件流
在流处理的上下文中，记录通常被称为事件，改事件或者说对象，包含某个时间点发生的事件的细节。每个事件通常包含一个时间戳，用于指示事件发生的**墙上时间**。

事件由生产者生成一次，然后可能由多个消费者处理。相关的事件通常被组合成主题或流。为了更低的响应延时，当新事件出现时，最好通知消费者。

### 1.2 消息系统
向消费者通知新事件的常见方法是使用消息系统。在这种发布/订阅模式中，不同的系统采用了不同的方法，为了区分这些系统，提出以下两个问题对区分很有帮助:
1. 如果生产者发送消息的速度比消费者能处理的快，会发生什么？
    - 一般有三种选择: 系统丢弃消息；将消息缓存在队列中；激活背压(流量控制，即阻止生产者发送消息)
    - 如果消息被缓存在队列中，那么队列增长时会发生什么非常重要
    - 如果内存无法容纳所有队列，系统是否会崩溃，还是消息会被写入磁盘
    - 如果消息会落盘，又会如何影响消息传递系统的性能
2. 如果节点崩溃或者暂时离线，是否会有消息丢失?
    - 持久化需要写入磁盘或者结合复制方案，这些都是有成本的
    - 如果能够接受消息丢失，那么同样的硬件上可以获得更高的吞吐量和更低的延迟

消息传递有如下几种方式:
1. 生产者与消费者之间直接消息传递
2. 消息代理

#### 生产者与消费者之间直接消息传递
这种方式通常要求应用程序意识消息丢失的可能性，它们只支持有限的容错。通常还假定生产者和消费者同时在线。诸如 RPC 和 HTTP 请求，webhooks 都是这种消息传递方式

#### 消息代理
消息代理本质上是一种针对**处理消息而优化的数据库**。将数据集中在代理上，可以更容易的适应不断变化的客户端。持久性问题被转移到代理。消息写入代理的结果也通常导致**消费以异步方式工作**。

#### 多个消费者
当多个消费者读取同一主题中的消息时，有两种主要的消息传递模式:
1. 负载均衡式: 
    - 每一条消息都只被传递给其中一个消费者，所以消费者可以共享主题中处理消息的工作
    - 通过增加消费者可以并行处理消息
2. 扇出式:
    - 每条消息都被传递给所有的消费者
    - 独立的消费者独立接收相同的消息广播

这两种模式可以组合使用

#### 确认和重传
消费者可能在未处理完消息时就已经奔溃，为了确保消息不会丢失，消息代理使用**确认**: 客户端必须在处理完消息后显示的告诉代理，以便代理可以将其从队列中移除。

但是消息的确认/重传会导致以下两个问题:
1. 消息重复: 确认的消息可能在发送给代理的过程中丢失，导致代理重复发送和消息
2. 消息乱序: 与负载均衡结合时，重传机制不可避免的会导致消息被重新排序，为了避免这个问题，可以为每个消费者使用单独的队列(即不使用负载均衡)

注意如果消息之间存在因果依赖关系，消息的顺序就是至关重要的。

## 2. 分区日志
消息代理是基于瞬间的消息传递思想构建的，因此尽管可以永久记录消息，但通常也不会这么做。如果将新的消费者添加到消息系统，通常它只会开始接收在它注册后发送的消息；任何之前的消息已经消失。

那为什么不把数据库的持久存储和消息传递的低延迟结合起来呢？这正是**日志消息代理**背后的思想。

### 2.1 基于日志的消息存储
日志是磁盘上一个仅支持追加式修改记录的序列。与日志结构化存储引擎类似，我们可以使用相同结构来实现消息代理:
1. 生产者通过将消息追加到日志的末尾来发送消息
2. 消费者通过一次读取日志来接受消息

为了提升吞吐量，可以对日志进行分区，在每个分区中，代理为每个消息分配一个单调递增的序列号或偏移量。因为分区日志只能追加，所以分区内的消息是完全有序的。不同分区之间则没有顺序保证。

![基于日志的消息生产和消费](/images/db/message_log.png)


kafka、Amazon Kinesis Stream 和 Twitter DistributedLog 都是这种基于日志的消息代理系统。尽管这些消息代理将所有消息写入磁盘，但是通过多台机器进行分区，能够实现每秒数百万条消息的吞吐量，并且通过复制消息实现容错性。

因为多个消费者可以独立读取日志而不相互有影响，而且消息不会从日志中删除，所以基于日志的方法很自然的支持扇出式消息传递。通过将整个分区分配给消费者组中的节点，每一个节点消费一个分区，可以在一组消费者之间实现负责均衡。

通常当消费者被分配了一个日志分区时，它会以直接的单线程方式顺序读取分区中的消息，这种粗粒度的负载均衡有一些缺点:
1. 消费者的最大数量等于主题的分区数
2. 如果单个消息处理缓慢，会阻碍分区中后续消息的处理。可以将消息处理扩展至线程池，但这种方法消息的确认和消费者偏移管理变得复杂，通常单线程是优选。

因此在消息处理的代价很高，希望在逐个消息的基础上并行处理，而且消息排序又不那么重要的情况下，AMQP 类型的消息代理更可取。相反，在消息吞吐量高，每个消息处理速度快，消息顺序有很重要的情况下，基于日志的方法工作很好。

#### 消费者偏移量
消费者偏移量用于记录消费者已经消费的消息位置，这样就无须跟踪每条消息的确认，减少记录开销。这种偏移量与主从复制数据库中的日志序列号非常相似。

如果消费者节点失败，消费者组中的另一节点将被分配到失败的消费者分区，并以最后记录的偏移量开始使用消息。

#### 磁盘使用
不断追加的日志，磁盘空间最终会被耗尽。为了回收磁盘空间，日志实际上被分割成段，并不时地将旧段删除或归档保存。实际上，日志实现了一个有限大小的缓冲区，当缓冲区变满时，旧的消息被丢弃，该缓冲区被称为环形缓冲区。由于缓冲区在磁盘上，因此可以非常大。

#### 消费者跟不上生产者时
一开始我们讨论消费者跟不上生产者发送消息的速度时由三种选择。基于日志的方法是一种缓冲形式，它具有较大但固定大小的缓冲区。因此消费者落后太多，代理将丢弃缓冲区容量不能容纳的旧消息。可以监控消费者落后日志头部的距离，并在落后明显时发出警告。由于缓冲区很大，通常有足够的时间去修复缓慢的消费者，并允许它在开始丢失消息之前赶上。

即便落后太多并开始丢失消息也只有该消费者会受到影响，他不会中断其他消费者的服务。这是基于日志方法的消息代理带来的运营优势。在传统的消息代理中，需要小心删除消费者已经关闭的任何队列，否则他们讲继续不必要的积累消息，并占用其他活动消费者的内存。

#### 重新处理消息
使用AMQP 风格的消息代理，由于会导致消息在代理上被删除，因此处理和确认操作可视为带有一定破坏性。另一方面基于日志的消息代理中，使用消息更像是从文件读取，并不会更改日志。除了消费者的输出外，唯一的副作用是消费偏移量前移了。但是偏移量在消费者的控制之下，可以轻松对其进行操作了。

这个特点使得基于日志的消息系统更像之前讲的批处理系统过程。派生数据通过可重复的转换过程与输入数据明确分离。支持更多的实验性尝试，也更容易从错误和故障中进行恢复。从而成为集成数据流的不错选择。

## 3. 数据库与流