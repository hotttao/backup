---
title: 8. 事务
date: 2019-04-08
categories:
    - 分布式
tags:
    - 数据密集型应用
---

事务

<!-- more -->

## 1. 为什么需要事务
事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑单元，要么全部成功(提交)、要么失败(中止或回滚)。如果失败，应用程序可以安全地重试。这样无需担心**部分失败**的情况。事务存在的目的是简化应用层的编程模型。有了事务，应用程序可以不用考虑某些内部潜在的错误以及**复杂的并发性问题**，这些都交给数据库负责处理(称之为**安全性保证**)。

要判断什么时候需要事务，我们需要确切理解**事务能提供哪些安全性保证**，背后的代价是什么。

## 2. 深入理解事务
事务所提供的安全性保证即大家熟悉的 ACID，分表代表:
1. Atomicity: 原子性
2. Consistency: 一致性
3. Isolation: 隔离性
4. Durability: 持久性

但实际上各种数据库所实现的 ACID 并不相同，它们能提供的安全保证也各不相同。

而不符合 ACID 的系统有时被称为 BASE:
1. Basically Available: 基本可用性
2. Soft State: 软状态
3. Eventual Consistency: 最终一致性

接下来我们一一来介绍 原子性、一致性、隔离性和持久性的确切含义。

### 2.1 原子性
ACID 的原子性并不关乎多个操作的并发性，它没有描述多个线程视图访问相同的数据会发生情况，后者其实是由 ACID 的隔离性所定义。原子性其实描述了**客户端发起一个包含多个写操作的请求时可能发生的情况**。把多个写操作纳入到一个原子事务，万一出现了故障而导致没法完成最终提交时，事务会中止，并且数据库会**丢弃或撤销哪些局部完成的更改**。

原型性大大简化了: 如果事务已经中止，应用程序可以确定没有实质发生任何更改，可以安全的重试。

因此 ACID 中原子性所定义的特征是: 在出错时中止事务，并将部分完成的写入全部丢弃。也许**可中止性**更为准确。

### 2.2 一致性
很多场景都存在**一致性**，比如:
1. 副本一致性以及异步复制中，引出的最终一致性问题
2. 一致性哈希
3. CPA 理论中，一致性用来表示线性化
4. ACID 中一致性主要指**数据库处于应用程序所期待的预期状态**

ACID 的一致性主要是指**对数据有特定的预期状态**，任何数据更改必须满足这些**状态约束(或者恒等条件)**。

这种一致性本质上要求应用层来维护状态一致或恒等，应用程序有责任正确的定义事务来保持一致。即如果提供的数据修改为了恒等条件，数据很难检查而组织操作。应用程序可以借助数据库提供的原子性、隔离性达到一致性，但一致性并不源于数据库。因此**C 其实不属于 ACID**。

### 2.3 隔离性
隔离性意味着**并发执行的多个事务相互隔离**，不能相互交叉，不会相互影响，比如一个事务不应该看到其他事务部分执行的中间结果。

隔离性意味着可以假装事务是数据库上运行的唯一事务，尽管实际上可能多个事务在同时运行，数据库系统要保证当事务提交时，其结果与串行执行完全相同。

实际上为了权衡性能和安全性，存在多种隔离级别，待会我们在详述。

### 2.4 持久化
持久化保证一旦事务提交成功，及时存在硬件故障或数据奔溃，事务所写入的任何数据也不会丢失:
1. 对于单节点数据库，持久性意味着数据已经写入非易失性存储设备，写入的过程中，通常还涉及预写日志等，以保证磁盘数据损坏可恢复
2. 对于支持远程复制的数据库，持久化意味着数据已成功复制到多个节点

为了实现持久化，数据库必须等到这些写入或者复制完成之后才能报告事务成功提交。现实情况是没有哪一项技术可以提供绝对的持久性保证，包括写入磁盘、复制到远程以及备份，这些都是降低风险的手段，应该组合使用。

## 3. 多对象事务与单对象事务
### 3.1 多对象事务
多对象事务是指一个事务中会修改多个对象，多对象事务会保证多个数据对象之间保持同步。

多对象事务要求确定知道事务包含了哪些读写操作。对于关系型数据库，客户端通常与数据库服务器建立 TCP 连接，因而对于特定的链接，SQL 语句 BEGIN TRANSACTION 和 COMMIT 之间的所有操作都属于同一个事务。但是这种方式并不完美。如果 TCP 连接中断，事务必须终止。假定中断发生在事务提交之后，服务器确认提交完成之前，客户端最后不知道该事务是否已提交。为了解决这个问题，事务管理器需要定义一个**唯一的事务标识**来逻辑上绑定一组写操作，该事务标识符独立于 TCP 链接。

而许多非关系型数据库则可能不支持**多对象事务**

### 3.2 单对象事务
原子性和隔离性也同样适用于单个对象的更新，比如像数据库写入 20KB 的JSON 文档:
1. 发送第一个 10KB 之后网络连接中断，数据库是否会存储无法完整解析的片段
2. 数据库覆盖磁盘现有数据时故障，新旧值会不会混杂在一起
3. 另一个客户端是否能看到部分更新的文档

因此存储引擎必须实现的就是**单节点、单个对象层面**上提供原子性和隔离性，例如: 基于日志恢复实现原子性，对每个对象加锁来实现隔离

### 3.3 多对象事务的必要性
许多分布式数据库不支持多对象事务，主要是因为当出现**跨分区**时，多对象事务非常难以正确实现，同时在高可用或者极致性能场景下会带来很多负面影响。但是分布式数据库实现事务并非不可能，不存在原理上的限制。

我们是否需要多对象事务？是否有可能只用键值数据模型和单对象操作来实现任何应用程序？的确有可能，但是还有许多情况需要协调写入几个不同的对象:
1. 在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用。多对象事务使你确信这些引用始终有效
2. 缺乏连接功能的文档数据库会鼓励非规范化。当需要更新非规范化的信息时，如 图7-2 所示，需要一次更新多个文档。事务在这种情况下非常有用
3. 在具有二级索引的数据库中（除了纯粹的键值存储以外几乎都有），每次更改值时都需要更新索引。如果没有事务隔离性，记录可能出现在一个索引中，但没有出现在另一个索引中，因为第二个索引的更新还没有发生

### 3.4 处理错误和终止
ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则完全放弃整个事务，而不是部分放弃。然后并不是所欲的系统都遵循上述理念。例如无主复制的数据存储，主要是在“尽力而为”的基础上进行工作。可以概括为“数据库将做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情“ ——所以，从错误中恢复是应用程序的责任。

支持安全的重试机制才是中止流程的重点。尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美：
1. 如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障（所以客户端认为提交失败了），那么重试事务会导致事务被执行两次——除非你有一个额外的应用级除重机制。
2. 如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。
3. 仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的
4. 如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失
5. 如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用。如果你想确保几个不同的系统一起提交或放弃，二阶段提交（2PC, two-phase commit） 可以提供帮助

## 4. 弱隔离级别


