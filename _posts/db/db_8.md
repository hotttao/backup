---
title: 8. 事务
date: 2019-04-08
categories:
    - 分布式
tags:
    - 数据密集型应用
---

事务

<!-- more -->

## 1. 为什么需要事务
事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑单元，要么全部成功(提交)、要么失败(中止或回滚)。如果失败，应用程序可以安全地重试。这样无需担心**部分失败**的情况。事务存在的目的是简化应用层的编程模型。有了事务，应用程序可以不用考虑某些内部潜在的错误以及**复杂的并发性问题**，这些都交给数据库负责处理(称之为**安全性保证**)。

要判断什么时候需要事务，我们需要确切理解**事务能提供哪些安全性保证**，背后的代价是什么。

## 2. 深入理解事务
事务所提供的安全性保证即大家熟悉的 ACID，分表代表:
1. Atomicity: 原子性
2. Consistency: 一致性
3. Isolation: 隔离性
4. Durability: 持久性

但实际上各种数据库所实现的 ACID 并不相同，它们能提供的安全保证也各不相同。

而不符合 ACID 的系统有时被称为 BASE:
1. Basically Available: 基本可用性
2. Soft State: 软状态
3. Eventual Consistency: 最终一致性

接下来我们一一来介绍 原子性、一致性、隔离性和持久性的确切含义。

### 2.1 原子性
ACID 的原子性并不关乎多个操作的并发性，它没有描述多个线程视图访问相同的数据会发生情况，后者其实是由 ACID 的隔离性所定义。原子性其实描述了**客户端发起一个包含多个写操作的请求时可能发生的情况**。把多个写操作纳入到一个原子事务，万一出现了故障而导致没法完成最终提交时，事务会中止，并且数据库会**丢弃或撤销哪些局部完成的更改**。

原型性大大简化了: 如果事务已经中止，应用程序可以确定没有实质发生任何更改，可以安全的重试。

因此 ACID 中原子性所定义的特征是: 在出错时中止事务，并将部分完成的写入全部丢弃。也许**可中止性**更为准确。

### 2.2 一致性
很多场景都存在**一致性**，比如:
1. 副本一致性以及异步复制中，引出的最终一致性问题
2. 一致性哈希
3. CPA 理论中，一致性用来表示线性化
4. ACID 中一致性主要指**数据库处于应用程序所期待的预期状态**

ACID 的一致性主要是指**对数据有特定的预期状态**，任何数据更改必须满足这些**状态约束(或者恒等条件)**。

这种一致性本质上要求应用层来维护状态一致或恒等，应用程序有责任正确的定义事务来保持一致。即如果提供的数据修改为了恒等条件，数据很难检查而组织操作。应用程序可以借助数据库提供的原子性、隔离性达到一致性，但一致性并不源于数据库。因此**C 其实不属于 ACID**。

### 2.3 隔离性
隔离性意味着**并发执行的多个事务相互隔离**，不能相互交叉，不会相互影响，比如一个事务不应该看到其他事务部分执行的中间结果。

隔离性意味着可以假装事务是数据库上运行的唯一事务，尽管实际上可能多个事务在同时运行，数据库系统要保证当事务提交时，其结果与串行执行完全相同。

实际上为了权衡性能和安全性，存在多种隔离级别，待会我们在详述。

### 2.4 持久化
持久化保证一旦事务提交成功，及时存在硬件故障或数据奔溃，事务所写入的任何数据也不会丢失:
1. 对于单节点数据库，持久性意味着数据已经写入非易失性存储设备，写入的过程中，通常还涉及预写日志等，以保证磁盘数据损坏可恢复
2. 对于支持远程复制的数据库，持久化意味着数据已成功复制到多个节点

为了实现持久化，数据库必须等到这些写入或者复制完成之后才能报告事务成功提交。现实情况是没有哪一项技术可以提供绝对的持久性保证，包括写入磁盘、复制到远程以及备份，这些都是降低风险的手段，应该组合使用。

## 3. 多对象事务与单对象事务
### 3.1 多对象事务
多对象事务是指一个事务中会修改多个对象，多对象事务会保证多个数据对象之间保持同步。

多对象事务要求确定知道事务包含了哪些读写操作。对于关系型数据库，客户端通常与数据库服务器建立 TCP 连接，因而对于特定的链接，SQL 语句 BEGIN TRANSACTION 和 COMMIT 之间的所有操作都属于同一个事务。但是这种方式并不完美。如果 TCP 连接中断，事务必须终止。假定中断发生在事务提交之后，服务器确认提交完成之前，客户端最后不知道该事务是否已提交。为了解决这个问题，事务管理器需要定义一个**唯一的事务标识**来逻辑上绑定一组写操作，该事务标识符独立于 TCP 链接。

而许多非关系型数据库则可能不支持**多对象事务**

### 3.2 单对象事务
原子性和隔离性也同样适用于单个对象的更新，比如像数据库写入 20KB 的JSON 文档:
1. 发送第一个 10KB 之后网络连接中断，数据库是否会存储无法完整解析的片段
2. 数据库覆盖磁盘现有数据时故障，新旧值会不会混杂在一起
3. 另一个客户端是否能看到部分更新的文档

因此存储引擎必须实现的就是**单节点、单个对象层面**上提供原子性和隔离性，例如: 基于日志恢复实现原子性，对每个对象加锁来实现隔离

### 3.3 多对象事务的必要性
许多分布式数据库不支持多对象事务，主要是因为当出现**跨分区**时，多对象事务非常难以正确实现，同时在高可用或者极致性能场景下会带来很多负面影响。但是分布式数据库实现事务并非不可能，不存在原理上的限制。

我们是否需要多对象事务？是否有可能只用键值数据模型和单对象操作来实现任何应用程序？的确有可能，但是还有许多情况需要协调写入几个不同的对象:
1. 在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用。多对象事务使你确信这些引用始终有效
2. 缺乏连接功能的文档数据库会鼓励非规范化。当需要更新非规范化的信息时，如 图7-2 所示，需要一次更新多个文档。事务在这种情况下非常有用
3. 在具有二级索引的数据库中（除了纯粹的键值存储以外几乎都有），每次更改值时都需要更新索引。如果没有事务隔离性，记录可能出现在一个索引中，但没有出现在另一个索引中，因为第二个索引的更新还没有发生

### 3.4 处理错误和终止
ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则完全放弃整个事务，而不是部分放弃。然后并不是所欲的系统都遵循上述理念。例如无主复制的数据存储，主要是在“尽力而为”的基础上进行工作。可以概括为“数据库将做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情“ ——所以，从错误中恢复是应用程序的责任。

支持安全的重试机制才是中止流程的重点。尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美：
1. 如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障（所以客户端认为提交失败了），那么重试事务会导致事务被执行两次——除非你有一个额外的应用级除重机制。
2. 如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。
3. 仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的
4. 如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失
5. 如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用。如果你想确保几个不同的系统一起提交或放弃，二阶段提交（2PC, two-phase commit） 可以提供帮助

## 4. 弱隔离级别
只有出现某个事务修改数据而另一个事务同时要读取改数据，或者两个事务同时修改相同数据时，才会引发并发问题。并发问题通常难以测试和发现，所以数据库试图通过事务隔离来对应用程序隐藏内部的各种并发问题。隔离是假装没有发生并发，保证事务最终的执行结果与串行执行结果相同。

但是串行化的隔离会严重影响隔离，许多数据库倾向于采用较弱的隔离级别。这些较弱的隔离级别可以防止但是不是全部的并发问题。

接下来我们就来详细分析几个实际中经常用到的弱级别(非串行化)隔离，并详细讨论可能发生的竞争条件。有了这些认识后，可以帮助我们判断哪些场景适合什么样的隔离级别，最后我们将介绍串行化。

### 4.1 读-提交
读-提交时最基本的事务隔离级别，值提供以下两个保证:
1. 读数据库时，只能看到已成功提交的数据(防止，脏读)
2. 写数据库时，只会覆盖已成功提交的数据(防止，脏写)

#### 防止脏读
脏读是指事务可以看到**其他尚未提交事务部分写入的数据**，读-提交意味着事务的任何写入只有在成功提交后，才能被其他事务观察到(并且所有的写全部可见)。

当有一些需求时，需要防止脏读:
1. 事务需要更新多个对象
2. 如果事务中止，则所有写入操作都需要回滚。如果数据库允许脏读，那就意味着一个事务可能会看到稍后需要回滚的数据，而这些数据并未实际提交到数据库中。

#### 防止脏写
脏写是指事务会覆盖**尚未提交**的其他事务的**部分写入**。读-提交隔离级别可以防止脏写，通常的方式是推迟第二个写请求，直至前面的事务完成提交。

防止脏写，可以避免下面的并发问题:
1. 事务需要更新多个对象

### 实现读-提交
数据库通常采用**行级锁**来防止脏读: 当事务想要修改特定对象（行或文档）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。

使用加锁的方式实现脏读，因为会导致许多只读事务等待太长时间，大多数据库采用这样的方法防止脏读: 对每个待更新的对象，数据库都会维护**其旧值和当前持有锁事务将要设置的新值**两个版本。在事务提交之前，所有其他读操作都读取旧值，仅当写事务提交之后，才会切换到读取新值。

### 4.2 快照级别隔离与可重复读
读-提交，会产生不可重复读，即一个事务内，两次相同的读取可能会读到不同的值。有些场景不能容忍这种暂时的不一致:
1. 备份场景: 备份过程中会继续写入数据，最终的备份数据里可能包含部分旧版本和部分新版本数据
2. 分析查询和完整性检查场景

究其原因，读-提交无法获取数据库的一致性视图。快照级别隔离可以解决这个问题。其总体想法是: 每个事物都从数据库的一致性快照中读取，事物一开始所看到的是最近提交的数据，即使数据随后可能被另一个事物修改，但保证每个事物都只看到改特定时间点的旧数据。

快照级别隔离对长时间运行的只读查询(备份和分析)非常有用。

#### 实现快照级别隔离
与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写，读取不需要加锁，读操作不会阻止写操作，反之亦然。

快照级别隔离的实现使用的是**多版本并发控制**(Multi Version Concurrency Control, MVCC)。每个版本对应正在进行的多个事务在不同的时间点查看到的数据。

如果一个数据库只需要提供读已提交的隔离级别，而不提供快照隔离，那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。所以支持快照隔离的存储引擎往往直接采用MVCC来实现读已提交隔离级别。做法是**对每一个不同的查询**单独创建一个快照。

在 MVCC的实现中，事务开始时，首先会被赋予一个唯一的、单调递增的事务ID，每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务ID。当事务读取数据库时，通过事务ID决定哪些对象可见。仅当以下两个条件都成立时，数据对事务可见:
1. 事务开始时，创建该对象的事务已经完成了提交
2. 对象没有被删除，或者删除了，但是删除事务在当前事务开始时还未提交

#### 索引与快照级别隔离
MVCC 如何支持索引呢？

一种防范是索引直接指向对象的所有版本，然后想办法过滤对当前是事务不可见的那些版本。当后台的垃圾回收进程决定删除某个旧对象是，对应的索引条目也需要删除。

在CouchDB，Datomic和LMDB中使用另一种方法。虽然它们也使用B树，但它们使用的是一种仅追加/写时拷贝（append-only/copy-on-write） 的变体，它们在更新时不覆盖树的页面，而为每个修改页面创建一份副本。从父页面直到树根都会级联更新，以指向它们子页面的新版本。任何不受写入影响的页面都不需要被复制，并且保持不变。

这种追加式的 Btree，每个写入事务都会创建一个新的 B-tree root，代表该时刻数据库的一致性快照。这时就没有必要更具事务 ID 再去过滤某些对象，每笔修改都会修改现有的 Btree，因为之后的查询可以直接作用于特定快照 Btree(有利于查询性能)。采用这种方法依然需要后台进程来执行压缩和垃圾回收。