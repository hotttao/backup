---
title: 2 JavaScript 的面向对象
date: 2020-10-01
categories:
    - 前端
tags:
	- 设计模式
---

动态语言和静态语言由于在类型上根深蒂固的差异，导致了它们在实现设计模式上也有着非常大的不同。

<!-- more -->

## 1. 类型与面向对象
面向对象有四大特性: 封装、抽象、继承、多态，这四大特性是与语言无关的，但是不同语言实现的方式会有或大或小的差异，而类型就是其中重要的影响因素。


在动态类型语言中:
1. 没有强制的类型检查: 在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型
2. 实现面向接口编程，主要通过鸭子类型
3. 不存在任何程度上的“类型耦合“

在静态类型语言中:
1. 由于强制的类型检查，需要通过抽象类或者接口将对象进行向上转型
2. 当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用
3. 多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系，这在静态语言中是必须的

## 2. JavaScript 基于原型的面向对象
JavaScript 基于原型的面向对象与传统的面向对象有很大的不同:
1. 对象创建上:
    - 在以类为中心的面向对象编程语言中，对象总是从类中创建而来
    - 而在原型编程的思想中，类并不是必需的，一个对象是通过克隆另外一个对象所得到的
    - 原型模式的实现关键，是语言本身是否提供了clone方法
2. 实现继承上: 
    - 在原型编程的思想中，基于原型链的委托机制就是原型继承的本质
    - 果对象无法响应某个请求，它会把这个请求委托给它自己的原型

### 2.1 JavaScript中的原型
作为一门基于原型的语言，JavaScript 遵守如下原型编程的基本规则:
1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
3. 对象会记住它的原型
4. 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型

在 JavaScript中
1. 根对象是Object.prototype对象，在JavaScript遇到的每个对象，实际上都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。
2. 用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，再进行一些其他额外操作的过程
3. 就JavaScript的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。
4. 对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型
5. JavaScript给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象