---
title: 10 JavaScript Ajax
date: 2020-08-15
categories:
    - 前端
tags:
	- JavaScript
---
JavaScript 与 服务器通信
<!-- more -->

## 1. Ajax 
Ajax，全称 Asynchronous JavaScript+XML，能够向服务器请求额外的数据而无须卸载页面。Ajax通信与数据格式无关；这种技术就是无须刷新页面即可从服务器取得数据，但不一定是XML数据。

本节我们将介绍 Ajax 的如下实现:
1. XMLHttpRequest: ES5 中 JavaScript 的 http 客户端，能够以异步方式发送请求
2. 

这些技术实现的思路大体上都是相似的，通过内置一个新的对象来封装通信的细节，并通过事件触发的方式来实现异步。JavaScript http 请求与异步编程在 ES6 中得到了很大改进，ES5 中的很多计数目前已经很少使用，因此对上面这些技术我们只介绍基本原理不会详解介绍 API 接口。后面 ES6 部分会详细介绍最新的技术。

不过在此之前我们要学习一下 JavaScript 如何处理 JSON 数据，毕竟这是现在主流的数据交换格式。

## 2.JSON 解析
ECMAScript 5对解析JSON的行为进行规范，定义了全局对象JSON。JSON对象有两个方法:
1. stringify(): 把JavaScript对象序列化为JSON字符串和
2. parse(): 把JSON字符串解析为原生JavaScript值

### 2.1 JSON.stringify
JSON.stringify(js_obj, filter, indentation)
- 参数:
    - js_obj: 被序列化的 JavaScript 值
    - filter: 过滤器，数组或者一个函数
    - indentation: 是否保留缩进
        - 如果这个参数是一个数值，那它表示的是每个级别缩进的空格数
        - 如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符
        - 缩进空格数或字符数最大长度为 10，超过 10 会自动截断为 10 
- 注意:
    - 在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，不体现在结果中
    - 值为undefined的任何属性也都会被跳过

如果过滤器参数是数组，序列化的结果将只包含数组中列出的属性。如果第二个参数是函数，传入的函数接收两个参数，属性（键）名和属性值。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。函数返回的值就是相应键的值，如果函数返回了undefined，那么相应的属性会被忽略。

### 2.2 JSON.parse
JSON.parse(json_string, replacer)
- 参数:
    - json_string: JSON 字符串
    - replacer: 替换函数，接收两个参数属性名和值
        - 如果还原函数返回undefined，则表示要从结果中删除相应的键
        - 如果返回其他值，则将该值插入到结果中。
- 注意:
    - 字符串不是有效的JSON，该方法会抛出错误

```js
var book = JSON.parse('{"name": "中国"}')
```

### 2.3 对象 toJSON 方法
可以给对象定义toJSON()方法，返回其自身的JSON数据格式。假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下:
1. 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身
2. 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值
3. 对第(2)步返回的每个值进行相应的序列化
4. 如果提供了第三个参数，执行相应的格式化

## 2. XMLHTTPRequest
一个使用 XMLHTTPRequest 发送请求到接受响应的完整示例如下所示:

```js
var xhr = new XMLHTTPRequest();
xhr.open("get", "example.php", false); // 启动请求

xhr.setRequestHeader("myHeader", "value"); // 自定义请求头
xhr.send(null); // 发送请求
xhr.abort(); // abort() 方法用于取消异步请求

xhr.getResponseHeader("myHeader"); // 获取响应头信息
xhr.getAllResponseHeader(); // 取得一个包含所有头部信息的长字符串
```

默认情况下，在发送XHR请求的同时，还会发送下列头部信息:
1. Accept：浏览器能够处理的内容类型
2. Accept-Charset：浏览器能够显示的字符集
3. Accept-Encoding：浏览器能够处理的压缩编码
4. Accept-Language：浏览器当前设置的语言
5. Connection：浏览器与服务器之间连接的类型
6. Cookie：当前页面设置的任何Cookie
7. Host：发出请求的页面所在的域
8. Referer：发出请求的页面的URI
9. User-Agent：浏览器的用户代理字符串

在发送请求时:
1. 查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码
2. 使用XHR来模仿表单提交：首先将 Content-Type 头部信息设置为 application/x-www-form-urlencoded

```js
xhr.open("post", "postexample.php", false); // 启动请求
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // 自定义请求头
var form = document.getElementById("form");
xhr.send(serialize(form)); // 将页面中表单的数据进行序列化
```

### 2.1 请求发送
XMLHTTPRequest.open(method, url, async)
- 作用: 不会真正发送请求，而只是启动一个请求以备发送
- 参数:
    - method: get/post
    - url: URL相对于执行代码的当前页面
    - async: 是否以同步方式发送请求，false 以同步方式发送请求 

XMLHTTPRequest.send(body)
- 作用: 发送请求
- 参数: 
    - body: 作为请求主体发送的数据，如果不需要通过请求主体发送数据，则必须传入null(为了浏览器兼容)

XMLHTTPRequest.abort():
- 作用: 取消异步请求
- 注意: 
    - 调用这个方法后，XHR对象会停止触发事件
    - 也不再允许访问任何与响应有关的对象属性
    - 在终止请求之后，还应该对XHR对象进行解引用操作
    - 由于内存原因，不建议重用XHR对象。

XMLHTTPRequest.setRequestHeader(header, value):
- 作用: 自定义请求头部
- 注意: 必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()

### 2.2 接受响应
在收到响应后，响应的数据会自动填充XHR对象的如下属性:
1. responseText：作为响应主体被返回的文本
2. responseXML：如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的XML DOM文档
3. status：响应的HTTP状态
4. statusText: HTTP状态的说明

在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。

```js
if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 ){
    alter(xhr.responseText);
} else {
    alter("Request unsucess" + xhr.status);
}
```

### 2.3 XMLHTTPRequest 异步事件
异步发送请求时，通过检测 XHR 对象的 readyState 属性，可以判断请求/响应当前活动阶段:
1. 0：未初始化，尚未调用open()方法
2. 1：启动，已经调用open()方法，但尚未调用send()方法
3. 2：发送，已经调用send()方法，但尚未接收到响应
4. 3：接收，已经接收到部分响应数据
5. 4：完成，已经接收到全部响应数据，而且已经可以在客户端使用了

只要readyState属性的值由一个值变成另一个值，都会触发一次readystatechange事件。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。

```js
var xhr = XMLHTTPRequest();

xhr.onreadystatechange = function(){
    if (xhr.readstatechange == 4){
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 ){
            alter(xhr.responseText);
        } else {
            alter("Request unsucess" + xhr.status);
        }
    }
};

xhr.open("get", "example.php", true);
xhr.send(null);
```

这里有两点需要注意的地方:
1. 与其他事件处理程序不同，这里没有向onreadystatechange事件处理程序中传递event对象；必须通过XHR对象本身来确定下一步该怎么做
2. 没有使用this对象，原因是onreadystatechange事件处理程序的作用域问题。如果使用this对象，在有的浏览器中会导致函数执行失败，或者导致错误发生

### 2.4 formData
